diff --git a/ChangeLog b/ChangeLog
index 675f019..03cbfc0 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,122 @@
+2014-12-13  Werner Lemberg  <wl@gnu.org>
+
+	* src/pcf/pcfread.c (pcf_read_TOC): Improve fix from 2014-12-08.
+
+2014-12-11  Werner Lemberg  <wl@gnu.org>
+
+	* builds/toplevel.mk (dist): Use older POSIX standard for `tar'.
+
+	Apparently, BSD tar isn't capable yet of handling POSIX-1.2001
+	(contrary to GNU tar), so force the POSIX-1.1988 format.
+
+	Problem reported by Stephen Fisher <sfisher@SDF.ORG>.
+
+2014-12-11  Werner Lemberg  <wl@gnu.org>
+
+	* src/type42/t42parse.c (t42_parse_sfnts): Reject invalid TTF size.
+
+2014-12-11  Werner Lemberg  <wl@gnu.org>
+
+	* src/base/ftobjs.c (FT_Get_Glyph_Name): Fix off-by-one check.
+
+	Problem reported by Dennis Felsing <dennis@felsin9.de>.
+
+2014-12-11  Werner Lemberg  <wl@gnu.org>
+
+	* src/type42/t42parse.c (t42_parse_sfnts): Check `string_size'.
+
+	Problem reported by Dennis Felsing <dennis@felsin9.de>.
+
+2014-12-09  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
+
+	[gxvalid] Fix a naming convention conflicting with ftvalid.
+
+	See previous changeset for otvalid.
+
+	* src/gxvalid/{gxvcommn.h, gxvmort.h, gxvmorx.h}: Replace
+	`valid' by `gxvalid'.
+	* src/gxvalid/{gxvbsln.c, gxvcommn.c, gxvfeat.c, gxvjust.c,
+	gxvkern.c, gxvlcar.c, gxvmort.c, gxvmort0.c, gxvmort1.c,
+	gxvmort2.c, gxvmort4.c, gxvmort5.c, gxvmorx.c, gxvmorx0.c,
+	gxvmorx1.c, gxvmorx2.c, gxvmorx4.c, gxvmorx5.c, gxvopbd.c,
+	gxvprop.c, gxvtrak.c}: Replace `valid' by `gxvalid' if
+	it is typed as GXV_Validator.
+
+2014-12-09  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
+
+	[otvalid] Fix a naming convention conflicting with ftvalid.
+
+	Some prototypes in ftvalid.h use `valid' for the variables
+	typed as FT_Validator.  Their implementations in src/base/
+	ftobjs.c and utilizations in src/sfnt/ttcmap.c do similar.
+
+	Some macros in otvcommn.h assume the exist of the variable
+	`valid' typed as OTV_Validator in the caller.
+
+	Mixing these two conventions cause invalid pointer conversion
+	and unexpected SEGV in longjmp.  To prevent it, all variables
+	typed as OTV_Validator are renamed to `otvalid'.
+
+	* src/otvalid/otvcommn.h: Replace `valid' by `otvalid'.
+	* src/otvalid/{otvcommn.c, otvbase.c, otvgdef.c, otvgpos.c,
+	otvgsub.c, otvjstf.c, otvmath.c}: Replace `valid' by `otvalid'
+	if it is typed as OTV_Validator.
+
+2014-12-09  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
+
+	[ftvalid] Introduce FT_THROW() in FT_INVALID_XXX macros.
+
+	Original patch is designed by Werner Lemberg.  Extra part
+	for otvalid and gxvalid are added by suzuki toshiya, see
+	discussion:
+	http://lists.nongnu.org/archive/html/freetype-devel/2014-12/msg00002.html
+	http://lists.nongnu.org/archive/html/freetype-devel/2014-12/msg00007.html
+
+	* include/internal/ftvalid.h: Introduce FT_THROW() in FT_INVALID_().
+	* src/gxvalid/gxvcommn.h: Ditto.
+	* src/otvalid/otvcommn.h: Ditto.
+
+2014-12-08  Werner Lemberg  <wl@gnu.org>
+
+	[pcf] Fix Savannah bug #43774.
+
+	Work around `features' of X11's `pcfWriteFont' and `pcfReadFont'
+	functions.  Since the PCF format doesn't have an official
+	specification, we have to exactly follow these functions' behaviour.
+
+	The problem was unveiled with a patch from 2014-11-06, fixing issue
+	#43547.
+
+	* src/pcf/pcfread.c (pcf_read_TOC): Don't check table size for last
+	element.  Instead, assign real size.
+
+2014-12-07  Werner Lemberg  <wl@gnu.org>
+
+	Work around a bug in Borland's C++ compiler.
+
+	See
+
+	  http://qc.embarcadero.com/wc/qcmain.aspx?d=118998
+
+	for Borland's bug tracker entry.
+
+	Reported by Yuliana Zigangirova <zigangirova@inbox.ru>,
+	http://lists.gnu.org/archive/html/freetype-devel/2014-04/msg00001.html.
+
+	* include/internal/ftvalid.h (FT_ValidatorRec), src/smooth/ftgrays.c
+	(gray_TWorker_): Move `ft_jmp_buf' field to be the first element.
+
+2014-12-07  Werner Lemberg  <wl@gnu.org>
+
+	*/*: Decorate hex constants with `U' and `L' where appropriate.
+
+2014-12-07  Werner Lemberg  <wl@gnu.org>
+
+	[truetype] Prevent memory leak for buggy fonts.
+
+	* src/truetype/ttobjs.c (tt_size_done): Unconditionally call
+	`tt_size_done_bytecode'.
+
 2014-12-06  Werner Lemberg  <wl@gnu.org>
 
 	* Version 2.5.4 released.
diff --git a/builds/toplevel.mk b/builds/toplevel.mk
index 812750a..78983f8 100644
--- a/builds/toplevel.mk
+++ b/builds/toplevel.mk
@@ -220,9 +220,9 @@ dist:
 
 	mv tmp freetype-$(version)
 
-	tar cfh - freetype-$(version) \
+	tar -H ustar -cfh - freetype-$(version) \
 	| gzip -9 -c > freetype-$(version).tar.gz
-	tar cfh - freetype-$(version) \
+	tar -H ustar -cfh - freetype-$(version) \
 	| bzip2 -c > freetype-$(version).tar.bz2
 
 	@# Use CR/LF for zip files.
diff --git a/docs/release b/docs/release
index cf1f643..98f16cd 100644
--- a/docs/release
+++ b/docs/release
@@ -41,7 +41,8 @@ How to prepare a new release
 . Run  src/tools/chktrcmp.py  and check  that there  are no  undefined
   trace_XXXX macros.
 
-. Tag the git repositories (freetype2, freetype2-demos) with
+. After pushing the new release,  tag the git repositories (freetype2,
+  freetype2-demos) with
 
     git tag VER-<version> -m "" -u <committer>
 
@@ -188,7 +189,7 @@ How to prepare a new release
 
 ----------------------------------------------------------------------
 
-Copyright 2003, 2005-2007, 2009, 2011-2013 by
+Copyright 2003, 2005-2007, 2009, 2011-2014 by
 David Turner, Robert Wilhelm, and Werner Lemberg.
 
 This  file is  part of  the FreeType  project, and  may only  be used,
diff --git a/include/ftlcdfil.h b/include/ftlcdfil.h
index 39206f0..e8679c1 100644
--- a/include/ftlcdfil.h
+++ b/include/ftlcdfil.h
@@ -5,7 +5,7 @@
 /*    FreeType API for color filtering of subpixel bitmap glyphs           */
 /*    (specification).                                                     */
 /*                                                                         */
-/*  Copyright 2006-2008, 2010, 2013 by                                     */
+/*  Copyright 2006-2008, 2010, 2013, 2014 by                               */
 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
 /*                                                                         */
 /*  This file is part of the FreeType project, and may only be used,       */
@@ -56,7 +56,7 @@ FT_BEGIN_HEADER
    *
    *   FreeType generates alpha coverage maps, which are linear by nature.
    *   For instance, the value 0x80 in bitmap representation means that
-   *   (within numerical precision) 0x80/0xff fraction of that pixel is
+   *   (within numerical precision) 0x80/0xFF fraction of that pixel is
    *   covered by the glyph's outline.  The blending function for placing
    *   text over a background is
    *
diff --git a/include/ftsystem.h b/include/ftsystem.h
index 2c95cbb..7436ed2 100644
--- a/include/ftsystem.h
+++ b/include/ftsystem.h
@@ -4,7 +4,7 @@
 /*                                                                         */
 /*    FreeType low-level system interface definition (specification).      */
 /*                                                                         */
-/*  Copyright 1996-2001, 2002, 2005, 2010 by                               */
+/*  Copyright 1996-2001, 2002, 2005, 2010, 2014 by                         */
 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
 /*                                                                         */
 /*  This file is part of the FreeType project, and may only be used,       */
@@ -192,6 +192,10 @@ FT_BEGIN_HEADER
    * @description:
    *   A handle to an input stream.
    *
+   * @also:
+   *   See @FT_StreamRec for the publicly accessible fields of a given
+   *   stream object.
+   *
    */
   typedef struct FT_StreamRec_*  FT_Stream;
 
@@ -285,6 +289,11 @@ FT_BEGIN_HEADER
    *   size ::
    *     The stream size in bytes.
    *
+   *     In case of compressed streams where the size is unknown before
+   *     actually doing the decompression, the value is set to 0x7FFFFFFF. 
+   *     (Note that this size value can occur for normal streams also; it is
+   *     thus just a hint.)
+   *
    *   pos ::
    *     The current position within the stream.
    *
diff --git a/include/internal/ftvalid.h b/include/internal/ftvalid.h
index 12ad036..c281b14 100644
--- a/include/internal/ftvalid.h
+++ b/include/internal/ftvalid.h
@@ -4,7 +4,7 @@
 /*                                                                         */
 /*    FreeType validation support (specification).                         */
 /*                                                                         */
-/*  Copyright 2004, 2013 by                                                */
+/*  Copyright 2004, 2013, 2014 by                                          */
 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
 /*                                                                         */
 /*  This file is part of the FreeType project, and may only be used,       */
@@ -87,13 +87,13 @@ FT_BEGIN_HEADER
   /* validator structure */
   typedef struct  FT_ValidatorRec_
   {
+    ft_jmp_buf          jump_buffer; /* used for exception handling      */
+
     const FT_Byte*      base;        /* address of table in memory       */
     const FT_Byte*      limit;       /* `base' + sizeof(table) in memory */
     FT_ValidationLevel  level;       /* validation level                 */
     FT_Error            error;       /* error returned. 0 means success  */
 
-    ft_jmp_buf          jump_buffer; /* used for exception handling      */
-
   } FT_ValidatorRec;
 
 #if defined( _MSC_VER )
@@ -126,31 +126,29 @@ FT_BEGIN_HEADER
   /* Calls ft_validate_error.  Assumes that the `valid' local variable */
   /* holds a pointer to the current validator object.                  */
   /*                                                                   */
-  /* Use preprocessor prescan to pass FT_ERR_PREFIX.                   */
-  /*                                                                   */
-#define FT_INVALID( _prefix, _error )  FT_INVALID_( _prefix, _error )
-#define FT_INVALID_( _prefix, _error ) \
-          ft_validator_error( valid, _prefix ## _error )
+#define FT_INVALID( _error )  FT_INVALID_( _error )
+#define FT_INVALID_( _error ) \
+          ft_validator_error( valid, FT_THROW( _error ) )
 
   /* called when a broken table is detected */
 #define FT_INVALID_TOO_SHORT \
-          FT_INVALID( FT_ERR_PREFIX, Invalid_Table )
+          FT_INVALID( Invalid_Table )
 
   /* called when an invalid offset is detected */
 #define FT_INVALID_OFFSET \
-          FT_INVALID( FT_ERR_PREFIX, Invalid_Offset )
+          FT_INVALID( Invalid_Offset )
 
   /* called when an invalid format/value is detected */
 #define FT_INVALID_FORMAT \
-          FT_INVALID( FT_ERR_PREFIX, Invalid_Table )
+          FT_INVALID( Invalid_Table )
 
   /* called when an invalid glyph index is detected */
 #define FT_INVALID_GLYPH_ID \
-          FT_INVALID( FT_ERR_PREFIX, Invalid_Glyph_Index )
+          FT_INVALID( Invalid_Glyph_Index )
 
   /* called when an invalid field value is detected */
 #define FT_INVALID_DATA \
-          FT_INVALID( FT_ERR_PREFIX, Invalid_Table )
+          FT_INVALID( Invalid_Table )
 
 
 FT_END_HEADER
diff --git a/include/ttnameid.h b/include/ttnameid.h
index 9711d1d..e65b558 100644
--- a/include/ttnameid.h
+++ b/include/ttnameid.h
@@ -4,7 +4,7 @@
 /*                                                                         */
 /*    TrueType name ID definitions (specification only).                   */
 /*                                                                         */
-/*  Copyright 1996-2004, 2006-2008, 2012, 2013 by                          */
+/*  Copyright 1996-2004, 2006-2008, 2012-2014 by                           */
 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
 /*                                                                         */
 /*  This file is part of the FreeType project, and may only be used,       */
@@ -470,26 +470,26 @@ FT_BEGIN_HEADER
 #define TT_MS_LANGID_ARABIC_GENERAL                    0x0001
 #define TT_MS_LANGID_ARABIC_SAUDI_ARABIA               0x0401
 #define TT_MS_LANGID_ARABIC_IRAQ                       0x0801
-#define TT_MS_LANGID_ARABIC_EGYPT                      0x0c01
+#define TT_MS_LANGID_ARABIC_EGYPT                      0x0C01
 #define TT_MS_LANGID_ARABIC_LIBYA                      0x1001
 #define TT_MS_LANGID_ARABIC_ALGERIA                    0x1401
 #define TT_MS_LANGID_ARABIC_MOROCCO                    0x1801
-#define TT_MS_LANGID_ARABIC_TUNISIA                    0x1c01
+#define TT_MS_LANGID_ARABIC_TUNISIA                    0x1C01
 #define TT_MS_LANGID_ARABIC_OMAN                       0x2001
 #define TT_MS_LANGID_ARABIC_YEMEN                      0x2401
 #define TT_MS_LANGID_ARABIC_SYRIA                      0x2801
-#define TT_MS_LANGID_ARABIC_JORDAN                     0x2c01
+#define TT_MS_LANGID_ARABIC_JORDAN                     0x2C01
 #define TT_MS_LANGID_ARABIC_LEBANON                    0x3001
 #define TT_MS_LANGID_ARABIC_KUWAIT                     0x3401
 #define TT_MS_LANGID_ARABIC_UAE                        0x3801
-#define TT_MS_LANGID_ARABIC_BAHRAIN                    0x3c01
+#define TT_MS_LANGID_ARABIC_BAHRAIN                    0x3C01
 #define TT_MS_LANGID_ARABIC_QATAR                      0x4001
 #define TT_MS_LANGID_BULGARIAN_BULGARIA                0x0402
 #define TT_MS_LANGID_CATALAN_SPAIN                     0x0403
 #define TT_MS_LANGID_CHINESE_GENERAL                   0x0004
 #define TT_MS_LANGID_CHINESE_TAIWAN                    0x0404
 #define TT_MS_LANGID_CHINESE_PRC                       0x0804
-#define TT_MS_LANGID_CHINESE_HONG_KONG                 0x0c04
+#define TT_MS_LANGID_CHINESE_HONG_KONG                 0x0C04
 #define TT_MS_LANGID_CHINESE_SINGAPORE                 0x1004
 
 #if 1  /* this looks like the correct value */
@@ -507,7 +507,7 @@ FT_BEGIN_HEADER
 #define TT_MS_LANGID_DANISH_DENMARK                    0x0406
 #define TT_MS_LANGID_GERMAN_GERMANY                    0x0407
 #define TT_MS_LANGID_GERMAN_SWITZERLAND                0x0807
-#define TT_MS_LANGID_GERMAN_AUSTRIA                    0x0c07
+#define TT_MS_LANGID_GERMAN_AUSTRIA                    0x0C07
 #define TT_MS_LANGID_GERMAN_LUXEMBOURG                 0x1007
 #define TT_MS_LANGID_GERMAN_LIECHTENSTEI               0x1407
 #define TT_MS_LANGID_GREEK_GREECE                      0x0408
@@ -520,69 +520,69 @@ FT_BEGIN_HEADER
 #define TT_MS_LANGID_ENGLISH_GENERAL                   0x0009
 #define TT_MS_LANGID_ENGLISH_UNITED_STATES             0x0409
 #define TT_MS_LANGID_ENGLISH_UNITED_KINGDOM            0x0809
-#define TT_MS_LANGID_ENGLISH_AUSTRALIA                 0x0c09
+#define TT_MS_LANGID_ENGLISH_AUSTRALIA                 0x0C09
 #define TT_MS_LANGID_ENGLISH_CANADA                    0x1009
 #define TT_MS_LANGID_ENGLISH_NEW_ZEALAND               0x1409
 #define TT_MS_LANGID_ENGLISH_IRELAND                   0x1809
-#define TT_MS_LANGID_ENGLISH_SOUTH_AFRICA              0x1c09
+#define TT_MS_LANGID_ENGLISH_SOUTH_AFRICA              0x1C09
 #define TT_MS_LANGID_ENGLISH_JAMAICA                   0x2009
 #define TT_MS_LANGID_ENGLISH_CARIBBEAN                 0x2409
 #define TT_MS_LANGID_ENGLISH_BELIZE                    0x2809
-#define TT_MS_LANGID_ENGLISH_TRINIDAD                  0x2c09
+#define TT_MS_LANGID_ENGLISH_TRINIDAD                  0x2C09
 #define TT_MS_LANGID_ENGLISH_ZIMBABWE                  0x3009
 #define TT_MS_LANGID_ENGLISH_PHILIPPINES               0x3409
 #define TT_MS_LANGID_ENGLISH_INDONESIA                 0x3809
-#define TT_MS_LANGID_ENGLISH_HONG_KONG                 0x3c09
+#define TT_MS_LANGID_ENGLISH_HONG_KONG                 0x3C09
 #define TT_MS_LANGID_ENGLISH_INDIA                     0x4009
 #define TT_MS_LANGID_ENGLISH_MALAYSIA                  0x4409
 #define TT_MS_LANGID_ENGLISH_SINGAPORE                 0x4809
-#define TT_MS_LANGID_SPANISH_SPAIN_TRADITIONAL_SORT    0x040a
-#define TT_MS_LANGID_SPANISH_MEXICO                    0x080a
-#define TT_MS_LANGID_SPANISH_SPAIN_INTERNATIONAL_SORT  0x0c0a
-#define TT_MS_LANGID_SPANISH_GUATEMALA                 0x100a
-#define TT_MS_LANGID_SPANISH_COSTA_RICA                0x140a
-#define TT_MS_LANGID_SPANISH_PANAMA                    0x180a
-#define TT_MS_LANGID_SPANISH_DOMINICAN_REPUBLIC        0x1c0a
-#define TT_MS_LANGID_SPANISH_VENEZUELA                 0x200a
-#define TT_MS_LANGID_SPANISH_COLOMBIA                  0x240a
-#define TT_MS_LANGID_SPANISH_PERU                      0x280a
-#define TT_MS_LANGID_SPANISH_ARGENTINA                 0x2c0a
-#define TT_MS_LANGID_SPANISH_ECUADOR                   0x300a
-#define TT_MS_LANGID_SPANISH_CHILE                     0x340a
-#define TT_MS_LANGID_SPANISH_URUGUAY                   0x380a
-#define TT_MS_LANGID_SPANISH_PARAGUAY                  0x3c0a
-#define TT_MS_LANGID_SPANISH_BOLIVIA                   0x400a
-#define TT_MS_LANGID_SPANISH_EL_SALVADOR               0x440a
-#define TT_MS_LANGID_SPANISH_HONDURAS                  0x480a
-#define TT_MS_LANGID_SPANISH_NICARAGUA                 0x4c0a
-#define TT_MS_LANGID_SPANISH_PUERTO_RICO               0x500a
-#define TT_MS_LANGID_SPANISH_UNITED_STATES             0x540a
+#define TT_MS_LANGID_SPANISH_SPAIN_TRADITIONAL_SORT    0x040A
+#define TT_MS_LANGID_SPANISH_MEXICO                    0x080A
+#define TT_MS_LANGID_SPANISH_SPAIN_INTERNATIONAL_SORT  0x0C0A
+#define TT_MS_LANGID_SPANISH_GUATEMALA                 0x100A
+#define TT_MS_LANGID_SPANISH_COSTA_RICA                0x140A
+#define TT_MS_LANGID_SPANISH_PANAMA                    0x180A
+#define TT_MS_LANGID_SPANISH_DOMINICAN_REPUBLIC        0x1C0A
+#define TT_MS_LANGID_SPANISH_VENEZUELA                 0x200A
+#define TT_MS_LANGID_SPANISH_COLOMBIA                  0x240A
+#define TT_MS_LANGID_SPANISH_PERU                      0x280A
+#define TT_MS_LANGID_SPANISH_ARGENTINA                 0x2C0A
+#define TT_MS_LANGID_SPANISH_ECUADOR                   0x300A
+#define TT_MS_LANGID_SPANISH_CHILE                     0x340A
+#define TT_MS_LANGID_SPANISH_URUGUAY                   0x380A
+#define TT_MS_LANGID_SPANISH_PARAGUAY                  0x3C0A
+#define TT_MS_LANGID_SPANISH_BOLIVIA                   0x400A
+#define TT_MS_LANGID_SPANISH_EL_SALVADOR               0x440A
+#define TT_MS_LANGID_SPANISH_HONDURAS                  0x480A
+#define TT_MS_LANGID_SPANISH_NICARAGUA                 0x4C0A
+#define TT_MS_LANGID_SPANISH_PUERTO_RICO               0x500A
+#define TT_MS_LANGID_SPANISH_UNITED_STATES             0x540A
   /* The following ID blatantly violate MS specs by using a */
   /* sublanguage > 0x1F.                                    */
-#define TT_MS_LANGID_SPANISH_LATIN_AMERICA             0xE40aU
-#define TT_MS_LANGID_FINNISH_FINLAND                   0x040b
-#define TT_MS_LANGID_FRENCH_FRANCE                     0x040c
-#define TT_MS_LANGID_FRENCH_BELGIUM                    0x080c
-#define TT_MS_LANGID_FRENCH_CANADA                     0x0c0c
-#define TT_MS_LANGID_FRENCH_SWITZERLAND                0x100c
-#define TT_MS_LANGID_FRENCH_LUXEMBOURG                 0x140c
-#define TT_MS_LANGID_FRENCH_MONACO                     0x180c
-#define TT_MS_LANGID_FRENCH_WEST_INDIES                0x1c0c
-#define TT_MS_LANGID_FRENCH_REUNION                    0x200c
-#define TT_MS_LANGID_FRENCH_CONGO                      0x240c
+#define TT_MS_LANGID_SPANISH_LATIN_AMERICA             0xE40AU
+#define TT_MS_LANGID_FINNISH_FINLAND                   0x040B
+#define TT_MS_LANGID_FRENCH_FRANCE                     0x040C
+#define TT_MS_LANGID_FRENCH_BELGIUM                    0x080C
+#define TT_MS_LANGID_FRENCH_CANADA                     0x0C0C
+#define TT_MS_LANGID_FRENCH_SWITZERLAND                0x100C
+#define TT_MS_LANGID_FRENCH_LUXEMBOURG                 0x140C
+#define TT_MS_LANGID_FRENCH_MONACO                     0x180C
+#define TT_MS_LANGID_FRENCH_WEST_INDIES                0x1C0C
+#define TT_MS_LANGID_FRENCH_REUNION                    0x200C
+#define TT_MS_LANGID_FRENCH_CONGO                      0x240C
   /* which was formerly: */
 #define TT_MS_LANGID_FRENCH_ZAIRE  TT_MS_LANGID_FRENCH_CONGO
-#define TT_MS_LANGID_FRENCH_SENEGAL                    0x280c
-#define TT_MS_LANGID_FRENCH_CAMEROON                   0x2c0c
-#define TT_MS_LANGID_FRENCH_COTE_D_IVOIRE              0x300c
-#define TT_MS_LANGID_FRENCH_MALI                       0x340c
-#define TT_MS_LANGID_FRENCH_MOROCCO                    0x380c
-#define TT_MS_LANGID_FRENCH_HAITI                      0x3c0c
-  /* and another violation of the spec (see 0xE40aU) */
-#define TT_MS_LANGID_FRENCH_NORTH_AFRICA               0xE40cU
-#define TT_MS_LANGID_HEBREW_ISRAEL                     0x040d
-#define TT_MS_LANGID_HUNGARIAN_HUNGARY                 0x040e
-#define TT_MS_LANGID_ICELANDIC_ICELAND                 0x040f
+#define TT_MS_LANGID_FRENCH_SENEGAL                    0x280C
+#define TT_MS_LANGID_FRENCH_CAMEROON                   0x2C0C
+#define TT_MS_LANGID_FRENCH_COTE_D_IVOIRE              0x300C
+#define TT_MS_LANGID_FRENCH_MALI                       0x340C
+#define TT_MS_LANGID_FRENCH_MOROCCO                    0x380C
+#define TT_MS_LANGID_FRENCH_HAITI                      0x3C0C
+  /* and another violation of the spec (see 0xE40AU) */
+#define TT_MS_LANGID_FRENCH_NORTH_AFRICA               0xE40CU
+#define TT_MS_LANGID_HEBREW_ISRAEL                     0x040D
+#define TT_MS_LANGID_HUNGARIAN_HUNGARY                 0x040E
+#define TT_MS_LANGID_ICELANDIC_ICELAND                 0x040F
 #define TT_MS_LANGID_ITALIAN_ITALY                     0x0410
 #define TT_MS_LANGID_ITALIAN_SWITZERLAND               0x0810
 #define TT_MS_LANGID_JAPANESE_JAPAN                    0x0411
@@ -600,27 +600,27 @@ FT_BEGIN_HEADER
 #define TT_MS_LANGID_MOLDAVIAN_MOLDAVIA                0x0818
 #define TT_MS_LANGID_RUSSIAN_RUSSIA                    0x0419
 #define TT_MS_LANGID_RUSSIAN_MOLDAVIA                  0x0819
-#define TT_MS_LANGID_CROATIAN_CROATIA                  0x041a
-#define TT_MS_LANGID_SERBIAN_SERBIA_LATIN              0x081a
-#define TT_MS_LANGID_SERBIAN_SERBIA_CYRILLIC           0x0c1a
+#define TT_MS_LANGID_CROATIAN_CROATIA                  0x041A
+#define TT_MS_LANGID_SERBIAN_SERBIA_LATIN              0x081A
+#define TT_MS_LANGID_SERBIAN_SERBIA_CYRILLIC           0x0C1A
 
 #if 0  /* this used to be this value, but it looks like we were wrong */
-#define TT_MS_LANGID_BOSNIAN_BOSNIA_HERZEGOVINA        0x101a
+#define TT_MS_LANGID_BOSNIAN_BOSNIA_HERZEGOVINA        0x101A
 #else  /* current sources say */
-#define TT_MS_LANGID_CROATIAN_BOSNIA_HERZEGOVINA       0x101a
-#define TT_MS_LANGID_BOSNIAN_BOSNIA_HERZEGOVINA        0x141a
+#define TT_MS_LANGID_CROATIAN_BOSNIA_HERZEGOVINA       0x101A
+#define TT_MS_LANGID_BOSNIAN_BOSNIA_HERZEGOVINA        0x141A
        /* and XPsp2 Platform SDK added (2004-07-26) */
        /* Names are shortened to be significant within 40 chars. */
-#define TT_MS_LANGID_SERBIAN_BOSNIA_HERZ_LATIN         0x181a
-#define TT_MS_LANGID_SERBIAN_BOSNIA_HERZ_CYRILLIC      0x181a
+#define TT_MS_LANGID_SERBIAN_BOSNIA_HERZ_LATIN         0x181A
+#define TT_MS_LANGID_SERBIAN_BOSNIA_HERZ_CYRILLIC      0x181A
 #endif
 
-#define TT_MS_LANGID_SLOVAK_SLOVAKIA                   0x041b
-#define TT_MS_LANGID_ALBANIAN_ALBANIA                  0x041c
-#define TT_MS_LANGID_SWEDISH_SWEDEN                    0x041d
-#define TT_MS_LANGID_SWEDISH_FINLAND                   0x081d
-#define TT_MS_LANGID_THAI_THAILAND                     0x041e
-#define TT_MS_LANGID_TURKISH_TURKEY                    0x041f
+#define TT_MS_LANGID_SLOVAK_SLOVAKIA                   0x041B
+#define TT_MS_LANGID_ALBANIAN_ALBANIA                  0x041C
+#define TT_MS_LANGID_SWEDISH_SWEDEN                    0x041D
+#define TT_MS_LANGID_SWEDISH_FINLAND                   0x081D
+#define TT_MS_LANGID_THAI_THAILAND                     0x041E
+#define TT_MS_LANGID_TURKISH_TURKEY                    0x041F
 #define TT_MS_LANGID_URDU_PAKISTAN                     0x0420
 #define TT_MS_LANGID_URDU_INDIA                        0x0820
 #define TT_MS_LANGID_INDONESIAN_INDONESIA              0x0421
@@ -633,13 +633,13 @@ FT_BEGIN_HEADER
 #define TT_MS_LANGID_CLASSIC_LITHUANIAN_LITHUANIA      0x0827
 #define TT_MS_LANGID_TAJIK_TAJIKISTAN                  0x0428
 #define TT_MS_LANGID_FARSI_IRAN                        0x0429
-#define TT_MS_LANGID_VIETNAMESE_VIET_NAM               0x042a
-#define TT_MS_LANGID_ARMENIAN_ARMENIA                  0x042b
-#define TT_MS_LANGID_AZERI_AZERBAIJAN_LATIN            0x042c
-#define TT_MS_LANGID_AZERI_AZERBAIJAN_CYRILLIC         0x082c
-#define TT_MS_LANGID_BASQUE_SPAIN                      0x042d
-#define TT_MS_LANGID_SORBIAN_GERMANY                   0x042e
-#define TT_MS_LANGID_MACEDONIAN_MACEDONIA              0x042f
+#define TT_MS_LANGID_VIETNAMESE_VIET_NAM               0x042A
+#define TT_MS_LANGID_ARMENIAN_ARMENIA                  0x042B
+#define TT_MS_LANGID_AZERI_AZERBAIJAN_LATIN            0x042C
+#define TT_MS_LANGID_AZERI_AZERBAIJAN_CYRILLIC         0x082C
+#define TT_MS_LANGID_BASQUE_SPAIN                      0x042D
+#define TT_MS_LANGID_SORBIAN_GERMANY                   0x042E
+#define TT_MS_LANGID_MACEDONIAN_MACEDONIA              0x042F
 #define TT_MS_LANGID_SUTU_SOUTH_AFRICA                 0x0430
 #define TT_MS_LANGID_TSONGA_SOUTH_AFRICA               0x0431
 #define TT_MS_LANGID_TSWANA_SOUTH_AFRICA               0x0432
@@ -650,32 +650,32 @@ FT_BEGIN_HEADER
 #define TT_MS_LANGID_GEORGIAN_GEORGIA                  0x0437
 #define TT_MS_LANGID_FAEROESE_FAEROE_ISLANDS           0x0438
 #define TT_MS_LANGID_HINDI_INDIA                       0x0439
-#define TT_MS_LANGID_MALTESE_MALTA                     0x043a
+#define TT_MS_LANGID_MALTESE_MALTA                     0x043A
   /* Added by XPsp2 Platform SDK (2004-07-26) */
-#define TT_MS_LANGID_SAMI_NORTHERN_NORWAY              0x043b
-#define TT_MS_LANGID_SAMI_NORTHERN_SWEDEN              0x083b
-#define TT_MS_LANGID_SAMI_NORTHERN_FINLAND             0x0C3b
-#define TT_MS_LANGID_SAMI_LULE_NORWAY                  0x103b
-#define TT_MS_LANGID_SAMI_LULE_SWEDEN                  0x143b
-#define TT_MS_LANGID_SAMI_SOUTHERN_NORWAY              0x183b
-#define TT_MS_LANGID_SAMI_SOUTHERN_SWEDEN              0x1C3b
-#define TT_MS_LANGID_SAMI_SKOLT_FINLAND                0x203b
-#define TT_MS_LANGID_SAMI_INARI_FINLAND                0x243b
+#define TT_MS_LANGID_SAMI_NORTHERN_NORWAY              0x043B
+#define TT_MS_LANGID_SAMI_NORTHERN_SWEDEN              0x083B
+#define TT_MS_LANGID_SAMI_NORTHERN_FINLAND             0x0C3B
+#define TT_MS_LANGID_SAMI_LULE_NORWAY                  0x103B
+#define TT_MS_LANGID_SAMI_LULE_SWEDEN                  0x143B
+#define TT_MS_LANGID_SAMI_SOUTHERN_NORWAY              0x183B
+#define TT_MS_LANGID_SAMI_SOUTHERN_SWEDEN              0x1C3B
+#define TT_MS_LANGID_SAMI_SKOLT_FINLAND                0x203B
+#define TT_MS_LANGID_SAMI_INARI_FINLAND                0x243B
   /* ... and we also keep our old identifier... */
-#define TT_MS_LANGID_SAAMI_LAPONIA                     0x043b
+#define TT_MS_LANGID_SAAMI_LAPONIA                     0x043B
 
 #if 0 /* this seems to be a previous inversion */
-#define TT_MS_LANGID_IRISH_GAELIC_IRELAND              0x043c
-#define TT_MS_LANGID_SCOTTISH_GAELIC_UNITED_KINGDOM    0x083c
+#define TT_MS_LANGID_IRISH_GAELIC_IRELAND              0x043C
+#define TT_MS_LANGID_SCOTTISH_GAELIC_UNITED_KINGDOM    0x083C
 #else
-#define TT_MS_LANGID_SCOTTISH_GAELIC_UNITED_KINGDOM    0x083c
-#define TT_MS_LANGID_IRISH_GAELIC_IRELAND              0x043c
+#define TT_MS_LANGID_SCOTTISH_GAELIC_UNITED_KINGDOM    0x083C
+#define TT_MS_LANGID_IRISH_GAELIC_IRELAND              0x043C
 #endif
 
-#define TT_MS_LANGID_YIDDISH_GERMANY                   0x043d
-#define TT_MS_LANGID_MALAY_MALAYSIA                    0x043e
-#define TT_MS_LANGID_MALAY_BRUNEI_DARUSSALAM           0x083e
-#define TT_MS_LANGID_KAZAK_KAZAKSTAN                   0x043f
+#define TT_MS_LANGID_YIDDISH_GERMANY                   0x043D
+#define TT_MS_LANGID_MALAY_MALAYSIA                    0x043E
+#define TT_MS_LANGID_MALAY_BRUNEI_DARUSSALAM           0x083E
+#define TT_MS_LANGID_KAZAK_KAZAKSTAN                   0x043F
 #define TT_MS_LANGID_KIRGHIZ_KIRGHIZSTAN /* Cyrillic*/ 0x0440
   /* alias declared in Windows 2000 */
 #define TT_MS_LANGID_KIRGHIZ_KIRGHIZ_REPUBLIC \
@@ -693,12 +693,12 @@ FT_BEGIN_HEADER
 #define TT_MS_LANGID_GUJARATI_INDIA                    0x0447
 #define TT_MS_LANGID_ORIYA_INDIA                       0x0448
 #define TT_MS_LANGID_TAMIL_INDIA                       0x0449
-#define TT_MS_LANGID_TELUGU_INDIA                      0x044a
-#define TT_MS_LANGID_KANNADA_INDIA                     0x044b
-#define TT_MS_LANGID_MALAYALAM_INDIA                   0x044c
-#define TT_MS_LANGID_ASSAMESE_INDIA                    0x044d
-#define TT_MS_LANGID_MARATHI_INDIA                     0x044e
-#define TT_MS_LANGID_SANSKRIT_INDIA                    0x044f
+#define TT_MS_LANGID_TELUGU_INDIA                      0x044A
+#define TT_MS_LANGID_KANNADA_INDIA                     0x044B
+#define TT_MS_LANGID_MALAYALAM_INDIA                   0x044C
+#define TT_MS_LANGID_ASSAMESE_INDIA                    0x044D
+#define TT_MS_LANGID_MARATHI_INDIA                     0x044E
+#define TT_MS_LANGID_SANSKRIT_INDIA                    0x044F
 #define TT_MS_LANGID_MONGOLIAN_MONGOLIA /* Cyrillic */ 0x0450
 #define TT_MS_LANGID_MONGOLIAN_MONGOLIA_MONGOLIAN      0x0850
 #define TT_MS_LANGID_TIBETAN_CHINA                     0x0451
@@ -732,13 +732,13 @@ FT_BEGIN_HEADER
 #define TT_MS_LANGID_SINDHI_INDIA /* Arabic */         0x0459
 #define TT_MS_LANGID_SINDHI_PAKISTAN                   0x0859
   /* Missing a LCID for Sindhi in Devanagari script */
-#define TT_MS_LANGID_SYRIAC_SYRIA                      0x045a
-#define TT_MS_LANGID_SINHALESE_SRI_LANKA               0x045b
-#define TT_MS_LANGID_CHEROKEE_UNITED_STATES            0x045c
-#define TT_MS_LANGID_INUKTITUT_CANADA                  0x045d
-#define TT_MS_LANGID_AMHARIC_ETHIOPIA                  0x045e
-#define TT_MS_LANGID_TAMAZIGHT_MOROCCO /* Arabic */    0x045f
-#define TT_MS_LANGID_TAMAZIGHT_MOROCCO_LATIN           0x085f
+#define TT_MS_LANGID_SYRIAC_SYRIA                      0x045A
+#define TT_MS_LANGID_SINHALESE_SRI_LANKA               0x045B
+#define TT_MS_LANGID_CHEROKEE_UNITED_STATES            0x045C
+#define TT_MS_LANGID_INUKTITUT_CANADA                  0x045D
+#define TT_MS_LANGID_AMHARIC_ETHIOPIA                  0x045E
+#define TT_MS_LANGID_TAMAZIGHT_MOROCCO /* Arabic */    0x045F
+#define TT_MS_LANGID_TAMAZIGHT_MOROCCO_LATIN           0x085F
   /* Missing a LCID for Tifinagh script */
 #define TT_MS_LANGID_KASHMIRI_PAKISTAN /* Arabic */    0x0460
   /* Spelled this way by XPsp2 Platform SDK (2004-07-26) */
@@ -758,15 +758,15 @@ FT_BEGIN_HEADER
 #define TT_MS_LANGID_FULFULDE_NIGERIA                  0x0467
 #define TT_MS_LANGID_HAUSA_NIGERIA                     0x0468
 #define TT_MS_LANGID_IBIBIO_NIGERIA                    0x0469
-#define TT_MS_LANGID_YORUBA_NIGERIA                    0x046a
-#define TT_MS_LANGID_QUECHUA_BOLIVIA                   0x046b
-#define TT_MS_LANGID_QUECHUA_ECUADOR                   0x086b
-#define TT_MS_LANGID_QUECHUA_PERU                      0x0c6b
-#define TT_MS_LANGID_SEPEDI_SOUTH_AFRICA               0x046c
+#define TT_MS_LANGID_YORUBA_NIGERIA                    0x046A
+#define TT_MS_LANGID_QUECHUA_BOLIVIA                   0x046B
+#define TT_MS_LANGID_QUECHUA_ECUADOR                   0x086B
+#define TT_MS_LANGID_QUECHUA_PERU                      0x0C6B
+#define TT_MS_LANGID_SEPEDI_SOUTH_AFRICA               0x046C
   /* Also spelled by XPsp2 Platform SDK (2004-07-26) */
 #define TT_MS_LANGID_SOTHO_SOUTHERN_SOUTH_AFRICA \
           TT_MS_LANGID_SEPEDI_SOUTH_AFRICA
-  /* language codes 0x046d, 0x046e and 0x046f are (still) unknown. */
+  /* language codes 0x046D, 0x046E and 0x046F are (still) unknown. */
 #define TT_MS_LANGID_IGBO_NIGERIA                      0x0470
 #define TT_MS_LANGID_KANURI_NIGERIA                    0x0471
 #define TT_MS_LANGID_OROMO_ETHIOPIA                    0x0472
@@ -783,12 +783,12 @@ FT_BEGIN_HEADER
   /*       studying).                                                     */
 #define TT_MS_LANGID_YI_CHINA                          0x0478
 #define TT_MS_LANGID_PAPIAMENTU_NETHERLANDS_ANTILLES   0x0479
-  /* language codes from 0x047a to 0x047f are (still) unknown. */
+  /* language codes from 0x047A to 0x047F are (still) unknown. */
 #define TT_MS_LANGID_UIGHUR_CHINA                      0x0480
 #define TT_MS_LANGID_MAORI_NEW_ZEALAND                 0x0481
 
 #if 0  /* not deemed useful for fonts */
-#define TT_MS_LANGID_HUMAN_INTERFACE_DEVICE            0x04ff
+#define TT_MS_LANGID_HUMAN_INTERFACE_DEVICE            0x04FF
 #endif
 
 
diff --git a/src/autofit/afmodule.c b/src/autofit/afmodule.c
index 81ece38..641e03e 100644
--- a/src/autofit/afmodule.c
+++ b/src/autofit/afmodule.c
@@ -226,7 +226,7 @@
   af_get_interface( FT_Module    module,
                     const char*  module_interface )
   {
-    /* AF_SERVICES_GET derefers `library' in PIC mode */
+    /* AF_SERVICES_GET dereferences `library' in PIC mode */
 #ifdef FT_CONFIG_OPTION_PIC
     FT_Library  library;
 
diff --git a/src/base/ftbbox.c b/src/base/ftbbox.c
index 14f4785..f9a1751 100644
--- a/src/base/ftbbox.c
+++ b/src/base/ftbbox.c
@@ -435,8 +435,10 @@
   FT_Outline_Get_BBox( FT_Outline*  outline,
                        FT_BBox     *abbox )
   {
-    FT_BBox     cbox = { 0x7FFFFFFF, 0x7FFFFFFF, -0x7FFFFFFF, -0x7FFFFFFF };
-    FT_BBox     bbox = { 0x7FFFFFFF, 0x7FFFFFFF, -0x7FFFFFFF, -0x7FFFFFFF };
+    FT_BBox     cbox = {  0x7FFFFFFFL,  0x7FFFFFFFL,
+                         -0x7FFFFFFFL, -0x7FFFFFFFL };
+    FT_BBox     bbox = {  0x7FFFFFFFL,  0x7FFFFFFFL,
+                         -0x7FFFFFFFL, -0x7FFFFFFFL };
     FT_Vector*  vec;
     FT_UShort   n;
 
diff --git a/src/base/ftbitmap.c b/src/base/ftbitmap.c
index 5dd33a2..19a1a80 100644
--- a/src/base/ftbitmap.c
+++ b/src/base/ftbitmap.c
@@ -363,7 +363,7 @@
               p[x] |= p[x - 1] << ( 8 - i );
 
 #if 0
-            if ( p[x] == 0xff )
+            if ( p[x] == 0xFF )
               break;
 #endif
           }
diff --git a/src/base/ftcalc.c b/src/base/ftcalc.c
index f3ef8c5..02d256d 100644
--- a/src/base/ftcalc.c
+++ b/src/base/ftcalc.c
@@ -115,30 +115,31 @@
   FT_BASE_DEF ( FT_Int )
   FT_MSB( FT_UInt32 z )
   {
-    FT_Int shift = 0;
+    FT_Int  shift = 0;
+
 
     /* determine msb bit index in `shift' */
-    if ( z & 0xFFFF0000U )
+    if ( z & 0xFFFF0000UL )
     {
       z     >>= 16;
       shift  += 16;
     }
-    if ( z & 0x0000FF00U )
+    if ( z & 0x0000FF00UL )
     {
       z     >>= 8;
       shift  += 8;
     }
-    if ( z & 0x000000F0U )
+    if ( z & 0x000000F0UL )
     {
       z     >>= 4;
       shift  += 4;
     }
-    if ( z & 0x0000000CU )
+    if ( z & 0x0000000CUL )
     {
       z     >>= 2;
       shift  += 2;
     }
-    if ( z & 0x00000002U )
+    if ( z & 0x00000002UL )
     {
    /* z     >>= 1; */
       shift  += 1;
diff --git a/src/base/ftobjs.c b/src/base/ftobjs.c
index 32a372b..ee15a01 100644
--- a/src/base/ftobjs.c
+++ b/src/base/ftobjs.c
@@ -1910,7 +1910,7 @@
     rlen = ( header[0x57] << 24 ) |
            ( header[0x58] << 16 ) |
            ( header[0x59] <<  8 ) |
-             header[0x5a];
+             header[0x5A];
 #endif /* 0 */
     offset = 128 + ( ( dlen + 127 ) & ~127 );
 
@@ -3648,8 +3648,10 @@
     /* clean up buffer */
     ((FT_Byte*)buffer)[0] = '\0';
 
-    if ( (FT_Long)glyph_index > face->num_glyphs ||
-         !FT_HAS_GLYPH_NAMES( face )             )
+    if ( (FT_Long)glyph_index >= face->num_glyphs )
+      return FT_THROW( Invalid_Glyph_Index );
+
+    if ( !FT_HAS_GLYPH_NAMES( face ) )
       return FT_THROW( Invalid_Argument );
 
     FT_FACE_LOOKUP_SERVICE( face, service, GLYPH_DICT );
diff --git a/src/base/ftrfork.c b/src/base/ftrfork.c
index 5352970..efe24d6 100644
--- a/src/base/ftrfork.c
+++ b/src/base/ftrfork.c
@@ -182,10 +182,10 @@
         return error;
 
       FT_TRACE2(( "Resource tags: %c%c%c%c\n",
-                  (char)( 0xff & ( tag_internal >> 24 ) ),
-                  (char)( 0xff & ( tag_internal >> 16 ) ),
-                  (char)( 0xff & ( tag_internal >>  8 ) ),
-                  (char)( 0xff & ( tag_internal >>  0 ) ) ));
+                  (char)( 0xFF & ( tag_internal >> 24 ) ),
+                  (char)( 0xFF & ( tag_internal >> 16 ) ),
+                  (char)( 0xFF & ( tag_internal >>  8 ) ),
+                  (char)( 0xFF & ( tag_internal >>  0 ) ) ));
       FT_TRACE3(( "             : subcount=%d, suboffset=0x%04x\n",
                   subcnt, rpos ));
 
diff --git a/src/base/ftstroke.c b/src/base/ftstroke.c
index d123e02..5fc41fc 100644
--- a/src/base/ftstroke.c
+++ b/src/base/ftstroke.c
@@ -834,8 +834,8 @@
     stroker->miter_limit = miter_limit;
 
     /* ensure miter limit has sensible value */
-    if ( stroker->miter_limit < 0x10000 )
-      stroker->miter_limit = 0x10000;
+    if ( stroker->miter_limit < 0x10000L )
+      stroker->miter_limit = 0x10000L;
 
     /* save line join style:                                           */
     /* line join style can be temporarily changed when stroking curves */
diff --git a/src/base/fttrigon.c b/src/base/fttrigon.c
index 9b2ccd5..35685a4 100644
--- a/src/base/fttrigon.c
+++ b/src/base/fttrigon.c
@@ -117,8 +117,8 @@
     /* and CORDIC hypotenuse, so it minimizes the error       */
 
     /* Check carry overflow of lo + 0x40000000 */
-    lo += 0x40000000U;
-    hi += ( lo < 0x40000000U );
+    lo += 0x40000000UL;
+    hi += ( lo < 0x40000000UL );
 
     val  = (FT_Fixed)hi;
 
diff --git a/src/bdf/bdflib.c b/src/bdf/bdflib.c
index 369c111..abcfdee 100644
--- a/src/bdf/bdflib.c
+++ b/src/bdf/bdflib.c
@@ -781,8 +781,8 @@
       hold     = buf[end];
       buf[end] = 0;
 
-      /* XXX: Use encoding independent value for 0x1a */
-      if ( buf[start] != '#' && buf[start] != 0x1a && end > start )
+      /* XXX: Use encoding independent value for 0x1A */
+      if ( buf[start] != '#' && buf[start] != 0x1A && end > start )
       {
         error = (*cb)( buf + start, (unsigned long)( end - start ), lineno,
                        (void*)&cb, client_data );
@@ -823,17 +823,17 @@
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
   };
 
   static const unsigned char  odigits[32] =
   {
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
@@ -841,7 +841,7 @@
 
   static const unsigned char  ddigits[32] =
   {
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x03,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
@@ -849,8 +849,8 @@
 
   static const unsigned char  hdigits[32] =
   {
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x03,
-    0x7e, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
+    0x7E, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   };
diff --git a/src/bzip2/ftbzip2.c b/src/bzip2/ftbzip2.c
index 5965136..7e406b1 100644
--- a/src/bzip2/ftbzip2.c
+++ b/src/bzip2/ftbzip2.c
@@ -131,7 +131,7 @@
     /* head[0] && head[1] are the magic numbers;    */
     /* head[2] is the version, and head[3] the blocksize */
     if ( head[0] != 0x42  ||
-         head[1] != 0x5a  ||
+         head[1] != 0x5A  ||
          head[2] != 0x68  )  /* only support bzip2 (huffman) */
     {
       error = FT_THROW( Invalid_File_Format );
diff --git a/src/cff/cf2font.c b/src/cff/cf2font.c
index a46b748..83fd348 100644
--- a/src/cff/cf2font.c
+++ b/src/cff/cf2font.c
@@ -150,8 +150,8 @@
       /* logarithms; remembering that the 16 lowest bits of the fraction */
       /* are dropped this is correct to within a factor of almost 4.     */
       /* For example, 0x80.0000 * 0x80.0000 = 0x4000.0000 is 23+23 and   */
-      /* is flagged as possible overflow because 0xff.ffff * 0xff.ffff = */
-      /* 0xffff.fe00 is also 23+23.                                      */
+      /* is flagged as possible overflow because 0xFF.FFFF * 0xFF.FFFF = */
+      /* 0xFFFF.FE00 is also 23+23.                                      */
 
       logBase2 = FT_MSB( (FT_UInt32)stemWidthPer1000 ) +
                    FT_MSB( (FT_UInt32)ppem );
diff --git a/src/cff/cffdrivr.c b/src/cff/cffdrivr.c
index dde7d44..3e8898e 100644
--- a/src/cff/cffdrivr.c
+++ b/src/cff/cffdrivr.c
@@ -4,7 +4,7 @@
 /*                                                                         */
 /*    OpenType font driver implementation (body).                          */
 /*                                                                         */
-/*  Copyright 1996-2013 by                                                 */
+/*  Copyright 1996-2014 by                                                 */
 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
 /*                                                                         */
 /*  This file is part of the FreeType project, and may only be used,       */
@@ -753,7 +753,7 @@
     FT_Module_Interface  result;
 
 
-    /* CFF_SERVICES_GET derefers `library' in PIC mode */
+    /* CFF_SERVICES_GET dereferences `library' in PIC mode */
 #ifdef FT_CONFIG_OPTION_PIC
     if ( !driver )
       return NULL;
diff --git a/src/cff/cffparse.c b/src/cff/cffparse.c
index 91bd532..c79ab62 100644
--- a/src/cff/cffparse.c
+++ b/src/cff/cffparse.c
@@ -188,7 +188,7 @@
     }
 
     /* Read fraction part, if any. */
-    if ( nib == 0xa )
+    if ( nib == 0xA )
       for (;;)
       {
         /* If we entered this iteration with phase == 4, we need */
diff --git a/src/gxvalid/gxvbsln.c b/src/gxvalid/gxvbsln.c
index 3d10031..d165118 100644
--- a/src/gxvalid/gxvbsln.c
+++ b/src/gxvalid/gxvbsln.c
@@ -72,10 +72,10 @@
   static void
   gxv_bsln_LookupValue_validate( FT_UShort            glyph,
                                  GXV_LookupValueCPtr  value_p,
-                                 GXV_Validator        valid )
+                                 GXV_Validator        gxvalid )
   {
-    FT_UShort   v = value_p->u;
-    FT_UShort*  ctlPoints;
+    FT_UShort     v = value_p->u;
+    FT_UShort*    ctlPoints;
 
     FT_UNUSED( glyph );
 
@@ -124,7 +124,7 @@
   gxv_bsln_LookupFmt4_transit( FT_UShort            relative_gindex,
                                GXV_LookupValueCPtr  base_value_p,
                                FT_Bytes             lookuptbl_limit,
-                               GXV_Validator        valid )
+                               GXV_Validator        gxvalid )
   {
     FT_Bytes             p;
     FT_Bytes             limit;
@@ -135,7 +135,7 @@
     offset = (FT_UShort)( base_value_p->u +
                           ( relative_gindex * sizeof ( FT_UShort ) ) );
 
-    p     = valid->lookuptbl_head + offset;
+    p     = gxvalid->lookuptbl_head + offset;
     limit = lookuptbl_limit;
     GXV_LIMIT_CHECK( 2 );
 
@@ -148,7 +148,7 @@
   static void
   gxv_bsln_parts_fmt0_validate( FT_Bytes       tables,
                                 FT_Bytes       limit,
-                                GXV_Validator  valid )
+                                GXV_Validator  gxvalid )
   {
     FT_Bytes  p = tables;
 
@@ -158,7 +158,7 @@
     /* deltas */
     GXV_LIMIT_CHECK( 2 * GXV_BSLN_VALUE_COUNT );
 
-    valid->table_data = NULL;      /* No ctlPoints here. */
+    gxvalid->table_data = NULL;      /* No ctlPoints here. */
 
     GXV_EXIT;
   }
@@ -167,7 +167,7 @@
   static void
   gxv_bsln_parts_fmt1_validate( FT_Bytes       tables,
                                 FT_Bytes       limit,
-                                GXV_Validator  valid )
+                                GXV_Validator  gxvalid )
   {
     FT_Bytes  p = tables;
 
@@ -175,15 +175,15 @@
     GXV_NAME_ENTER( "parts format 1" );
 
     /* deltas */
-    gxv_bsln_parts_fmt0_validate( p, limit, valid );
+    gxv_bsln_parts_fmt0_validate( p, limit, gxvalid );
 
     /* mappingData */
-    valid->lookupval_sign   = GXV_LOOKUPVALUE_UNSIGNED;
-    valid->lookupval_func   = gxv_bsln_LookupValue_validate;
-    valid->lookupfmt4_trans = gxv_bsln_LookupFmt4_transit;
+    gxvalid->lookupval_sign   = GXV_LOOKUPVALUE_UNSIGNED;
+    gxvalid->lookupval_func   = gxv_bsln_LookupValue_validate;
+    gxvalid->lookupfmt4_trans = gxv_bsln_LookupFmt4_transit;
     gxv_LookupTable_validate( p + 2 * GXV_BSLN_VALUE_COUNT,
                               limit,
-                              valid );
+                              gxvalid );
 
     GXV_EXIT;
   }
@@ -192,7 +192,7 @@
   static void
   gxv_bsln_parts_fmt2_validate( FT_Bytes       tables,
                                 FT_Bytes       limit,
-                                GXV_Validator  valid )
+                                GXV_Validator  gxvalid )
   {
     FT_Bytes   p = tables;
 
@@ -211,7 +211,7 @@
     stdGlyph = FT_NEXT_USHORT( p );
     GXV_TRACE(( " (stdGlyph = %u)\n", stdGlyph ));
 
-    gxv_glyphid_validate( stdGlyph, valid );
+    gxv_glyphid_validate( stdGlyph, gxvalid );
 
     /* Record the position of ctlPoints */
     GXV_BSLN_DATA( ctlPoints_p ) = p;
@@ -226,7 +226,7 @@
           FT_INVALID_DATA;
       }
       else
-        gxv_ctlPoint_validate( stdGlyph, (FT_Short)ctlPoint, valid );
+        gxv_ctlPoint_validate( stdGlyph, (FT_Short)ctlPoint, gxvalid );
     }
 
     GXV_EXIT;
@@ -236,7 +236,7 @@
   static void
   gxv_bsln_parts_fmt3_validate( FT_Bytes       tables,
                                 FT_Bytes       limit,
-                                GXV_Validator  valid)
+                                GXV_Validator  gxvalid)
   {
     FT_Bytes  p = tables;
 
@@ -244,15 +244,15 @@
     GXV_NAME_ENTER( "parts format 3" );
 
     /* stdGlyph + ctlPoints */
-    gxv_bsln_parts_fmt2_validate( p, limit, valid );
+    gxv_bsln_parts_fmt2_validate( p, limit, gxvalid );
 
     /* mappingData */
-    valid->lookupval_sign   = GXV_LOOKUPVALUE_UNSIGNED;
-    valid->lookupval_func   = gxv_bsln_LookupValue_validate;
-    valid->lookupfmt4_trans = gxv_bsln_LookupFmt4_transit;
+    gxvalid->lookupval_sign   = GXV_LOOKUPVALUE_UNSIGNED;
+    gxvalid->lookupval_func   = gxv_bsln_LookupValue_validate;
+    gxvalid->lookupfmt4_trans = gxv_bsln_LookupFmt4_transit;
     gxv_LookupTable_validate( p + ( 2 + 2 * GXV_BSLN_VALUE_COUNT ),
                               limit,
-                              valid );
+                              gxvalid );
 
     GXV_EXIT;
   }
@@ -271,8 +271,8 @@
                      FT_Face       face,
                      FT_Validator  ftvalid )
   {
-    GXV_ValidatorRec  validrec;
-    GXV_Validator     valid = &validrec;
+    GXV_ValidatorRec  gxvalidrec;
+    GXV_Validator     gxvalid = &gxvalidrec;
 
     GXV_bsln_DataRec  bslnrec;
     GXV_bsln_Data     bsln = &bslnrec;
@@ -293,9 +293,9 @@
     };
 
 
-    valid->root       = ftvalid;
-    valid->table_data = bsln;
-    valid->face       = face;
+    gxvalid->root       = ftvalid;
+    gxvalid->table_data = bsln;
+    gxvalid->face       = face;
 
     FT_TRACE3(( "validating `bsln' table\n" ));
     GXV_INIT;
@@ -320,7 +320,7 @@
 
     bsln->defaultBaseline = defaultBaseline;
 
-    fmt_funcs_table[format]( p, limit, valid );
+    fmt_funcs_table[format]( p, limit, gxvalid );
 
     FT_TRACE4(( "\n" ));
   }
diff --git a/src/gxvalid/gxvcommn.c b/src/gxvalid/gxvcommn.c
index 7af5234..8e72a72 100644
--- a/src/gxvalid/gxvcommn.c
+++ b/src/gxvalid/gxvcommn.c
@@ -65,7 +65,7 @@
                                    FT_UShort*     buff,
                                    FT_UInt        nmemb,
                                    FT_UShort      limit,
-                                   GXV_Validator  valid )
+                                   GXV_Validator  gxvalid )
   {
     FT_UInt  i;
 
@@ -130,7 +130,7 @@
                                   FT_ULong*      buff,
                                   FT_UInt        nmemb,
                                   FT_ULong       limit,
-                                  GXV_Validator  valid)
+                                  GXV_Validator  gxvalid)
   {
     FT_UInt  i;
 
@@ -182,7 +182,7 @@
                             FT_Bytes       limit,
                             FT_Byte*       min,
                             FT_Byte*       max,
-                            GXV_Validator  valid )
+                            GXV_Validator  gxvalid )
   {
     FT_Bytes  p = table;
 
@@ -202,7 +202,7 @@
       *max = (FT_Byte)FT_MAX( *max, val );
     }
 
-    valid->subtable_length = p - table;
+    gxvalid->subtable_length = p - table;
   }
 
 
@@ -211,7 +211,7 @@
                               FT_Bytes       limit,
                               FT_UShort*     min,
                               FT_UShort*     max,
-                              GXV_Validator  valid )
+                              GXV_Validator  gxvalid )
   {
     FT_Bytes  p = table;
 
@@ -231,7 +231,7 @@
       *max = (FT_Byte)FT_MAX( *max, val );
     }
 
-    valid->subtable_length = p - table;
+    gxvalid->subtable_length = p - table;
   }
 
 
@@ -256,7 +256,7 @@
 
   static void
   gxv_BinSrchHeader_check_consistency( GXV_BinSrchHeader*  binSrchHeader,
-                                       GXV_Validator       valid )
+                                       GXV_Validator       gxvalid )
   {
     FT_UShort  searchRange;
     FT_UShort  entrySelector;
@@ -329,7 +329,7 @@
                               FT_Bytes       limit,
                               FT_UShort*     unitSize_p,
                               FT_UShort*     nUnits_p,
-                              GXV_Validator  valid )
+                              GXV_Validator  gxvalid )
   {
     FT_Bytes           p = table;
     GXV_BinSrchHeader  binSrchHeader;
@@ -359,7 +359,7 @@
     binSrchHeader.rangeShift    = FT_NEXT_USHORT( p );
     GXV_TRACE(( "nUnits %d\n", binSrchHeader.nUnits ));
 
-    gxv_BinSrchHeader_check_consistency( &binSrchHeader, valid );
+    gxv_BinSrchHeader_check_consistency( &binSrchHeader, gxvalid );
 
     if ( *unitSize_p == 0 )
       *unitSize_p = binSrchHeader.unitSize;
@@ -367,7 +367,7 @@
     if ( *nUnits_p == 0 )
       *nUnits_p = binSrchHeader.nUnits;
 
-    valid->subtable_length = p - table;
+    gxvalid->subtable_length = p - table;
     GXV_EXIT;
   }
 
@@ -422,7 +422,7 @@
   static void
   gxv_LookupTable_fmt0_validate( FT_Bytes       table,
                                  FT_Bytes       limit,
-                                 GXV_Validator  valid )
+                                 GXV_Validator  gxvalid )
   {
     FT_Bytes   p = table;
     FT_UShort  i;
@@ -432,24 +432,24 @@
 
     GXV_NAME_ENTER( "LookupTable format 0" );
 
-    GXV_LIMIT_CHECK( 2 * valid->face->num_glyphs );
+    GXV_LIMIT_CHECK( 2 * gxvalid->face->num_glyphs );
 
-    for ( i = 0; i < valid->face->num_glyphs; i++ )
+    for ( i = 0; i < gxvalid->face->num_glyphs; i++ )
     {
       GXV_LIMIT_CHECK( 2 );
       if ( p + 2 >= limit )     /* some fonts have too-short fmt0 array */
       {
         GXV_TRACE(( "too short, glyphs %d - %d are missing\n",
-                    i, valid->face->num_glyphs ));
+                    i, gxvalid->face->num_glyphs ));
         GXV_SET_ERR_IF_PARANOID( FT_INVALID_GLYPH_ID );
         break;
       }
 
-      value = GXV_LOOKUP_VALUE_LOAD( p, valid->lookupval_sign );
-      valid->lookupval_func( i, &value, valid );
+      value = GXV_LOOKUP_VALUE_LOAD( p, gxvalid->lookupval_sign );
+      gxvalid->lookupval_func( i, &value, gxvalid );
     }
 
-    valid->subtable_length = p - table;
+    gxvalid->subtable_length = p - table;
     GXV_EXIT;
   }
 
@@ -473,12 +473,12 @@
   static void
   gxv_LookupTable_fmt2_skip_endmarkers( FT_Bytes       table,
                                         FT_UShort      unitSize,
-                                        GXV_Validator  valid )
+                                        GXV_Validator  gxvalid )
   {
     FT_Bytes  p = table;
 
 
-    while ( ( p + 4 ) < valid->root->limit )
+    while ( ( p + 4 ) < gxvalid->root->limit )
     {
       if ( p[0] != 0xFF || p[1] != 0xFF || /* lastGlyph */
            p[2] != 0xFF || p[3] != 0xFF )  /* firstGlyph */
@@ -486,14 +486,14 @@
       p += unitSize;
     }
 
-    valid->subtable_length = p - table;
+    gxvalid->subtable_length = p - table;
   }
 
 
   static void
   gxv_LookupTable_fmt2_validate( FT_Bytes       table,
                                  FT_Bytes       limit,
-                                 GXV_Validator  valid )
+                                 GXV_Validator  gxvalid )
   {
     FT_Bytes             p = table;
     FT_UShort            gid;
@@ -509,8 +509,8 @@
     GXV_NAME_ENTER( "LookupTable format 2" );
 
     unitSize = nUnits = 0;
-    gxv_BinSrchHeader_validate( p, limit, &unitSize, &nUnits, valid );
-    p += valid->subtable_length;
+    gxv_BinSrchHeader_validate( p, limit, &unitSize, &nUnits, gxvalid );
+    p += gxvalid->subtable_length;
 
     GXV_UNITSIZE_VALIDATE( "format2", unitSize, nUnits, 6 );
 
@@ -519,10 +519,10 @@
       GXV_LIMIT_CHECK( 2 + 2 + 2 );
       lastGlyph  = FT_NEXT_USHORT( p );
       firstGlyph = FT_NEXT_USHORT( p );
-      value      = GXV_LOOKUP_VALUE_LOAD( p, valid->lookupval_sign );
+      value      = GXV_LOOKUP_VALUE_LOAD( p, gxvalid->lookupval_sign );
 
-      gxv_glyphid_validate( firstGlyph, valid );
-      gxv_glyphid_validate( lastGlyph, valid );
+      gxv_glyphid_validate( firstGlyph, gxvalid );
+      gxv_glyphid_validate( lastGlyph, gxvalid );
 
       if ( lastGlyph < gid )
       {
@@ -539,7 +539,7 @@
                     unit, lastGlyph, firstGlyph ));
         GXV_SET_ERR_IF_PARANOID( FT_INVALID_GLYPH_ID );
 
-        if ( valid->root->level == FT_VALIDATE_TIGHT )
+        if ( gxvalid->root->level == FT_VALIDATE_TIGHT )
           continue;     /* ftxvalidator silently skips such an entry */
 
         FT_TRACE4(( "continuing with exchanged values\n" ));
@@ -549,13 +549,13 @@
       }
 
       for ( gid = firstGlyph; gid <= lastGlyph; gid++ )
-        valid->lookupval_func( gid, &value, valid );
+        gxvalid->lookupval_func( gid, &value, gxvalid );
     }
 
-    gxv_LookupTable_fmt2_skip_endmarkers( p, unitSize, valid );
-    p += valid->subtable_length;
+    gxv_LookupTable_fmt2_skip_endmarkers( p, unitSize, gxvalid );
+    p += gxvalid->subtable_length;
 
-    valid->subtable_length = p - table;
+    gxvalid->subtable_length = p - table;
     GXV_EXIT;
   }
 
@@ -564,7 +564,7 @@
   static void
   gxv_LookupTable_fmt4_validate( FT_Bytes       table,
                                  FT_Bytes       limit,
-                                 GXV_Validator  valid )
+                                 GXV_Validator  gxvalid )
   {
     FT_Bytes             p = table;
     FT_UShort            unit;
@@ -581,8 +581,8 @@
     GXV_NAME_ENTER( "LookupTable format 4" );
 
     unitSize = nUnits = 0;
-    gxv_BinSrchHeader_validate( p, limit, &unitSize, &nUnits, valid );
-    p += valid->subtable_length;
+    gxv_BinSrchHeader_validate( p, limit, &unitSize, &nUnits, gxvalid );
+    p += gxvalid->subtable_length;
 
     GXV_UNITSIZE_VALIDATE( "format4", unitSize, nUnits, 6 );
 
@@ -592,8 +592,8 @@
       lastGlyph  = FT_NEXT_USHORT( p );
       firstGlyph = FT_NEXT_USHORT( p );
 
-      gxv_glyphid_validate( firstGlyph, valid );
-      gxv_glyphid_validate( lastGlyph, valid );
+      gxv_glyphid_validate( firstGlyph, gxvalid );
+      gxv_glyphid_validate( lastGlyph, gxvalid );
 
       if ( lastGlyph < gid )
       {
@@ -610,7 +610,7 @@
                     unit, lastGlyph, firstGlyph ));
         GXV_SET_ERR_IF_PARANOID( FT_INVALID_GLYPH_ID );
 
-        if ( valid->root->level == FT_VALIDATE_TIGHT )
+        if ( gxvalid->root->level == FT_VALIDATE_TIGHT )
           continue; /* ftxvalidator silently skips such an entry */
 
         FT_TRACE4(( "continuing with exchanged values\n" ));
@@ -624,19 +624,19 @@
 
       for ( gid = firstGlyph; gid <= lastGlyph; gid++ )
       {
-        value = valid->lookupfmt4_trans( (FT_UShort)( gid - firstGlyph ),
+        value = gxvalid->lookupfmt4_trans( (FT_UShort)( gid - firstGlyph ),
                                          &base_value,
                                          limit,
-                                         valid );
+                                         gxvalid );
 
-        valid->lookupval_func( gid, &value, valid );
+        gxvalid->lookupval_func( gid, &value, gxvalid );
       }
     }
 
-    gxv_LookupTable_fmt2_skip_endmarkers( p, unitSize, valid );
-    p += valid->subtable_length;
+    gxv_LookupTable_fmt2_skip_endmarkers( p, unitSize, gxvalid );
+    p += gxvalid->subtable_length;
 
-    valid->subtable_length = p - table;
+    gxvalid->subtable_length = p - table;
     GXV_EXIT;
   }
 
@@ -645,26 +645,26 @@
   static void
   gxv_LookupTable_fmt6_skip_endmarkers( FT_Bytes       table,
                                         FT_UShort      unitSize,
-                                        GXV_Validator  valid )
+                                        GXV_Validator  gxvalid )
   {
     FT_Bytes  p = table;
 
 
-    while ( p < valid->root->limit )
+    while ( p < gxvalid->root->limit )
     {
       if ( p[0] != 0xFF || p[1] != 0xFF )
         break;
       p += unitSize;
     }
 
-    valid->subtable_length = p - table;
+    gxvalid->subtable_length = p - table;
   }
 
 
   static void
   gxv_LookupTable_fmt6_validate( FT_Bytes       table,
                                  FT_Bytes       limit,
-                                 GXV_Validator  valid )
+                                 GXV_Validator  gxvalid )
   {
     FT_Bytes             p = table;
     FT_UShort            unit;
@@ -679,8 +679,8 @@
     GXV_NAME_ENTER( "LookupTable format 6" );
 
     unitSize = nUnits = 0;
-    gxv_BinSrchHeader_validate( p, limit, &unitSize, &nUnits, valid );
-    p += valid->subtable_length;
+    gxv_BinSrchHeader_validate( p, limit, &unitSize, &nUnits, gxvalid );
+    p += gxvalid->subtable_length;
 
     GXV_UNITSIZE_VALIDATE( "format6", unitSize, nUnits, 4 );
 
@@ -688,9 +688,9 @@
     {
       GXV_LIMIT_CHECK( 2 + 2 );
       glyph = FT_NEXT_USHORT( p );
-      value = GXV_LOOKUP_VALUE_LOAD( p, valid->lookupval_sign );
+      value = GXV_LOOKUP_VALUE_LOAD( p, gxvalid->lookupval_sign );
 
-      if ( gxv_glyphid_validate( glyph, valid ) )
+      if ( gxv_glyphid_validate( glyph, gxvalid ) )
         GXV_TRACE(( " endmarker found within defined range"
                     " (entry %d < nUnits=%d)\n",
                     unit, nUnits ));
@@ -703,13 +703,13 @@
       }
       prev_glyph = glyph;
 
-      valid->lookupval_func( glyph, &value, valid );
+      gxvalid->lookupval_func( glyph, &value, gxvalid );
     }
 
-    gxv_LookupTable_fmt6_skip_endmarkers( p, unitSize, valid );
-    p += valid->subtable_length;
+    gxv_LookupTable_fmt6_skip_endmarkers( p, unitSize, gxvalid );
+    p += gxvalid->subtable_length;
 
-    valid->subtable_length = p - table;
+    gxvalid->subtable_length = p - table;
     GXV_EXIT;
   }
 
@@ -718,7 +718,7 @@
   static void
   gxv_LookupTable_fmt8_validate( FT_Bytes       table,
                                  FT_Bytes       limit,
-                                 GXV_Validator  valid )
+                                 GXV_Validator  gxvalid )
   {
     FT_Bytes              p = table;
     FT_UShort             i;
@@ -735,18 +735,18 @@
     firstGlyph = FT_NEXT_USHORT( p );
     glyphCount = FT_NEXT_USHORT( p );
 
-    gxv_glyphid_validate( firstGlyph, valid );
-    gxv_glyphid_validate( (FT_UShort)( firstGlyph + glyphCount ), valid );
+    gxv_glyphid_validate( firstGlyph, gxvalid );
+    gxv_glyphid_validate( (FT_UShort)( firstGlyph + glyphCount ), gxvalid );
 
     /* valueArray */
     for ( i = 0; i < glyphCount; i++ )
     {
       GXV_LIMIT_CHECK( 2 );
-      value = GXV_LOOKUP_VALUE_LOAD( p, valid->lookupval_sign );
-      valid->lookupval_func( (FT_UShort)( firstGlyph + i ), &value, valid );
+      value = GXV_LOOKUP_VALUE_LOAD( p, gxvalid->lookupval_sign );
+      gxvalid->lookupval_func( (FT_UShort)( firstGlyph + i ), &value, gxvalid );
     }
 
-    valid->subtable_length = p - table;
+    gxvalid->subtable_length = p - table;
     GXV_EXIT;
   }
 
@@ -754,7 +754,7 @@
   FT_LOCAL_DEF( void )
   gxv_LookupTable_validate( FT_Bytes       table,
                             FT_Bytes       limit,
-                            GXV_Validator  valid )
+                            GXV_Validator  gxvalid )
   {
     FT_Bytes   p = table;
     FT_UShort  format;
@@ -778,7 +778,7 @@
     GXV_NAME_ENTER( "LookupTable" );
 
     /* lookuptbl_head may be used in fmt4 transit function. */
-    valid->lookuptbl_head = table;
+    gxvalid->lookuptbl_head = table;
 
     /* format */
     GXV_LIMIT_CHECK( 2 );
@@ -792,10 +792,10 @@
     if ( func == NULL )
       FT_INVALID_FORMAT;
 
-    func( p, limit, valid );
-    p += valid->subtable_length;
+    func( p, limit, gxvalid );
+    p += gxvalid->subtable_length;
 
-    valid->subtable_length = p - table;
+    gxvalid->subtable_length = p - table;
 
     GXV_EXIT;
   }
@@ -811,7 +811,7 @@
 
   FT_LOCAL_DEF( FT_Int )
   gxv_glyphid_validate( FT_UShort      gid,
-                        GXV_Validator  valid )
+                        GXV_Validator  gxvalid )
   {
     FT_Face  face;
 
@@ -822,7 +822,7 @@
       return 1;
     }
 
-    face = valid->face;
+    face = gxvalid->face;
     if ( face->num_glyphs < gid )
     {
       GXV_TRACE(( " gxv_glyphid_check() gid overflow: num_glyphs %d < %d\n",
@@ -845,7 +845,7 @@
   FT_LOCAL_DEF( void )
   gxv_ctlPoint_validate( FT_UShort      gid,
                          FT_Short       ctl_point,
-                         GXV_Validator  valid )
+                         GXV_Validator  gxvalid )
   {
     FT_Face       face;
     FT_Error      error;
@@ -855,7 +855,7 @@
     short         n_points;
 
 
-    face = valid->face;
+    face = gxvalid->face;
 
     error = FT_Load_Glyph( face,
                            gid,
@@ -885,7 +885,7 @@
   gxv_sfntName_validate( FT_UShort      name_index,
                          FT_UShort      min_index,
                          FT_UShort      max_index,
-                         GXV_Validator  valid )
+                         GXV_Validator  gxvalid )
   {
     FT_SfntName  name;
     FT_UInt      i;
@@ -897,10 +897,10 @@
     if ( name_index < min_index || max_index < name_index )
       FT_INVALID_FORMAT;
 
-    nnames = FT_Get_Sfnt_Name_Count( valid->face );
+    nnames = FT_Get_Sfnt_Name_Count( gxvalid->face );
     for ( i = 0; i < nnames; i++ )
     {
-      if ( FT_Get_Sfnt_Name( valid->face, i, &name ) != FT_Err_Ok )
+      if ( FT_Get_Sfnt_Name( gxvalid->face, i, &name ) != FT_Err_Ok )
         continue ;
 
       if ( name.name_id == name_index )
@@ -944,7 +944,7 @@
                            FT_UShort*     length_p,
                            FT_UShort      stateSize,
                            FT_Byte*       maxClassID_p,
-                           GXV_Validator  valid )
+                           GXV_Validator  gxvalid )
   {
     FT_Bytes   p     = table;
     FT_Bytes   limit = table + *length_p;
@@ -965,7 +965,7 @@
     if ( !nGlyphs )
       goto Out;
 
-    gxv_glyphid_validate( (FT_UShort)( firstGlyph + nGlyphs ), valid );
+    gxv_glyphid_validate( (FT_UShort)( firstGlyph + nGlyphs ), gxvalid );
 
     {
       FT_Byte    nGlyphInClass[256];
@@ -1022,9 +1022,9 @@
                            FT_UShort      stateSize,
                            FT_Byte*       maxState_p,
                            FT_Byte*       maxEntry_p,
-                           GXV_Validator  valid )
+                           GXV_Validator  gxvalid )
   {
-    FT_Bytes  p = table;
+    FT_Bytes  p     = table;
     FT_Bytes  limit = table + *length_p;
     FT_Byte   clazz;
     FT_Byte   entry;
@@ -1076,7 +1076,7 @@
                            FT_Byte        maxClassID,
                            FT_Bytes       statetable_table,
                            FT_Bytes       statetable_limit,
-                           GXV_Validator  valid )
+                           GXV_Validator  gxvalid )
   {
     FT_Bytes  p     = table;
     FT_Bytes  limit = table + *length_p;
@@ -1166,13 +1166,13 @@
         goto Exit;
       }
 
-      if ( NULL != valid->statetable.entry_validate_func )
-        valid->statetable.entry_validate_func( state,
-                                               flags,
-                                               &glyphOffset,
-                                               statetable_table,
-                                               statetable_limit,
-                                               valid );
+      if ( NULL != gxvalid->statetable.entry_validate_func )
+        gxvalid->statetable.entry_validate_func( state,
+                                                 flags,
+                                                 &glyphOffset,
+                                                 statetable_table,
+                                                 statetable_limit,
+                                                 gxvalid );
     }
 
   Exit:
@@ -1192,7 +1192,7 @@
                                  FT_UShort*     classTable_length_p,
                                  FT_UShort*     stateArray_length_p,
                                  FT_UShort*     entryTable_length_p,
-                                 GXV_Validator  valid )
+                                 GXV_Validator  gxvalid )
   {
     FT_UShort   o[3];
     FT_UShort*  l[3];
@@ -1206,14 +1206,14 @@
     l[1] = stateArray_length_p;
     l[2] = entryTable_length_p;
 
-    gxv_set_length_by_ushort_offset( o, l, buff, 3, table_size, valid );
+    gxv_set_length_by_ushort_offset( o, l, buff, 3, table_size, gxvalid );
   }
 
 
   FT_LOCAL_DEF( void )
   gxv_StateTable_validate( FT_Bytes       table,
                            FT_Bytes       limit,
-                           GXV_Validator  valid )
+                           GXV_Validator  gxvalid )
   {
     FT_UShort   stateSize;
     FT_UShort   classTable;     /* offset to Class(Sub)Table */
@@ -1250,11 +1250,11 @@
     if ( stateSize > 0xFF )
       FT_INVALID_DATA;
 
-    if ( valid->statetable.optdata_load_func != NULL )
-      valid->statetable.optdata_load_func( p, limit, valid );
+    if ( gxvalid->statetable.optdata_load_func != NULL )
+      gxvalid->statetable.optdata_load_func( p, limit, gxvalid );
 
-    if ( valid->statetable.subtable_setup_func != NULL)
-      setup_func = valid->statetable.subtable_setup_func;
+    if ( gxvalid->statetable.subtable_setup_func != NULL)
+      setup_func = gxvalid->statetable.subtable_setup_func;
     else
       setup_func = gxv_StateTable_subtable_setup;
 
@@ -1265,7 +1265,7 @@
                 &classTable_length,
                 &stateArray_length,
                 &entryTable_length,
-                valid );
+                gxvalid );
 
     GXV_TRACE(( "StateTable Subtables\n" ));
 
@@ -1274,7 +1274,7 @@
                                &classTable_length,
                                stateSize,
                                &maxClassID,
-                               valid );
+                               gxvalid );
     else
       maxClassID = (FT_Byte)( stateSize - 1 );
 
@@ -1285,7 +1285,7 @@
                                stateSize,
                                &maxState,
                                &maxEntry,
-                               valid );
+                               gxvalid );
     else
     {
 #if 0
@@ -1306,7 +1306,7 @@
                                maxClassID,
                                table,
                                limit,
-                               valid );
+                               gxvalid );
 
     GXV_EXIT;
   }
@@ -1322,7 +1322,7 @@
                                   FT_ULong*      classTable_length_p,
                                   FT_ULong*      stateArray_length_p,
                                   FT_ULong*      entryTable_length_p,
-                                  GXV_Validator  valid )
+                                  GXV_Validator  gxvalid )
   {
     FT_ULong   o[3];
     FT_ULong*  l[3];
@@ -1336,21 +1336,21 @@
     l[1] = stateArray_length_p;
     l[2] = entryTable_length_p;
 
-    gxv_set_length_by_ulong_offset( o, l, buff, 3, table_size, valid );
+    gxv_set_length_by_ulong_offset( o, l, buff, 3, table_size, gxvalid );
   }
 
 
   static void
   gxv_XClassTable_lookupval_validate( FT_UShort            glyph,
                                       GXV_LookupValueCPtr  value_p,
-                                      GXV_Validator        valid )
+                                      GXV_Validator        gxvalid )
   {
     FT_UNUSED( glyph );
 
-    if ( value_p->u >= valid->xstatetable.nClasses )
+    if ( value_p->u >= gxvalid->xstatetable.nClasses )
       FT_INVALID_DATA;
-    if ( value_p->u > valid->xstatetable.maxClassID )
-      valid->xstatetable.maxClassID = value_p->u;
+    if ( value_p->u > gxvalid->xstatetable.maxClassID )
+      gxvalid->xstatetable.maxClassID = value_p->u;
   }
 
 
@@ -1384,7 +1384,7 @@
   gxv_XClassTable_lookupfmt4_transit( FT_UShort            relative_gindex,
                                       GXV_LookupValueCPtr  base_value_p,
                                       FT_Bytes             lookuptbl_limit,
-                                      GXV_Validator        valid )
+                                      GXV_Validator        gxvalid )
   {
     FT_Bytes             p;
     FT_Bytes             limit;
@@ -1395,7 +1395,7 @@
     offset = (FT_UShort)( base_value_p->u +
                           relative_gindex * sizeof ( FT_UShort ) );
 
-    p     = valid->lookuptbl_head + offset;
+    p     = gxvalid->lookuptbl_head + offset;
     limit = lookuptbl_limit;
 
     GXV_LIMIT_CHECK ( 2 );
@@ -1412,7 +1412,7 @@
                             FT_ULong       stateSize,
                             FT_UShort*     maxState_p,
                             FT_UShort*     maxEntry_p,
-                            GXV_Validator  valid )
+                            GXV_Validator  gxvalid )
   {
     FT_Bytes   p = table;
     FT_Bytes   limit = table + *length_p;
@@ -1463,7 +1463,7 @@
                             FT_UShort      maxClassID,
                             FT_Bytes       xstatetable_table,
                             FT_Bytes       xstatetable_limit,
-                            GXV_Validator  valid )
+                            GXV_Validator  gxvalid )
   {
     FT_Bytes   p = table;
     FT_Bytes   limit = table + *length_p;
@@ -1540,13 +1540,13 @@
         goto Exit;
       }
 
-      if ( NULL != valid->xstatetable.entry_validate_func )
-        valid->xstatetable.entry_validate_func( state,
-                                                flags,
-                                                &glyphOffset,
-                                                xstatetable_table,
-                                                xstatetable_limit,
-                                                valid );
+      if ( NULL != gxvalid->xstatetable.entry_validate_func )
+        gxvalid->xstatetable.entry_validate_func( state,
+                                                  flags,
+                                                  &glyphOffset,
+                                                  xstatetable_table,
+                                                  xstatetable_limit,
+                                                  gxvalid );
     }
 
   Exit:
@@ -1559,7 +1559,7 @@
   FT_LOCAL_DEF( void )
   gxv_XStateTable_validate( FT_Bytes       table,
                             FT_Bytes       limit,
-                            GXV_Validator  valid )
+                            GXV_Validator  gxvalid )
   {
     /* StateHeader members */
     FT_ULong   classTable;      /* offset to Class(Sub)Table */
@@ -1582,26 +1582,26 @@
     GXV_TRACE(( "XStateTable header\n" ));
 
     GXV_LIMIT_CHECK( 4 + 4 + 4 + 4 );
-    valid->xstatetable.nClasses = FT_NEXT_ULONG( p );
+    gxvalid->xstatetable.nClasses = FT_NEXT_ULONG( p );
     classTable = FT_NEXT_ULONG( p );
     stateArray = FT_NEXT_ULONG( p );
     entryTable = FT_NEXT_ULONG( p );
 
-    GXV_TRACE(( "nClasses =0x%08x\n", valid->xstatetable.nClasses ));
+    GXV_TRACE(( "nClasses =0x%08x\n", gxvalid->xstatetable.nClasses ));
     GXV_TRACE(( "offset to classTable=0x%08x\n", classTable ));
     GXV_TRACE(( "offset to stateArray=0x%08x\n", stateArray ));
     GXV_TRACE(( "offset to entryTable=0x%08x\n", entryTable ));
 
-    if ( valid->xstatetable.nClasses > 0xFFFFU )
+    if ( gxvalid->xstatetable.nClasses > 0xFFFFU )
       FT_INVALID_DATA;
 
     GXV_TRACE(( "StateTable Subtables\n" ));
 
-    if ( valid->xstatetable.optdata_load_func != NULL )
-      valid->xstatetable.optdata_load_func( p, limit, valid );
+    if ( gxvalid->xstatetable.optdata_load_func != NULL )
+      gxvalid->xstatetable.optdata_load_func( p, limit, gxvalid );
 
-    if ( valid->xstatetable.subtable_setup_func != NULL )
-      setup_func = valid->xstatetable.subtable_setup_func;
+    if ( gxvalid->xstatetable.subtable_setup_func != NULL )
+      setup_func = gxvalid->xstatetable.subtable_setup_func;
     else
       setup_func = gxv_XStateTable_subtable_setup;
 
@@ -1612,37 +1612,37 @@
                 &classTable_length,
                 &stateArray_length,
                 &entryTable_length,
-                valid );
+                gxvalid );
 
     if ( classTable != 0 )
     {
-      valid->xstatetable.maxClassID = 0;
-      valid->lookupval_sign         = GXV_LOOKUPVALUE_UNSIGNED;
-      valid->lookupval_func         = gxv_XClassTable_lookupval_validate;
-      valid->lookupfmt4_trans       = gxv_XClassTable_lookupfmt4_transit;
+      gxvalid->xstatetable.maxClassID = 0;
+      gxvalid->lookupval_sign         = GXV_LOOKUPVALUE_UNSIGNED;
+      gxvalid->lookupval_func         = gxv_XClassTable_lookupval_validate;
+      gxvalid->lookupfmt4_trans       = gxv_XClassTable_lookupfmt4_transit;
       gxv_LookupTable_validate( table + classTable,
                                 table + classTable + classTable_length,
-                                valid );
+                                gxvalid );
 #if 0
-      if ( valid->subtable_length < classTable_length )
-        classTable_length = valid->subtable_length;
+      if ( gxvalid->subtable_length < classTable_length )
+        classTable_length = gxvalid->subtable_length;
 #endif
     }
     else
     {
       /* XXX: check range? */
-      valid->xstatetable.maxClassID =
-        (FT_UShort)( valid->xstatetable.nClasses - 1 );
+      gxvalid->xstatetable.maxClassID =
+        (FT_UShort)( gxvalid->xstatetable.nClasses - 1 );
     }
 
     if ( stateArray != 0 )
       gxv_XStateArray_validate( table + stateArray,
                                 &stateArray_length,
-                                valid->xstatetable.maxClassID,
-                                valid->xstatetable.nClasses,
+                                gxvalid->xstatetable.maxClassID,
+                                gxvalid->xstatetable.nClasses,
                                 &maxState,
                                 &maxEntry,
-                                valid );
+                                gxvalid );
     else
     {
 #if 0
@@ -1659,10 +1659,10 @@
                                 &entryTable_length,
                                 maxEntry,
                                 stateArray_length,
-                                valid->xstatetable.maxClassID,
+                                gxvalid->xstatetable.maxClassID,
                                 table,
                                 limit,
-                                valid );
+                                gxvalid );
 
     GXV_EXIT;
   }
@@ -1719,7 +1719,7 @@
 
   FT_LOCAL_DEF( void )
   gxv_odtect_validate( GXV_odtect_Range  odtect,
-                       GXV_Validator     valid )
+                       GXV_Validator     gxvalid )
   {
     FT_UInt  i, j;
 
diff --git a/src/gxvalid/gxvcommn.h b/src/gxvalid/gxvcommn.h
index 2f44a75..f114345 100644
--- a/src/gxvalid/gxvcommn.h
+++ b/src/gxvalid/gxvcommn.h
@@ -4,7 +4,7 @@
 /*                                                                         */
 /*    TrueTypeGX/AAT common tables validation (specification).             */
 /*                                                                         */
-/*  Copyright 2004, 2005, 2012                                             */
+/*  Copyright 2004, 2005, 2012, 2014                                       */
 /*  by suzuki toshiya, Masatake YAMATO, Red Hat K.K.,                      */
 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
 /*                                                                         */
@@ -62,7 +62,7 @@ FT_BEGIN_HEADER
 
 #undef GXV_LOAD_UNUSED_VARS /* debug purpose */
 
-#define IS_PARANOID_VALIDATION          ( valid->root->level >= FT_VALIDATE_PARANOID )
+#define IS_PARANOID_VALIDATION          ( gxvalid->root->level >= FT_VALIDATE_PARANOID )
 #define GXV_SET_ERR_IF_PARANOID( err )  { if ( IS_PARANOID_VALIDATION ) ( err ); }
 
   /*************************************************************************/
@@ -81,7 +81,7 @@ FT_BEGIN_HEADER
   typedef void
   (*GXV_Validate_Func)( FT_Bytes       table,
                         FT_Bytes       limit,
-                        GXV_Validator  valid );
+                        GXV_Validator  gxvalid );
 
 
   /* ====================== LookupTable Validator ======================== */
@@ -106,13 +106,13 @@ FT_BEGIN_HEADER
   typedef void
   (*GXV_Lookup_Value_Validate_Func)( FT_UShort            glyph,
                                      GXV_LookupValueCPtr  value_p,
-                                     GXV_Validator        valid );
+                                     GXV_Validator        gxvalid );
 
   typedef GXV_LookupValueDesc
   (*GXV_Lookup_Fmt4_Transit_Func)( FT_UShort            relative_gindex,
                                    GXV_LookupValueCPtr  base_value_p,
                                    FT_Bytes             lookuptbl_limit,
-                                   GXV_Validator        valid );
+                                   GXV_Validator        gxvalid );
 
 
   /* ====================== StateTable Validator ========================= */
@@ -131,10 +131,10 @@ FT_BEGIN_HEADER
 
 
 #define GXV_GLYPHOFFSET_FMT( table )           \
-        ( valid->table.entry_glyphoffset_fmt )
+        ( gxvalid->table.entry_glyphoffset_fmt )
 
 #define GXV_GLYPHOFFSET_SIZE( table )              \
-        ( valid->table.entry_glyphoffset_fmt / 2 )
+        ( gxvalid->table.entry_glyphoffset_fmt / 2 )
 
 
   /* ----------------------- 16bit StateTable ---------------------------- */
@@ -160,7 +160,7 @@ FT_BEGIN_HEADER
                                          FT_UShort*     classTable_length_p,
                                          FT_UShort*     stateArray_length_p,
                                          FT_UShort*     entryTable_length_p,
-                                         GXV_Validator  valid );
+                                         GXV_Validator  gxvalid );
 
   typedef void
   (*GXV_StateTable_Entry_Validate_Func)(
@@ -169,12 +169,12 @@ FT_BEGIN_HEADER
      GXV_StateTable_GlyphOffsetCPtr  glyphOffset_p,
      FT_Bytes                        statetable_table,
      FT_Bytes                        statetable_limit,
-     GXV_Validator                   valid );
+     GXV_Validator                   gxvalid );
 
   typedef void
   (*GXV_StateTable_OptData_Load_Func)( FT_Bytes       table,
                                        FT_Bytes       limit,
-                                       GXV_Validator  valid );
+                                       GXV_Validator  gxvalid );
 
   typedef struct  GXV_StateTable_ValidatorRec_
   {
@@ -202,7 +202,7 @@ FT_BEGIN_HEADER
                                           FT_ULong*      classTable_length_p,
                                           FT_ULong*      stateArray_length_p,
                                           FT_ULong*      entryTable_length_p,
-                                          GXV_Validator  valid );
+                                          GXV_Validator  gxvalid );
 
   typedef void
   (*GXV_XStateTable_Entry_Validate_Func)(
@@ -211,7 +211,7 @@ FT_BEGIN_HEADER
      GXV_StateTable_GlyphOffsetCPtr  glyphOffset_p,
      FT_Bytes                        xstatetable_table,
      FT_Bytes                        xstatetable_limit,
-     GXV_Validator                   valid );
+     GXV_Validator                   gxvalid );
 
 
   typedef GXV_StateTable_OptData_Load_Func  GXV_XStateTable_OptData_Load_Func;
@@ -263,35 +263,35 @@ FT_BEGIN_HEADER
 
 
 #define GXV_TABLE_DATA( tag, field )                           \
-        ( ( (GXV_ ## tag ## _Data)valid->table_data )->field )
+        ( ( (GXV_ ## tag ## _Data)gxvalid->table_data )->field )
 
 #undef  FT_INVALID_
-#define FT_INVALID_( _prefix, _error )                         \
-          ft_validator_error( valid->root, _prefix ## _error )
+#define FT_INVALID_( _error ) \
+          ft_validator_error( gxvalid->root, FT_THROW( _error ) )
 
 #define GXV_LIMIT_CHECK( _count )                                     \
           FT_BEGIN_STMNT                                              \
-            if ( p + _count > ( limit? limit : valid->root->limit ) ) \
+            if ( p + _count > ( limit? limit : gxvalid->root->limit ) ) \
               FT_INVALID_TOO_SHORT;                                   \
           FT_END_STMNT
 
 
 #ifdef FT_DEBUG_LEVEL_TRACE
 
-#define GXV_INIT  valid->debug_indent = 0
+#define GXV_INIT  gxvalid->debug_indent = 0
 
 #define GXV_NAME_ENTER( name )                             \
           FT_BEGIN_STMNT                                   \
-            valid->debug_indent += 2;                      \
-            FT_TRACE4(( "%*.s", valid->debug_indent, 0 )); \
+            gxvalid->debug_indent += 2;                      \
+            FT_TRACE4(( "%*.s", gxvalid->debug_indent, 0 )); \
             FT_TRACE4(( "%s table\n", name ));             \
           FT_END_STMNT
 
-#define GXV_EXIT  valid->debug_indent -= 2
+#define GXV_EXIT  gxvalid->debug_indent -= 2
 
 #define GXV_TRACE( s )                                     \
           FT_BEGIN_STMNT                                   \
-            FT_TRACE4(( "%*.s", valid->debug_indent, 0 )); \
+            FT_TRACE4(( "%*.s", gxvalid->debug_indent, 0 )); \
             FT_TRACE4( s );                                \
           FT_END_STMNT
 
@@ -349,7 +349,7 @@ FT_BEGIN_HEADER
                                                         \
                                                         \
               for ( b = p; b < (FT_Bytes)p + len; b++ ) \
-                if ( 0x40 < *b && *b < 0x7e )           \
+                if ( 0x40 < *b && *b < 0x7E )           \
                   FT_TRACE1(("%c", *b)) ;               \
                 else                                    \
                   FT_TRACE1(("\\x%02x", *b)) ;          \
@@ -373,12 +373,12 @@ FT_BEGIN_HEADER
                               FT_Bytes       limit,
                               FT_UShort*     unitSize_p,
                               FT_UShort*     nUnits_p,
-                              GXV_Validator  valid );
+                              GXV_Validator  gxvalid );
 
   FT_LOCAL( void )
   gxv_LookupTable_validate( FT_Bytes       table,
                             FT_Bytes       limit,
-                            GXV_Validator  valid );
+                            GXV_Validator  gxvalid );
 
 
   /*************************************************************************/
@@ -391,7 +391,7 @@ FT_BEGIN_HEADER
 
   FT_LOCAL( FT_Int )
   gxv_glyphid_validate( FT_UShort      gid,
-                        GXV_Validator  valid );
+                        GXV_Validator  gxvalid );
 
 
   /*************************************************************************/
@@ -405,7 +405,7 @@ FT_BEGIN_HEADER
   FT_LOCAL( void )
   gxv_ctlPoint_validate( FT_UShort      gid,
                          FT_Short       ctl_point,
-                         GXV_Validator  valid );
+                         GXV_Validator  gxvalid );
 
 
   /*************************************************************************/
@@ -420,7 +420,7 @@ FT_BEGIN_HEADER
   gxv_sfntName_validate( FT_UShort      name_index,
                          FT_UShort      min_index,
                          FT_UShort      max_index,
-                         GXV_Validator  valid );
+                         GXV_Validator  gxvalid );
 
 
   /*************************************************************************/
@@ -439,7 +439,7 @@ FT_BEGIN_HEADER
                                  FT_UShort*     classTable_length_p,
                                  FT_UShort*     stateArray_length_p,
                                  FT_UShort*     entryTable_length_p,
-                                 GXV_Validator  valid );
+                                 GXV_Validator  gxvalid );
 
   FT_LOCAL( void )
   gxv_XStateTable_subtable_setup( FT_ULong       table_size,
@@ -449,17 +449,17 @@ FT_BEGIN_HEADER
                                   FT_ULong*      classTable_length_p,
                                   FT_ULong*      stateArray_length_p,
                                   FT_ULong*      entryTable_length_p,
-                                  GXV_Validator  valid );
+                                  GXV_Validator  gxvalid );
 
   FT_LOCAL( void )
   gxv_StateTable_validate( FT_Bytes       table,
                            FT_Bytes       limit,
-                           GXV_Validator  valid );
+                           GXV_Validator  gxvalid );
 
   FT_LOCAL( void )
   gxv_XStateTable_validate( FT_Bytes       table,
                             FT_Bytes       limit,
-                            GXV_Validator  valid );
+                            GXV_Validator  gxvalid );
 
 
   /*************************************************************************/
@@ -475,14 +475,14 @@ FT_BEGIN_HEADER
                             FT_Bytes       limit,
                             FT_Byte*       min,
                             FT_Byte*       max,
-                            GXV_Validator  valid );
+                            GXV_Validator  gxvalid );
 
   FT_LOCAL( void )
   gxv_array_getlimits_ushort( FT_Bytes       table,
                               FT_Bytes       limit,
                               FT_UShort*     min,
                               FT_UShort*     max,
-                              GXV_Validator  valid );
+                              GXV_Validator  gxvalid );
 
   FT_LOCAL( void )
   gxv_set_length_by_ushort_offset( FT_UShort*     offset,
@@ -490,7 +490,7 @@ FT_BEGIN_HEADER
                                    FT_UShort*     buff,
                                    FT_UInt        nmemb,
                                    FT_UShort      limit,
-                                   GXV_Validator  valid );
+                                   GXV_Validator  gxvalid );
 
   FT_LOCAL( void )
   gxv_set_length_by_ulong_offset( FT_ULong*      offset,
@@ -498,19 +498,19 @@ FT_BEGIN_HEADER
                                   FT_ULong*      buff,
                                   FT_UInt        nmemb,
                                   FT_ULong       limit,
-                                  GXV_Validator  valid);
+                                  GXV_Validator  gxvalid);
 
 
 #define GXV_SUBTABLE_OFFSET_CHECK( _offset )          \
           FT_BEGIN_STMNT                              \
-            if ( (_offset) > valid->subtable_length ) \
+            if ( (_offset) > gxvalid->subtable_length ) \
               FT_INVALID_OFFSET;                      \
           FT_END_STMNT
 
 #define GXV_SUBTABLE_LIMIT_CHECK( _count )                  \
           FT_BEGIN_STMNT                                    \
-            if ( ( p + (_count) - valid->subtable_start ) > \
-                   valid->subtable_length )                 \
+            if ( ( p + (_count) - gxvalid->subtable_start ) > \
+                   gxvalid->subtable_length )                 \
               FT_INVALID_TOO_SHORT;                         \
           FT_END_STMNT
 
@@ -556,7 +556,7 @@ FT_BEGIN_HEADER
 
   FT_LOCAL( void )
   gxv_odtect_validate( GXV_odtect_Range  odtect,
-                       GXV_Validator     valid );
+                       GXV_Validator     gxvalid );
 
 
 #define GXV_ODTECT( n, odtect )                              \
diff --git a/src/gxvalid/gxvfeat.c b/src/gxvalid/gxvfeat.c
index 6f75650..69298b2 100644
--- a/src/gxvalid/gxvfeat.c
+++ b/src/gxvalid/gxvfeat.c
@@ -82,7 +82,7 @@
   gxv_feat_registry_validate( FT_UShort      feature,
                               FT_UShort      nSettings,
                               FT_Bool        exclusive,
-                              GXV_Validator  valid )
+                              GXV_Validator  gxvalid )
   {
     GXV_NAME_ENTER( "feature in registry" );
 
@@ -108,7 +108,7 @@
     {
       /* Don't use here. Apple is reserved. */
       GXV_TRACE(( "feature number %d is reserved by Apple\n", feature ));
-      if ( valid->root->level >= FT_VALIDATE_TIGHT )
+      if ( gxvalid->root->level >= FT_VALIDATE_TIGHT )
         FT_INVALID_DATA;
     }
 
@@ -117,7 +117,7 @@
       GXV_TRACE(( "feature %d: nSettings %d != defined nSettings %d\n",
                   feature, nSettings,
                   gxv_feat_registry[feature].nSettings ));
-      if ( valid->root->level >= FT_VALIDATE_TIGHT )
+      if ( gxvalid->root->level >= FT_VALIDATE_TIGHT )
         FT_INVALID_DATA;
     }
 
@@ -125,7 +125,7 @@
     {
       GXV_TRACE(( "exclusive flag %d differs from predefined value\n",
                   exclusive ));
-      if ( valid->root->level >= FT_VALIDATE_TIGHT )
+      if ( gxvalid->root->level >= FT_VALIDATE_TIGHT )
         FT_INVALID_DATA;
     }
 
@@ -137,7 +137,7 @@
   static void
   gxv_feat_name_index_validate( FT_Bytes       table,
                                 FT_Bytes       limit,
-                                GXV_Validator  valid )
+                                GXV_Validator  gxvalid )
   {
     FT_Bytes  p = table;
 
@@ -153,7 +153,7 @@
     gxv_sfntName_validate( (FT_UShort)nameIndex,
                            255,
                            32768U,
-                           valid );
+                           gxvalid );
 
     GXV_EXIT;
   }
@@ -163,7 +163,7 @@
   gxv_feat_setting_validate( FT_Bytes       table,
                              FT_Bytes       limit,
                              FT_Bool        exclusive,
-                             GXV_Validator  valid )
+                             GXV_Validator  gxvalid )
   {
     FT_Bytes   p = table;
     FT_UShort  setting;
@@ -179,7 +179,7 @@
     if ( exclusive && ( setting & 1 ) == 0 )
       FT_INVALID_DATA;
 
-    gxv_feat_name_index_validate( p, limit, valid );
+    gxv_feat_name_index_validate( p, limit, gxvalid );
 
     GXV_FEAT_DATA( setting ) = setting;
 
@@ -190,7 +190,7 @@
   static void
   gxv_feat_name_validate( FT_Bytes       table,
                           FT_Bytes       limit,
-                          GXV_Validator  valid )
+                          GXV_Validator  gxvalid )
   {
     FT_Bytes   p             = table;
     FT_UInt    reserved_size = GXV_FEAT_DATA( reserved_size );
@@ -240,14 +240,14 @@
         FT_INVALID_FORMAT;
     }
 
-    gxv_feat_registry_validate( feature, nSettings, exclusive, valid );
+    gxv_feat_registry_validate( feature, nSettings, exclusive, gxvalid );
 
-    gxv_feat_name_index_validate( p, limit, valid );
+    gxv_feat_name_index_validate( p, limit, gxvalid );
 
-    p = valid->root->base + settingTable;
+    p = gxvalid->root->base + settingTable;
     for ( last_setting = -1, i = 0; i < nSettings; i++ )
     {
-      gxv_feat_setting_validate( p, limit, exclusive, valid );
+      gxv_feat_setting_validate( p, limit, exclusive, gxvalid );
 
       if ( (FT_Int)GXV_FEAT_DATA( setting ) <= last_setting )
         GXV_SET_ERR_IF_PARANOID( FT_INVALID_FORMAT );
@@ -274,8 +274,8 @@
                      FT_Face       face,
                      FT_Validator  ftvalid )
   {
-    GXV_ValidatorRec  validrec;
-    GXV_Validator     valid = &validrec;
+    GXV_ValidatorRec  gxvalidrec;
+    GXV_Validator     gxvalid = &gxvalidrec;
 
     GXV_feat_DataRec  featrec;
     GXV_feat_Data     feat = &featrec;
@@ -289,9 +289,9 @@
     FT_Int            last_feature;
 
 
-    valid->root       = ftvalid;
-    valid->table_data = feat;
-    valid->face       = face;
+    gxvalid->root       = ftvalid;
+    gxvalid->table_data = feat;
+    gxvalid->face       = face;
 
     FT_TRACE3(( "validating `feat' table\n" ));
     GXV_INIT;
@@ -323,7 +323,7 @@
 
     for ( last_feature = -1, i = 0; i < featureNameCount; i++ )
     {
-      gxv_feat_name_validate( p, limit, valid );
+      gxv_feat_name_validate( p, limit, gxvalid );
 
       if ( (FT_Int)GXV_FEAT_DATA( feature ) <= last_feature )
         GXV_SET_ERR_IF_PARANOID( FT_INVALID_FORMAT );
diff --git a/src/gxvalid/gxvjust.c b/src/gxvalid/gxvjust.c
index 7816e0b..24c26a5 100644
--- a/src/gxvalid/gxvjust.c
+++ b/src/gxvalid/gxvjust.c
@@ -4,7 +4,7 @@
 /*                                                                         */
 /*    TrueTypeGX/AAT just table validation (body).                         */
 /*                                                                         */
-/*  Copyright 2005 by suzuki toshiya, Masatake YAMATO, Red Hat K.K.,       */
+/*  Copyright 2005, 2014 by suzuki toshiya, Masatake YAMATO, Red Hat K.K., */
 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
 /*                                                                         */
 /*  This file is part of the FreeType project, and may only be used,       */
@@ -69,14 +69,14 @@
   static void
   gxv_just_check_max_gid( FT_UShort         gid,
                           const FT_String*  msg_tag,
-                          GXV_Validator     valid )
+                          GXV_Validator     gxvalid )
   {
-    if ( gid < valid->face->num_glyphs )
+    if ( gid < gxvalid->face->num_glyphs )
       return;
 
     GXV_TRACE(( "just table includes too large %s"
                 " GID=%d > %d (in maxp)\n",
-                msg_tag, gid, valid->face->num_glyphs ));
+                msg_tag, gid, gxvalid->face->num_glyphs ));
     GXV_SET_ERR_IF_PARANOID( FT_INVALID_GLYPH_ID );
   }
 
@@ -84,7 +84,7 @@
   static void
   gxv_just_wdp_entry_validate( FT_Bytes       table,
                                FT_Bytes       limit,
-                               GXV_Validator  valid )
+                               GXV_Validator  gxvalid )
   {
     FT_Bytes   p = table;
     FT_ULong   justClass;
@@ -112,7 +112,7 @@
 #endif
 
     /* According to Apple spec, only 7bits in justClass is used */
-    if ( ( justClass & 0xFFFFFF80 ) != 0 )
+    if ( ( justClass & 0xFFFFFF80UL ) != 0 )
     {
       GXV_TRACE(( "just table includes non-zero value"
                   " in unused justClass higher bits"
@@ -120,14 +120,14 @@
       GXV_SET_ERR_IF_PARANOID( FT_INVALID_DATA );
     }
 
-    valid->subtable_length = p - table;
+    gxvalid->subtable_length = p - table;
   }
 
 
   static void
   gxv_just_wdc_entry_validate( FT_Bytes       table,
                                FT_Bytes       limit,
-                               GXV_Validator  valid )
+                               GXV_Validator  gxvalid )
   {
     FT_Bytes  p = table;
     FT_ULong  count, i;
@@ -138,18 +138,18 @@
     for ( i = 0; i < count; i++ )
     {
       GXV_TRACE(( "validating wdc pair %d/%d\n", i + 1, count ));
-      gxv_just_wdp_entry_validate( p, limit, valid );
-      p += valid->subtable_length;
+      gxv_just_wdp_entry_validate( p, limit, gxvalid );
+      p += gxvalid->subtable_length;
     }
 
-    valid->subtable_length = p - table;
+    gxvalid->subtable_length = p - table;
   }
 
 
   static void
   gxv_just_widthDeltaClusters_validate( FT_Bytes       table,
                                         FT_Bytes       limit,
-                                        GXV_Validator  valid )
+                                        GXV_Validator  gxvalid )
   {
     FT_Bytes  p         = table ;
     FT_Bytes  wdc_end   = table + GXV_JUST_DATA( wdc_offset_max );
@@ -163,11 +163,11 @@
 
     for ( i = 0; p <= wdc_end; i++ )
     {
-      gxv_just_wdc_entry_validate( p, limit, valid );
-      p += valid->subtable_length;
+      gxv_just_wdc_entry_validate( p, limit, gxvalid );
+      p += gxvalid->subtable_length;
     }
 
-    valid->subtable_length = p - table;
+    gxvalid->subtable_length = p - table;
 
     GXV_EXIT;
   }
@@ -176,7 +176,7 @@
   static void
   gxv_just_actSubrecord_type0_validate( FT_Bytes       table,
                                         FT_Bytes       limit,
-                                        GXV_Validator  valid )
+                                        GXV_Validator  gxvalid )
   {
     FT_Bytes   p = table;
 
@@ -214,17 +214,17 @@
 
       GXV_LIMIT_CHECK( 2 );
       glyphs = FT_NEXT_USHORT( p );
-      gxv_just_check_max_gid( glyphs, "type0:glyphs", valid );
+      gxv_just_check_max_gid( glyphs, "type0:glyphs", gxvalid );
     }
 
-    valid->subtable_length = p - table;
+    gxvalid->subtable_length = p - table;
   }
 
 
   static void
   gxv_just_actSubrecord_type1_validate( FT_Bytes       table,
                                         FT_Bytes       limit,
-                                        GXV_Validator  valid )
+                                        GXV_Validator  gxvalid )
   {
     FT_Bytes   p = table;
     FT_UShort  addGlyph;
@@ -233,20 +233,20 @@
     GXV_LIMIT_CHECK( 2 );
     addGlyph = FT_NEXT_USHORT( p );
 
-    gxv_just_check_max_gid( addGlyph, "type1:addGlyph", valid );
+    gxv_just_check_max_gid( addGlyph, "type1:addGlyph", gxvalid );
 
-    valid->subtable_length = p - table;
+    gxvalid->subtable_length = p - table;
   }
 
 
   static void
   gxv_just_actSubrecord_type2_validate( FT_Bytes       table,
                                         FT_Bytes       limit,
-                                        GXV_Validator  valid )
+                                        GXV_Validator  gxvalid )
   {
     FT_Bytes   p = table;
 #ifdef GXV_LOAD_UNUSED_VARS
-    FT_Fixed   substThreshhold; /* Apple misspelled "Threshhold" */
+    FT_Fixed      substThreshhold; /* Apple misspelled "Threshhold" */
 #endif
     FT_UShort  addGlyph;
     FT_UShort  substGlyph;
@@ -262,18 +262,18 @@
     substGlyph      = FT_NEXT_USHORT( p );
 
     if ( addGlyph != 0xFFFF )
-      gxv_just_check_max_gid( addGlyph, "type2:addGlyph", valid );
+      gxv_just_check_max_gid( addGlyph, "type2:addGlyph", gxvalid );
 
-    gxv_just_check_max_gid( substGlyph, "type2:substGlyph", valid );
+    gxv_just_check_max_gid( substGlyph, "type2:substGlyph", gxvalid );
 
-    valid->subtable_length = p - table;
+    gxvalid->subtable_length = p - table;
   }
 
 
   static void
   gxv_just_actSubrecord_type4_validate( FT_Bytes       table,
                                         FT_Bytes       limit,
-                                        GXV_Validator  valid )
+                                        GXV_Validator  gxvalid )
   {
     FT_Bytes  p = table;
     FT_ULong  variantsAxis;
@@ -288,9 +288,9 @@
     noStretchValue = FT_NEXT_ULONG( p );
     maximumLimit   = FT_NEXT_ULONG( p );
 
-    valid->subtable_length = p - table;
+    gxvalid->subtable_length = p - table;
 
-    if ( variantsAxis != 0x64756374 ) /* 'duct' */
+    if ( variantsAxis != 0x64756374L ) /* 'duct' */
       GXV_TRACE(( "variantsAxis 0x%08x is non default value",
                    variantsAxis ));
 
@@ -310,7 +310,7 @@
   static void
   gxv_just_actSubrecord_type5_validate( FT_Bytes       table,
                                         FT_Bytes       limit,
-                                        GXV_Validator  valid )
+                                        GXV_Validator  gxvalid )
   {
     FT_Bytes   p = table;
     FT_UShort  flags;
@@ -324,9 +324,9 @@
     if ( flags )
       GXV_TRACE(( "type5: nonzero value 0x%04x in unused flags\n",
                    flags ));
-    gxv_just_check_max_gid( glyph, "type5:glyph", valid );
+    gxv_just_check_max_gid( glyph, "type5:glyph", gxvalid );
 
-    valid->subtable_length = p - table;
+    gxvalid->subtable_length = p - table;
   }
 
 
@@ -334,7 +334,7 @@
   static void
   gxv_just_actSubrecord_validate( FT_Bytes       table,
                                   FT_Bytes       limit,
-                                  GXV_Validator  valid )
+                                  GXV_Validator  gxvalid )
   {
     FT_Bytes   p = table;
     FT_UShort  actionClass;
@@ -354,21 +354,21 @@
       GXV_SET_ERR_IF_PARANOID( FT_INVALID_DATA );
 
     if ( actionType == 0 )
-      gxv_just_actSubrecord_type0_validate( p, limit, valid );
+      gxv_just_actSubrecord_type0_validate( p, limit, gxvalid );
     else if ( actionType == 1 )
-      gxv_just_actSubrecord_type1_validate( p, limit, valid );
+      gxv_just_actSubrecord_type1_validate( p, limit, gxvalid );
     else if ( actionType == 2 )
-      gxv_just_actSubrecord_type2_validate( p, limit, valid );
+      gxv_just_actSubrecord_type2_validate( p, limit, gxvalid );
     else if ( actionType == 3 )
       ;                         /* Stretch glyph action: no actionData */
     else if ( actionType == 4 )
-      gxv_just_actSubrecord_type4_validate( p, limit, valid );
+      gxv_just_actSubrecord_type4_validate( p, limit, gxvalid );
     else if ( actionType == 5 )
-      gxv_just_actSubrecord_type5_validate( p, limit, valid );
+      gxv_just_actSubrecord_type5_validate( p, limit, gxvalid );
     else
       FT_INVALID_DATA;
 
-    valid->subtable_length = actionLength;
+    gxvalid->subtable_length = actionLength;
 
     GXV_EXIT;
   }
@@ -377,7 +377,7 @@
   static void
   gxv_just_pcActionRecord_validate( FT_Bytes       table,
                                     FT_Bytes       limit,
-                                    GXV_Validator  valid )
+                                    GXV_Validator  gxvalid )
   {
     FT_Bytes  p = table;
     FT_ULong  actionCount;
@@ -390,11 +390,11 @@
 
     for ( i = 0; i < actionCount; i++ )
     {
-      gxv_just_actSubrecord_validate( p, limit, valid );
-      p += valid->subtable_length;
+      gxv_just_actSubrecord_validate( p, limit, gxvalid );
+      p += gxvalid->subtable_length;
     }
 
-    valid->subtable_length = p - table;
+    gxvalid->subtable_length = p - table;
 
     GXV_EXIT;
   }
@@ -403,7 +403,7 @@
   static void
   gxv_just_pcTable_LookupValue_entry_validate( FT_UShort            glyph,
                                                GXV_LookupValueCPtr  value_p,
-                                               GXV_Validator        valid )
+                                               GXV_Validator        gxvalid )
   {
     FT_UNUSED( glyph );
 
@@ -417,19 +417,19 @@
   static void
   gxv_just_pcLookupTable_validate( FT_Bytes       table,
                                    FT_Bytes       limit,
-                                   GXV_Validator  valid )
+                                   GXV_Validator  gxvalid )
   {
-    FT_Bytes p = table;
+    FT_Bytes  p = table;
 
 
     GXV_NAME_ENTER( "just pcLookupTable" );
     GXV_JUST_DATA( pc_offset_max ) = 0x0000;
     GXV_JUST_DATA( pc_offset_min ) = 0xFFFFU;
 
-    valid->lookupval_sign = GXV_LOOKUPVALUE_UNSIGNED;
-    valid->lookupval_func = gxv_just_pcTable_LookupValue_entry_validate;
+    gxvalid->lookupval_sign = GXV_LOOKUPVALUE_UNSIGNED;
+    gxvalid->lookupval_func = gxv_just_pcTable_LookupValue_entry_validate;
 
-    gxv_LookupTable_validate( p, limit, valid );
+    gxv_LookupTable_validate( p, limit, gxvalid );
 
     /* subtable_length is set by gxv_LookupTable_validate() */
 
@@ -440,20 +440,20 @@
   static void
   gxv_just_postcompTable_validate( FT_Bytes       table,
                                    FT_Bytes       limit,
-                                   GXV_Validator  valid )
+                                   GXV_Validator  gxvalid )
   {
     FT_Bytes  p = table;
 
 
     GXV_NAME_ENTER( "just postcompTable" );
 
-    gxv_just_pcLookupTable_validate( p, limit, valid );
-    p += valid->subtable_length;
+    gxv_just_pcLookupTable_validate( p, limit, gxvalid );
+    p += gxvalid->subtable_length;
 
-    gxv_just_pcActionRecord_validate( p, limit, valid );
-    p += valid->subtable_length;
+    gxv_just_pcActionRecord_validate( p, limit, gxvalid );
+    p += gxvalid->subtable_length;
 
-    valid->subtable_length = p - table;
+    gxvalid->subtable_length = p - table;
 
     GXV_EXIT;
   }
@@ -466,7 +466,7 @@
     GXV_StateTable_GlyphOffsetCPtr  glyphOffset_p,
     FT_Bytes                        table,
     FT_Bytes                        limit,
-    GXV_Validator                   valid )
+    GXV_Validator                   gxvalid )
   {
 #ifdef GXV_LOAD_UNUSED_VARS
     /* TODO: validate markClass & currentClass */
@@ -480,7 +480,7 @@
     FT_UNUSED( glyphOffset_p );
     FT_UNUSED( table );
     FT_UNUSED( limit );
-    FT_UNUSED( valid );
+    FT_UNUSED( gxvalid );
 
 #ifndef GXV_LOAD_UNUSED_VARS
     FT_UNUSED( flags );
@@ -496,7 +496,7 @@
   static void
   gxv_just_justClassTable_validate ( FT_Bytes       table,
                                      FT_Bytes       limit,
-                                     GXV_Validator  valid )
+                                     GXV_Validator  gxvalid )
   {
     FT_Bytes   p = table;
     FT_UShort  length;
@@ -521,14 +521,14 @@
       GXV_TRACE(( "  justClassTable: nonzero value (0x%08x)"
                   " in unused subFeatureFlags\n", subFeatureFlags ));
 
-    valid->statetable.optdata               = NULL;
-    valid->statetable.optdata_load_func     = NULL;
-    valid->statetable.subtable_setup_func   = NULL;
-    valid->statetable.entry_glyphoffset_fmt = GXV_GLYPHOFFSET_NONE;
-    valid->statetable.entry_validate_func   =
+    gxvalid->statetable.optdata               = NULL;
+    gxvalid->statetable.optdata_load_func     = NULL;
+    gxvalid->statetable.subtable_setup_func   = NULL;
+    gxvalid->statetable.entry_glyphoffset_fmt = GXV_GLYPHOFFSET_NONE;
+    gxvalid->statetable.entry_validate_func   =
       gxv_just_classTable_entry_validate;
 
-    gxv_StateTable_validate( p, table + length, valid );
+    gxv_StateTable_validate( p, table + length, gxvalid );
 
     /* subtable_length is set by gxv_LookupTable_validate() */
 
@@ -539,7 +539,7 @@
   static void
   gxv_just_wdcTable_LookupValue_validate( FT_UShort            glyph,
                                           GXV_LookupValueCPtr  value_p,
-                                          GXV_Validator        valid )
+                                          GXV_Validator        gxvalid )
   {
     FT_UNUSED( glyph );
 
@@ -553,7 +553,7 @@
   static void
   gxv_just_justData_lookuptable_validate( FT_Bytes       table,
                                           FT_Bytes       limit,
-                                          GXV_Validator  valid )
+                                          GXV_Validator  gxvalid )
   {
     FT_Bytes  p = table;
 
@@ -561,10 +561,10 @@
     GXV_JUST_DATA( wdc_offset_max ) = 0x0000;
     GXV_JUST_DATA( wdc_offset_min ) = 0xFFFFU;
 
-    valid->lookupval_sign = GXV_LOOKUPVALUE_UNSIGNED;
-    valid->lookupval_func = gxv_just_wdcTable_LookupValue_validate;
+    gxvalid->lookupval_sign = GXV_LOOKUPVALUE_UNSIGNED;
+    gxvalid->lookupval_func = gxv_just_wdcTable_LookupValue_validate;
 
-    gxv_LookupTable_validate( p, limit, valid );
+    gxv_LookupTable_validate( p, limit, gxvalid );
 
     /* subtable_length is set by gxv_LookupTable_validate() */
 
@@ -578,7 +578,7 @@
   static void
   gxv_just_justData_validate( FT_Bytes       table,
                               FT_Bytes       limit,
-                              GXV_Validator  valid )
+                              GXV_Validator  gxvalid )
   {
     /*
      * following 3 offsets are measured from the start of `just'
@@ -604,36 +604,36 @@
     GXV_TRACE(( " (wdcTableOffset = 0x%04x)\n", wdcTableOffset ));
     GXV_TRACE(( " (pcTableOffset = 0x%04x)\n", pcTableOffset ));
 
-    gxv_just_justData_lookuptable_validate( p, limit, valid );
-    gxv_odtect_add_range( p, valid->subtable_length,
+    gxv_just_justData_lookuptable_validate( p, limit, gxvalid );
+    gxv_odtect_add_range( p, gxvalid->subtable_length,
                           "just_LookupTable", odtect );
 
     if ( wdcTableOffset )
     {
       gxv_just_widthDeltaClusters_validate(
-        valid->root->base + wdcTableOffset, limit, valid );
-      gxv_odtect_add_range( valid->root->base + wdcTableOffset,
-                            valid->subtable_length, "just_wdcTable", odtect );
+        gxvalid->root->base + wdcTableOffset, limit, gxvalid );
+      gxv_odtect_add_range( gxvalid->root->base + wdcTableOffset,
+                            gxvalid->subtable_length, "just_wdcTable", odtect );
     }
 
     if ( pcTableOffset )
     {
-      gxv_just_postcompTable_validate( valid->root->base + pcTableOffset,
-                                       limit, valid );
-      gxv_odtect_add_range( valid->root->base + pcTableOffset,
-                            valid->subtable_length, "just_pcTable", odtect );
+      gxv_just_postcompTable_validate( gxvalid->root->base + pcTableOffset,
+                                       limit, gxvalid );
+      gxv_odtect_add_range( gxvalid->root->base + pcTableOffset,
+                            gxvalid->subtable_length, "just_pcTable", odtect );
     }
 
     if ( justClassTableOffset )
     {
       gxv_just_justClassTable_validate(
-        valid->root->base + justClassTableOffset, limit, valid );
-      gxv_odtect_add_range( valid->root->base + justClassTableOffset,
-                            valid->subtable_length, "just_justClassTable",
+        gxvalid->root->base + justClassTableOffset, limit, gxvalid );
+      gxv_odtect_add_range( gxvalid->root->base + justClassTableOffset,
+                            gxvalid->subtable_length, "just_justClassTable",
                             odtect );
     }
 
-    gxv_odtect_validate( odtect, valid );
+    gxv_odtect_validate( odtect, gxvalid );
 
     GXV_EXIT;
   }
@@ -647,8 +647,8 @@
     FT_Bytes           p     = table;
     FT_Bytes           limit = 0;
 
-    GXV_ValidatorRec   validrec;
-    GXV_Validator      valid = &validrec;
+    GXV_ValidatorRec   gxvalidrec;
+    GXV_Validator      gxvalid = &gxvalidrec;
     GXV_just_DataRec   justrec;
     GXV_just_Data      just = &justrec;
 
@@ -662,14 +662,14 @@
 
     GXV_ODTECT_INIT( odtect );
 
-    valid->root       = ftvalid;
-    valid->table_data = just;
-    valid->face       = face;
+    gxvalid->root       = ftvalid;
+    gxvalid->table_data = just;
+    gxvalid->face       = face;
 
     FT_TRACE3(( "validating `just' table\n" ));
     GXV_INIT;
 
-    limit      = valid->root->limit;
+    limit      = gxvalid->root->limit;
 
     GXV_LIMIT_CHECK( 4 + 2 + 2 + 2 );
     version     = FT_NEXT_ULONG( p );
@@ -696,19 +696,19 @@
     /* validate justData */
     if ( 0 < horizOffset )
     {
-      gxv_just_justData_validate( table + horizOffset, limit, valid );
-      gxv_odtect_add_range( table + horizOffset, valid->subtable_length,
+      gxv_just_justData_validate( table + horizOffset, limit, gxvalid );
+      gxv_odtect_add_range( table + horizOffset, gxvalid->subtable_length,
                             "horizJustData", odtect );
     }
 
     if ( 0 < vertOffset )
     {
-      gxv_just_justData_validate( table + vertOffset, limit, valid );
-      gxv_odtect_add_range( table + vertOffset, valid->subtable_length,
+      gxv_just_justData_validate( table + vertOffset, limit, gxvalid );
+      gxv_odtect_add_range( table + vertOffset, gxvalid->subtable_length,
                             "vertJustData", odtect );
     }
 
-    gxv_odtect_validate( odtect, valid );
+    gxv_odtect_validate( odtect, gxvalid );
 
     FT_TRACE4(( "\n" ));
   }
diff --git a/src/gxvalid/gxvkern.c b/src/gxvalid/gxvkern.c
index 557c5f1..787e3db 100644
--- a/src/gxvalid/gxvkern.c
+++ b/src/gxvalid/gxvkern.c
@@ -79,20 +79,20 @@
 
 #define GXV_KERN_DATA( field )  GXV_TABLE_DATA( kern, field )
 
-#define KERN_IS_CLASSIC( valid )                               \
+#define KERN_IS_CLASSIC( gxvalid )                               \
           ( KERN_VERSION_CLASSIC == GXV_KERN_DATA( version ) )
-#define KERN_IS_NEW( valid )                                   \
+#define KERN_IS_NEW( gxvalid )                                   \
           ( KERN_VERSION_NEW     == GXV_KERN_DATA( version ) )
 
-#define KERN_DIALECT( valid )              \
+#define KERN_DIALECT( gxvalid )              \
           GXV_KERN_DATA( dialect_request )
-#define KERN_ALLOWS_MS( valid )                       \
-          ( KERN_DIALECT( valid ) & KERN_DIALECT_MS )
-#define KERN_ALLOWS_APPLE( valid )                       \
-          ( KERN_DIALECT( valid ) & KERN_DIALECT_APPLE )
+#define KERN_ALLOWS_MS( gxvalid )                       \
+          ( KERN_DIALECT( gxvalid ) & KERN_DIALECT_MS )
+#define KERN_ALLOWS_APPLE( gxvalid )                       \
+          ( KERN_DIALECT( gxvalid ) & KERN_DIALECT_APPLE )
 
-#define GXV_KERN_HEADER_SIZE           ( KERN_IS_NEW( valid ) ? 8 : 4 )
-#define GXV_KERN_SUBTABLE_HEADER_SIZE  ( KERN_IS_NEW( valid ) ? 8 : 6 )
+#define GXV_KERN_HEADER_SIZE           ( KERN_IS_NEW( gxvalid ) ? 8 : 4 )
+#define GXV_KERN_SUBTABLE_HEADER_SIZE  ( KERN_IS_NEW( gxvalid ) ? 8 : 6 )
 
 
   /*************************************************************************/
@@ -110,7 +110,7 @@
   gxv_kern_subtable_fmt0_pairs_validate( FT_Bytes       table,
                                          FT_Bytes       limit,
                                          FT_UShort      nPairs,
-                                         GXV_Validator  valid )
+                                         GXV_Validator  gxvalid )
   {
     FT_Bytes   p = table;
     FT_UShort  i;
@@ -134,11 +134,11 @@
 
       /* left */
       gid_left  = FT_NEXT_USHORT( p );
-      gxv_glyphid_validate( gid_left, valid );
+      gxv_glyphid_validate( gid_left, gxvalid );
 
       /* right */
       gid_right = FT_NEXT_USHORT( p );
-      gxv_glyphid_validate( gid_right, valid );
+      gxv_glyphid_validate( gid_right, gxvalid );
 
       /* Pairs of left and right GIDs must be unique and sorted. */
       GXV_TRACE(( "left gid = %u, right gid = %u\n", gid_left, gid_right ));
@@ -171,7 +171,7 @@
   static void
   gxv_kern_subtable_fmt0_validate( FT_Bytes       table,
                                    FT_Bytes       limit,
-                                   GXV_Validator  valid )
+                                   GXV_Validator  gxvalid )
   {
     FT_Bytes   p = table + GXV_KERN_SUBTABLE_HEADER_SIZE;
 
@@ -186,10 +186,10 @@
 
     /* nPairs, searchRange, entrySelector, rangeShift */
     GXV_LIMIT_CHECK( 2 + 2 + 2 + 2 );
-    gxv_BinSrchHeader_validate( p, limit, &unitSize, &nPairs, valid );
+    gxv_BinSrchHeader_validate( p, limit, &unitSize, &nPairs, gxvalid );
     p += 2 + 2 + 2 + 2;
 
-    gxv_kern_subtable_fmt0_pairs_validate( p, limit, nPairs, valid );
+    gxv_kern_subtable_fmt0_pairs_validate( p, limit, nPairs, gxvalid );
 
     GXV_EXIT;
   }
@@ -209,11 +209,11 @@
   static void
   gxv_kern_subtable_fmt1_valueTable_load( FT_Bytes       table,
                                           FT_Bytes       limit,
-                                          GXV_Validator  valid )
+                                          GXV_Validator  gxvalid )
   {
     FT_Bytes                       p = table;
     GXV_kern_fmt1_StateOptRecData  optdata =
-      (GXV_kern_fmt1_StateOptRecData)valid->statetable.optdata;
+      (GXV_kern_fmt1_StateOptRecData)gxvalid->statetable.optdata;
 
 
     GXV_LIMIT_CHECK( 2 );
@@ -232,14 +232,14 @@
                                          FT_UShort*     classTable_length_p,
                                          FT_UShort*     stateArray_length_p,
                                          FT_UShort*     entryTable_length_p,
-                                         GXV_Validator  valid )
+                                         GXV_Validator  gxvalid )
   {
     FT_UShort  o[4];
     FT_UShort  *l[4];
     FT_UShort  buff[5];
 
     GXV_kern_fmt1_StateOptRecData  optdata =
-      (GXV_kern_fmt1_StateOptRecData)valid->statetable.optdata;
+      (GXV_kern_fmt1_StateOptRecData)gxvalid->statetable.optdata;
 
 
     o[0] = classTable;
@@ -251,7 +251,7 @@
     l[2] = entryTable_length_p;
     l[3] = &(optdata->valueTable_length);
 
-    gxv_set_length_by_ushort_offset( o, l, buff, 4, table_size, valid );
+    gxv_set_length_by_ushort_offset( o, l, buff, 4, table_size, gxvalid );
   }
 
 
@@ -265,7 +265,7 @@
     GXV_StateTable_GlyphOffsetCPtr  glyphOffset_p,
     FT_Bytes                        table,
     FT_Bytes                        limit,
-    GXV_Validator                   valid )
+    GXV_Validator                   gxvalid )
   {
 #ifdef GXV_LOAD_UNUSED_VARS
     FT_UShort  push;
@@ -289,7 +289,7 @@
 
     {
       GXV_kern_fmt1_StateOptRecData  vt_rec =
-        (GXV_kern_fmt1_StateOptRecData)valid->statetable.optdata;
+        (GXV_kern_fmt1_StateOptRecData)gxvalid->statetable.optdata;
       FT_Bytes  p;
 
 
@@ -311,7 +311,7 @@
   static void
   gxv_kern_subtable_fmt1_validate( FT_Bytes       table,
                                    FT_Bytes       limit,
-                                   GXV_Validator  valid )
+                                   GXV_Validator  gxvalid )
   {
     FT_Bytes                   p = table;
     GXV_kern_fmt1_StateOptRec  vt_rec;
@@ -319,18 +319,18 @@
 
     GXV_NAME_ENTER( "kern subtable format 1" );
 
-    valid->statetable.optdata =
+    gxvalid->statetable.optdata =
       &vt_rec;
-    valid->statetable.optdata_load_func =
+    gxvalid->statetable.optdata_load_func =
       gxv_kern_subtable_fmt1_valueTable_load;
-    valid->statetable.subtable_setup_func =
+    gxvalid->statetable.subtable_setup_func =
       gxv_kern_subtable_fmt1_subtable_setup;
-    valid->statetable.entry_glyphoffset_fmt =
+    gxvalid->statetable.entry_glyphoffset_fmt =
       GXV_GLYPHOFFSET_NONE;
-    valid->statetable.entry_validate_func =
+    gxvalid->statetable.entry_validate_func =
       gxv_kern_subtable_fmt1_entry_validate;
 
-    gxv_StateTable_validate( p, limit, valid );
+    gxv_StateTable_validate( p, limit, gxvalid );
 
     GXV_EXIT;
   }
@@ -373,7 +373,7 @@
   gxv_kern_subtable_fmt2_clstbl_validate( FT_Bytes            table,
                                           FT_Bytes            limit,
                                           GXV_kern_ClassSpec  spec,
-                                          GXV_Validator       valid )
+                                          GXV_Validator       gxvalid )
   {
     const FT_String*  tag    = GXV_KERN_FMT2_DATA( class_tag[spec] );
     GXV_odtect_Range  odtect = GXV_KERN_FMT2_DATA( odtect );
@@ -391,13 +391,13 @@
     GXV_TRACE(( " %s firstGlyph=%d, nGlyphs=%d\n",
                 tag, firstGlyph, nGlyphs ));
 
-    gxv_glyphid_validate( firstGlyph, valid );
-    gxv_glyphid_validate( (FT_UShort)( firstGlyph + nGlyphs - 1 ), valid );
+    gxv_glyphid_validate( firstGlyph, gxvalid );
+    gxv_glyphid_validate( (FT_UShort)( firstGlyph + nGlyphs - 1 ), gxvalid );
 
     gxv_array_getlimits_ushort( p, p + ( 2 * nGlyphs ),
                                 &( GXV_KERN_FMT2_DATA( offset_min[spec] ) ),
                                 &( GXV_KERN_FMT2_DATA( offset_max[spec] ) ),
-                                valid );
+                                gxvalid );
 
     gxv_odtect_add_range( table, 2 * nGlyphs, tag, odtect );
 
@@ -408,7 +408,7 @@
   static void
   gxv_kern_subtable_fmt2_validate( FT_Bytes       table,
                                    FT_Bytes       limit,
-                                   GXV_Validator  valid )
+                                   GXV_Validator  gxvalid )
   {
     GXV_ODTECT( 3, odtect );
     GXV_kern_subtable_fmt2_DataRec  fmt2_rec =
@@ -439,10 +439,10 @@
     GXV_LIMIT_CHECK( GXV_KERN_FMT2_DATA( array ) );
 
     gxv_kern_subtable_fmt2_clstbl_validate( table + leftOffsetTable, limit,
-                                            GXV_KERN_CLS_L, valid );
+                                            GXV_KERN_CLS_L, gxvalid );
 
     gxv_kern_subtable_fmt2_clstbl_validate( table + rightOffsetTable, limit,
-                                            GXV_KERN_CLS_R, valid );
+                                            GXV_KERN_CLS_R, gxvalid );
 
     if ( GXV_KERN_FMT2_DATA( offset_min[GXV_KERN_CLS_L] ) +
            GXV_KERN_FMT2_DATA( offset_min[GXV_KERN_CLS_R] )
@@ -455,7 +455,7 @@
                             - GXV_KERN_FMT2_DATA( array ),
                           "array", odtect );
 
-    gxv_odtect_validate( odtect, valid );
+    gxv_odtect_validate( odtect, gxvalid );
 
     GXV_EXIT;
   }
@@ -466,7 +466,7 @@
   static void
   gxv_kern_subtable_fmt3_validate( FT_Bytes       table,
                                    FT_Bytes       limit,
-                                   GXV_Validator  valid )
+                                   GXV_Validator  gxvalid )
   {
     FT_Bytes   p = table + GXV_KERN_SUBTABLE_HEADER_SIZE;
     FT_UShort  glyphCount;
@@ -485,10 +485,10 @@
     rightClassCount = FT_NEXT_BYTE( p );
     flags           = FT_NEXT_BYTE( p );
 
-    if ( valid->face->num_glyphs != glyphCount )
+    if ( gxvalid->face->num_glyphs != glyphCount )
     {
       GXV_TRACE(( "maxGID=%d, but glyphCount=%d\n",
-                  valid->face->num_glyphs, glyphCount ));
+                  gxvalid->face->num_glyphs, glyphCount ));
       GXV_SET_ERR_IF_PARANOID( FT_INVALID_GLYPH_ID );
     }
 
@@ -509,8 +509,8 @@
 
 
       GXV_LIMIT_CHECK( glyphCount );
-      gxv_array_getlimits_byte( p, p + glyphCount, &min, &max, valid );
-      p += valid->subtable_length;
+      gxv_array_getlimits_byte( p, p + glyphCount, &min, &max, gxvalid );
+      p += gxvalid->subtable_length;
 
       if ( leftClassCount < max )
         FT_INVALID_DATA;
@@ -524,8 +524,8 @@
 
 
       GXV_LIMIT_CHECK( glyphCount );
-      gxv_array_getlimits_byte( p, p + glyphCount, &min, &max, valid );
-      p += valid->subtable_length;
+      gxv_array_getlimits_byte( p, p + glyphCount, &min, &max, gxvalid );
+      p += gxvalid->subtable_length;
 
       if ( rightClassCount < max )
         FT_INVALID_DATA;
@@ -549,7 +549,7 @@
       }
     }
 
-    valid->subtable_length = p - table;
+    gxvalid->subtable_length = p - table;
 
     GXV_EXIT;
   }
@@ -558,7 +558,7 @@
   static FT_Bool
   gxv_kern_coverage_new_apple_validate( FT_UShort      coverage,
                                         FT_UShort*     format,
-                                        GXV_Validator  valid )
+                                        GXV_Validator  gxvalid )
   {
     /* new Apple-dialect */
 #ifdef GXV_LOAD_TRACE_VARS
@@ -567,7 +567,7 @@
     FT_Bool  kernVariation;
 #endif
 
-    FT_UNUSED( valid );
+    FT_UNUSED( gxvalid );
 
 
     /* reserved bits = 0 */
@@ -595,7 +595,7 @@
   static FT_Bool
   gxv_kern_coverage_classic_apple_validate( FT_UShort      coverage,
                                             FT_UShort*     format,
-                                            GXV_Validator  valid )
+                                            GXV_Validator  gxvalid )
   {
     /* classic Apple-dialect */
 #ifdef GXV_LOAD_TRACE_VARS
@@ -605,7 +605,7 @@
 
 
     /* check expected flags, but don't check if MS-dialect is impossible */
-    if ( !( coverage & 0xFD00 ) && KERN_ALLOWS_MS( valid ) )
+    if ( !( coverage & 0xFD00 ) && KERN_ALLOWS_MS( gxvalid ) )
       return FALSE;
 
     /* reserved bits = 0 */
@@ -636,7 +636,7 @@
   static FT_Bool
   gxv_kern_coverage_classic_microsoft_validate( FT_UShort      coverage,
                                                 FT_UShort*     format,
-                                                GXV_Validator  valid )
+                                                GXV_Validator  gxvalid )
   {
     /* classic Microsoft-dialect */
 #ifdef GXV_LOAD_TRACE_VARS
@@ -646,7 +646,7 @@
     FT_Bool  override;
 #endif
 
-    FT_UNUSED( valid );
+    FT_UNUSED( gxvalid );
 
 
     /* reserved bits = 0 */
@@ -686,7 +686,7 @@
   static GXV_kern_Dialect
   gxv_kern_coverage_validate( FT_UShort      coverage,
                               FT_UShort*     format,
-                              GXV_Validator  valid )
+                              GXV_Validator  gxvalid )
   {
     GXV_kern_Dialect  result = KERN_DIALECT_UNKNOWN;
 
@@ -695,33 +695,33 @@
 
     GXV_TRACE(( "interprete coverage 0x%04x by Apple style\n", coverage ));
 
-    if ( KERN_IS_NEW( valid ) )
+    if ( KERN_IS_NEW( gxvalid ) )
     {
       if ( gxv_kern_coverage_new_apple_validate( coverage,
                                                  format,
-                                                 valid ) )
+                                                 gxvalid ) )
       {
         result = KERN_DIALECT_APPLE;
         goto Exit;
       }
     }
 
-    if ( KERN_IS_CLASSIC( valid ) && KERN_ALLOWS_APPLE( valid ) )
+    if ( KERN_IS_CLASSIC( gxvalid ) && KERN_ALLOWS_APPLE( gxvalid ) )
     {
       if ( gxv_kern_coverage_classic_apple_validate( coverage,
                                                      format,
-                                                     valid ) )
+                                                     gxvalid ) )
       {
         result = KERN_DIALECT_APPLE;
         goto Exit;
       }
     }
 
-    if ( KERN_IS_CLASSIC( valid ) && KERN_ALLOWS_MS( valid ) )
+    if ( KERN_IS_CLASSIC( gxvalid ) && KERN_ALLOWS_MS( gxvalid ) )
     {
       if ( gxv_kern_coverage_classic_microsoft_validate( coverage,
                                                          format,
-                                                         valid ) )
+                                                         gxvalid ) )
       {
         result = KERN_DIALECT_MS;
         goto Exit;
@@ -739,7 +739,7 @@
   static void
   gxv_kern_subtable_validate( FT_Bytes       table,
                               FT_Bytes       limit,
-                              GXV_Validator  valid )
+                              GXV_Validator  gxvalid )
   {
     FT_Bytes   p = table;
 #ifdef GXV_LOAD_TRACE_VARS
@@ -761,7 +761,7 @@
     u16[1]   = FT_NEXT_USHORT( p ); /* Apple: length_lo MS: length */
     coverage = FT_NEXT_USHORT( p );
 
-    switch ( gxv_kern_coverage_validate( coverage, &format, valid ) )
+    switch ( gxv_kern_coverage_validate( coverage, &format, gxvalid ) )
     {
     case KERN_DIALECT_MS:
 #ifdef GXV_LOAD_TRACE_VARS
@@ -785,7 +785,7 @@
 #endif
       GXV_TRACE(( "Subtable length = %d\n", length ));
 
-      if ( KERN_IS_NEW( valid ) )
+      if ( KERN_IS_NEW( gxvalid ) )
       {
         GXV_LIMIT_CHECK( 2 );
 #ifdef GXV_LOAD_TRACE_VARS
@@ -806,18 +806,18 @@
 
     /* formats 1, 2, 3 require the position of the start of this subtable */
     if ( format == 0 )
-      gxv_kern_subtable_fmt0_validate( table, table + length, valid );
+      gxv_kern_subtable_fmt0_validate( table, table + length, gxvalid );
     else if ( format == 1 )
-      gxv_kern_subtable_fmt1_validate( table, table + length, valid );
+      gxv_kern_subtable_fmt1_validate( table, table + length, gxvalid );
     else if ( format == 2 )
-      gxv_kern_subtable_fmt2_validate( table, table + length, valid );
+      gxv_kern_subtable_fmt2_validate( table, table + length, gxvalid );
     else if ( format == 3 )
-      gxv_kern_subtable_fmt3_validate( table, table + length, valid );
+      gxv_kern_subtable_fmt3_validate( table, table + length, gxvalid );
     else
       FT_INVALID_DATA;
 
   Exit:
-    valid->subtable_length = length;
+    gxvalid->subtable_length = length;
     GXV_EXIT;
   }
 
@@ -837,8 +837,8 @@
                              GXV_kern_Dialect  dialect_request,
                              FT_Validator      ftvalid )
   {
-    GXV_ValidatorRec   validrec;
-    GXV_Validator      valid = &validrec;
+    GXV_ValidatorRec   gxvalidrec;
+    GXV_Validator      gxvalid = &gxvalidrec;
 
     GXV_kern_DataRec   kernrec;
     GXV_kern_Data      kern = &kernrec;
@@ -850,13 +850,13 @@
     FT_UInt            i;
 
 
-    valid->root       = ftvalid;
-    valid->table_data = kern;
-    valid->face       = face;
+    gxvalid->root       = ftvalid;
+    gxvalid->table_data = kern;
+    gxvalid->face       = face;
 
     FT_TRACE3(( "validating `kern' table\n" ));
     GXV_INIT;
-    KERN_DIALECT( valid ) = dialect_request;
+    KERN_DIALECT( gxvalid ) = dialect_request;
 
     GXV_LIMIT_CHECK( 2 );
     GXV_KERN_DATA( version ) = (GXV_kern_Version)FT_NEXT_USHORT( p );
@@ -865,12 +865,12 @@
 
     if ( 0x0001 < GXV_KERN_DATA( version ) )
       FT_INVALID_FORMAT;
-    else if ( KERN_IS_CLASSIC( valid ) )
+    else if ( KERN_IS_CLASSIC( gxvalid ) )
     {
       GXV_LIMIT_CHECK( 2 );
       nTables = FT_NEXT_USHORT( p );
     }
-    else if ( KERN_IS_NEW( valid ) )
+    else if ( KERN_IS_NEW( gxvalid ) )
     {
       if ( classic_only )
         FT_INVALID_FORMAT;
@@ -886,8 +886,8 @@
     {
       GXV_TRACE(( "validating subtable %d/%d\n", i, nTables ));
       /* p should be 32bit-aligned? */
-      gxv_kern_subtable_validate( p, 0, valid );
-      p += valid->subtable_length;
+      gxv_kern_subtable_validate( p, 0, gxvalid );
+      p += gxvalid->subtable_length;
     }
 
     FT_TRACE4(( "\n" ));
diff --git a/src/gxvalid/gxvlcar.c b/src/gxvalid/gxvlcar.c
index f14fa5b..48308b0 100644
--- a/src/gxvalid/gxvlcar.c
+++ b/src/gxvalid/gxvlcar.c
@@ -67,14 +67,14 @@
   static void
   gxv_lcar_partial_validate( FT_UShort      partial,
                              FT_UShort      glyph,
-                             GXV_Validator  valid )
+                             GXV_Validator  gxvalid )
   {
     GXV_NAME_ENTER( "partial" );
 
     if ( GXV_LCAR_DATA( format ) != 1 )
       goto Exit;
 
-    gxv_ctlPoint_validate( glyph, partial, valid );
+    gxv_ctlPoint_validate( glyph, partial, gxvalid );
 
   Exit:
     GXV_EXIT;
@@ -84,10 +84,10 @@
   static void
   gxv_lcar_LookupValue_validate( FT_UShort            glyph,
                                  GXV_LookupValueCPtr  value_p,
-                                 GXV_Validator        valid )
+                                 GXV_Validator        gxvalid )
   {
-    FT_Bytes   p     = valid->root->base + value_p->u;
-    FT_Bytes   limit = valid->root->limit;
+    FT_Bytes   p     = gxvalid->root->base + value_p->u;
+    FT_Bytes   limit = gxvalid->root->limit;
     FT_UShort  count;
     FT_Short   partial;
     FT_UShort  i;
@@ -102,7 +102,7 @@
     for ( i = 0; i < count; i++ )
     {
       partial = FT_NEXT_SHORT( p );
-      gxv_lcar_partial_validate( partial, glyph, valid );
+      gxv_lcar_partial_validate( partial, glyph, gxvalid );
     }
 
     GXV_EXIT;
@@ -148,7 +148,7 @@
   gxv_lcar_LookupFmt4_transit( FT_UShort            relative_gindex,
                                GXV_LookupValueCPtr  base_value_p,
                                FT_Bytes             lookuptbl_limit,
-                               GXV_Validator        valid )
+                               GXV_Validator        gxvalid )
   {
     FT_Bytes             p;
     FT_Bytes             limit;
@@ -160,8 +160,8 @@
     /* XXX: check range? */
     offset = (FT_UShort)( base_value_p->u +
                           relative_gindex * sizeof ( FT_UShort ) );
-    p      = valid->root->base + offset;
-    limit  = valid->root->limit;
+    p      = gxvalid->root->base + offset;
+    limit  = gxvalid->root->limit;
 
     GXV_LIMIT_CHECK ( 2 );
     value.u = FT_NEXT_USHORT( p );
@@ -185,8 +185,8 @@
   {
     FT_Bytes          p     = table;
     FT_Bytes          limit = 0;
-    GXV_ValidatorRec  validrec;
-    GXV_Validator     valid = &validrec;
+    GXV_ValidatorRec  gxvalidrec;
+    GXV_Validator     gxvalid = &gxvalidrec;
 
     GXV_lcar_DataRec  lcarrec;
     GXV_lcar_Data     lcar = &lcarrec;
@@ -194,9 +194,9 @@
     FT_Fixed          version;
 
 
-    valid->root       = ftvalid;
-    valid->table_data = lcar;
-    valid->face       = face;
+    gxvalid->root       = ftvalid;
+    gxvalid->table_data = lcar;
+    gxvalid->face       = face;
 
     FT_TRACE3(( "validating `lcar' table\n" ));
     GXV_INIT;
@@ -211,10 +211,10 @@
     if ( GXV_LCAR_DATA( format ) > 1 )
       FT_INVALID_FORMAT;
 
-    valid->lookupval_sign   = GXV_LOOKUPVALUE_UNSIGNED;
-    valid->lookupval_func   = gxv_lcar_LookupValue_validate;
-    valid->lookupfmt4_trans = gxv_lcar_LookupFmt4_transit;
-    gxv_LookupTable_validate( p, limit, valid );
+    gxvalid->lookupval_sign   = GXV_LOOKUPVALUE_UNSIGNED;
+    gxvalid->lookupval_func   = gxv_lcar_LookupValue_validate;
+    gxvalid->lookupfmt4_trans = gxv_lcar_LookupFmt4_transit;
+    gxv_LookupTable_validate( p, limit, gxvalid );
 
     FT_TRACE4(( "\n" ));
   }
diff --git a/src/gxvalid/gxvmort.c b/src/gxvalid/gxvmort.c
index c4d49b3..55ff5a8 100644
--- a/src/gxvalid/gxvmort.c
+++ b/src/gxvalid/gxvmort.c
@@ -40,7 +40,7 @@
 
   static void
   gxv_mort_feature_validate( GXV_mort_feature  f,
-                             GXV_Validator     valid )
+                             GXV_Validator     gxvalid )
   {
     if ( f->featureType >= gxv_feat_registry_length )
     {
@@ -89,7 +89,7 @@
   gxv_mort_featurearray_validate( FT_Bytes       table,
                                   FT_Bytes       limit,
                                   FT_ULong       nFeatureFlags,
-                                  GXV_Validator  valid )
+                                  GXV_Validator  gxvalid )
   {
     FT_Bytes  p = table;
     FT_ULong  i;
@@ -106,22 +106,22 @@
       f.enableFlags    = FT_NEXT_ULONG( p );
       f.disableFlags   = FT_NEXT_ULONG( p );
 
-      gxv_mort_feature_validate( &f, valid );
+      gxv_mort_feature_validate( &f, gxvalid );
     }
 
     if ( !IS_GXV_MORT_FEATURE_OFF( f ) )
       FT_INVALID_DATA;
 
-    valid->subtable_length = p - table;
+    gxvalid->subtable_length = p - table;
     GXV_EXIT;
   }
 
 
   FT_LOCAL_DEF( void )
   gxv_mort_coverage_validate( FT_UShort      coverage,
-                              GXV_Validator  valid )
+                              GXV_Validator  gxvalid )
   {
-    FT_UNUSED( valid );
+    FT_UNUSED( gxvalid );
 
 #ifdef FT_DEBUG_LEVEL_TRACE
     if ( coverage & 0x8000U )
@@ -150,7 +150,7 @@
   gxv_mort_subtables_validate( FT_Bytes       table,
                                FT_Bytes       limit,
                                FT_UShort      nSubtables,
-                               GXV_Validator  valid )
+                               GXV_Validator  gxvalid )
   {
     FT_Bytes  p = table;
 
@@ -198,7 +198,7 @@
       rest = length - ( 2 + 2 + 4 );
 
       GXV_LIMIT_CHECK( rest );
-      gxv_mort_coverage_validate( coverage, valid );
+      gxv_mort_coverage_validate( coverage, gxvalid );
 
       if ( type > 5 )
         FT_INVALID_FORMAT;
@@ -207,13 +207,13 @@
       if ( func == NULL )
         GXV_TRACE(( "morx type %d is reserved\n", type ));
 
-      func( p, p + rest, valid );
+      func( p, p + rest, gxvalid );
 
       p += rest;
       /* TODO: validate subFeatureFlags */
     }
 
-    valid->subtable_length = p - table;
+    gxvalid->subtable_length = p - table;
 
     GXV_EXIT;
   }
@@ -222,7 +222,7 @@
   static void
   gxv_mort_chain_validate( FT_Bytes       table,
                            FT_Bytes       limit,
-                           GXV_Validator  valid )
+                           GXV_Validator  gxvalid )
   {
     FT_Bytes   p = table;
 #ifdef GXV_LOAD_UNUSED_VARS
@@ -246,10 +246,10 @@
     nSubtables    = FT_NEXT_USHORT( p );
 
     gxv_mort_featurearray_validate( p, table + chainLength,
-                                    nFeatureFlags, valid );
-    p += valid->subtable_length;
-    gxv_mort_subtables_validate( p, table + chainLength, nSubtables, valid );
-    valid->subtable_length = chainLength;
+                                    nFeatureFlags, gxvalid );
+    p += gxvalid->subtable_length;
+    gxv_mort_subtables_validate( p, table + chainLength, nSubtables, gxvalid );
+    gxvalid->subtable_length = chainLength;
 
     /* TODO: validate defaultFlags */
     GXV_EXIT;
@@ -261,8 +261,8 @@
                      FT_Face       face,
                      FT_Validator  ftvalid )
   {
-    GXV_ValidatorRec  validrec;
-    GXV_Validator     valid = &validrec;
+    GXV_ValidatorRec  gxvalidrec;
+    GXV_Validator     gxvalid = &gxvalidrec;
     FT_Bytes          p     = table;
     FT_Bytes          limit = 0;
     FT_ULong          version;
@@ -270,9 +270,9 @@
     FT_ULong          i;
 
 
-    valid->root = ftvalid;
-    valid->face = face;
-    limit       = valid->root->limit;
+    gxvalid->root = ftvalid;
+    gxvalid->face = face;
+    limit         = gxvalid->root->limit;
 
     FT_TRACE3(( "validating `mort' table\n" ));
     GXV_INIT;
@@ -288,8 +288,8 @@
     {
       GXV_TRACE(( "validating chain %d/%d\n", i + 1, nChains ));
       GXV_32BIT_ALIGNMENT_VALIDATE( p - table );
-      gxv_mort_chain_validate( p, limit, valid );
-      p += valid->subtable_length;
+      gxv_mort_chain_validate( p, limit, gxvalid );
+      p += gxvalid->subtable_length;
     }
 
     FT_TRACE4(( "\n" ));
diff --git a/src/gxvalid/gxvmort.h b/src/gxvalid/gxvmort.h
index 1e5a1f5..8e62e52 100644
--- a/src/gxvalid/gxvmort.h
+++ b/src/gxvalid/gxvmort.h
@@ -55,36 +55,36 @@
   gxv_mort_featurearray_validate( FT_Bytes       table,
                                   FT_Bytes       limit,
                                   FT_ULong       nFeatureFlags,
-                                  GXV_Validator  valid );
+                                  GXV_Validator  gxvalid );
 
   FT_LOCAL( void )
   gxv_mort_coverage_validate( FT_UShort      coverage,
-                              GXV_Validator  valid );
+                              GXV_Validator  gxvalid );
 
   FT_LOCAL( void )
   gxv_mort_subtable_type0_validate( FT_Bytes       table,
                                     FT_Bytes       limit,
-                                    GXV_Validator  valid );
+                                    GXV_Validator  gxvalid );
 
   FT_LOCAL( void )
   gxv_mort_subtable_type1_validate( FT_Bytes       table,
                                     FT_Bytes       limit,
-                                    GXV_Validator  valid );
+                                    GXV_Validator  gxvalid );
 
   FT_LOCAL( void )
   gxv_mort_subtable_type2_validate( FT_Bytes       table,
                                     FT_Bytes       limit,
-                                    GXV_Validator  valid );
+                                    GXV_Validator  gxvalid );
 
   FT_LOCAL( void )
   gxv_mort_subtable_type4_validate( FT_Bytes       table,
                                     FT_Bytes       limit,
-                                    GXV_Validator  valid );
+                                    GXV_Validator  gxvalid );
 
   FT_LOCAL( void )
   gxv_mort_subtable_type5_validate( FT_Bytes       table,
                                     FT_Bytes       limit,
-                                    GXV_Validator  valid );
+                                    GXV_Validator  gxvalid );
 
 
 #endif /* __GXVMORT_H__ */
diff --git a/src/gxvalid/gxvmort0.c b/src/gxvalid/gxvmort0.c
index b136ced..f19016e 100644
--- a/src/gxvalid/gxvmort0.c
+++ b/src/gxvalid/gxvmort0.c
@@ -67,7 +67,7 @@
     GXV_StateTable_GlyphOffsetCPtr  glyphOffset_p,
     FT_Bytes                        table,
     FT_Bytes                        limit,
-    GXV_Validator                   valid )
+    GXV_Validator                   gxvalid )
   {
     FT_UShort  markFirst;
     FT_UShort  dontAdvance;
@@ -125,7 +125,7 @@
   FT_LOCAL_DEF( void )
   gxv_mort_subtable_type0_validate( FT_Bytes       table,
                                     FT_Bytes       limit,
-                                    GXV_Validator  valid )
+                                    GXV_Validator  gxvalid )
   {
     FT_Bytes  p = table;
 
@@ -135,14 +135,14 @@
 
     GXV_LIMIT_CHECK( GXV_STATETABLE_HEADER_SIZE );
 
-    valid->statetable.optdata               = NULL;
-    valid->statetable.optdata_load_func     = NULL;
-    valid->statetable.subtable_setup_func   = NULL;
-    valid->statetable.entry_glyphoffset_fmt = GXV_GLYPHOFFSET_NONE;
-    valid->statetable.entry_validate_func =
+    gxvalid->statetable.optdata               = NULL;
+    gxvalid->statetable.optdata_load_func     = NULL;
+    gxvalid->statetable.subtable_setup_func   = NULL;
+    gxvalid->statetable.entry_glyphoffset_fmt = GXV_GLYPHOFFSET_NONE;
+    gxvalid->statetable.entry_validate_func =
       gxv_mort_subtable_type0_entry_validate;
 
-    gxv_StateTable_validate( p, limit, valid );
+    gxv_StateTable_validate( p, limit, gxvalid );
 
     GXV_EXIT;
   }
diff --git a/src/gxvalid/gxvmort1.c b/src/gxvalid/gxvmort1.c
index 1c17a5d..0189504 100644
--- a/src/gxvalid/gxvmort1.c
+++ b/src/gxvalid/gxvmort1.c
@@ -53,12 +53,12 @@
   static void
   gxv_mort_subtable_type1_substitutionTable_load( FT_Bytes       table,
                                                   FT_Bytes       limit,
-                                                  GXV_Validator  valid )
+                                                  GXV_Validator  gxvalid )
   {
     FT_Bytes  p = table;
 
     GXV_mort_subtable_type1_StateOptRecData  optdata =
-      (GXV_mort_subtable_type1_StateOptRecData)valid->statetable.optdata;
+      (GXV_mort_subtable_type1_StateOptRecData)gxvalid->statetable.optdata;
 
 
     GXV_LIMIT_CHECK( 2 );
@@ -74,14 +74,14 @@
                                           FT_UShort*     classTable_length_p,
                                           FT_UShort*     stateArray_length_p,
                                           FT_UShort*     entryTable_length_p,
-                                          GXV_Validator  valid )
+                                          GXV_Validator  gxvalid )
   {
     FT_UShort  o[4];
     FT_UShort  *l[4];
     FT_UShort  buff[5];
 
     GXV_mort_subtable_type1_StateOptRecData  optdata =
-      (GXV_mort_subtable_type1_StateOptRecData)valid->statetable.optdata;
+      (GXV_mort_subtable_type1_StateOptRecData)gxvalid->statetable.optdata;
 
 
     o[0] = classTable;
@@ -93,7 +93,7 @@
     l[2] = entryTable_length_p;
     l[3] = &( optdata->substitutionTable_length );
 
-    gxv_set_length_by_ushort_offset( o, l, buff, 4, table_size, valid );
+    gxv_set_length_by_ushort_offset( o, l, buff, 4, table_size, gxvalid );
   }
 
 
@@ -102,7 +102,7 @@
     FT_Short          wordOffset,
     const FT_String*  tag,
     FT_Byte           state,
-    GXV_Validator     valid )
+    GXV_Validator     gxvalid )
   {
     FT_UShort  substTable;
     FT_UShort  substTable_limit;
@@ -113,16 +113,16 @@
 
     substTable =
       ((GXV_mort_subtable_type1_StateOptRec *)
-       (valid->statetable.optdata))->substitutionTable;
+       (gxvalid->statetable.optdata))->substitutionTable;
     substTable_limit =
       (FT_UShort)( substTable +
                    ((GXV_mort_subtable_type1_StateOptRec *)
-                    (valid->statetable.optdata))->substitutionTable_length );
+                    (gxvalid->statetable.optdata))->substitutionTable_length );
 
-    valid->min_gid = (FT_UShort)( ( substTable       - wordOffset * 2 ) / 2 );
-    valid->max_gid = (FT_UShort)( ( substTable_limit - wordOffset * 2 ) / 2 );
-    valid->max_gid = (FT_UShort)( FT_MAX( valid->max_gid,
-                                          valid->face->num_glyphs ) );
+    gxvalid->min_gid = (FT_UShort)( ( substTable       - wordOffset * 2 ) / 2 );
+    gxvalid->max_gid = (FT_UShort)( ( substTable_limit - wordOffset * 2 ) / 2 );
+    gxvalid->max_gid = (FT_UShort)( FT_MAX( gxvalid->max_gid,
+                                            gxvalid->face->num_glyphs ) );
 
     /* XXX: check range? */
 
@@ -137,7 +137,7 @@
     GXV_StateTable_GlyphOffsetCPtr  glyphOffset_p,
     FT_Bytes                        table,
     FT_Bytes                        limit,
-    GXV_Validator                   valid )
+    GXV_Validator                   gxvalid )
   {
 #ifdef GXV_LOAD_UNUSED_VARS
     FT_UShort  setMark;
@@ -169,24 +169,24 @@
     gxv_mort_subtable_type1_offset_to_subst_validate( markOffset,
                                                       "markOffset",
                                                       state,
-                                                      valid );
+                                                      gxvalid );
 
     gxv_mort_subtable_type1_offset_to_subst_validate( currentOffset,
                                                       "currentOffset",
                                                       state,
-                                                      valid );
+                                                      gxvalid );
   }
 
 
   static void
   gxv_mort_subtable_type1_substTable_validate( FT_Bytes       table,
                                                FT_Bytes       limit,
-                                               GXV_Validator  valid )
+                                               GXV_Validator  gxvalid )
   {
     FT_Bytes   p = table;
     FT_UShort  num_gids = (FT_UShort)(
                  ((GXV_mort_subtable_type1_StateOptRec *)
-                  (valid->statetable.optdata))->substitutionTable_length / 2 );
+                  (gxvalid->statetable.optdata))->substitutionTable_length / 2 );
     FT_UShort  i;
 
 
@@ -202,11 +202,11 @@
       if ( dst_gid >= 0xFFFFU )
         continue;
 
-      if ( dst_gid < valid->min_gid || valid->max_gid < dst_gid )
+      if ( dst_gid < gxvalid->min_gid || gxvalid->max_gid < dst_gid )
       {
         GXV_TRACE(( "substTable include a strange gid[%d]=%d >"
                     " out of define range (%d..%d)\n",
-                    i, dst_gid, valid->min_gid, valid->max_gid ));
+                    i, dst_gid, gxvalid->min_gid, gxvalid->max_gid ));
         GXV_SET_ERR_IF_PARANOID( FT_INVALID_GLYPH_ID );
       }
     }
@@ -223,7 +223,7 @@
   FT_LOCAL_DEF( void )
   gxv_mort_subtable_type1_validate( FT_Bytes       table,
                                     FT_Bytes       limit,
-                                    GXV_Validator  valid )
+                                    GXV_Validator  gxvalid )
   {
     FT_Bytes  p = table;
 
@@ -234,23 +234,23 @@
 
     GXV_LIMIT_CHECK( GXV_MORT_SUBTABLE_TYPE1_HEADER_SIZE );
 
-    valid->statetable.optdata =
+    gxvalid->statetable.optdata =
       &st_rec;
-    valid->statetable.optdata_load_func =
+    gxvalid->statetable.optdata_load_func =
       gxv_mort_subtable_type1_substitutionTable_load;
-    valid->statetable.subtable_setup_func =
+    gxvalid->statetable.subtable_setup_func =
       gxv_mort_subtable_type1_subtable_setup;
-    valid->statetable.entry_glyphoffset_fmt =
+    gxvalid->statetable.entry_glyphoffset_fmt =
       GXV_GLYPHOFFSET_ULONG;
-    valid->statetable.entry_validate_func =
+    gxvalid->statetable.entry_validate_func =
 
       gxv_mort_subtable_type1_entry_validate;
-    gxv_StateTable_validate( p, limit, valid );
+    gxv_StateTable_validate( p, limit, gxvalid );
 
     gxv_mort_subtable_type1_substTable_validate(
       table + st_rec.substitutionTable,
       table + st_rec.substitutionTable + st_rec.substitutionTable_length,
-      valid );
+      gxvalid );
 
     GXV_EXIT;
   }
diff --git a/src/gxvalid/gxvmort2.c b/src/gxvalid/gxvmort2.c
index 9e08fb7..099ffd4 100644
--- a/src/gxvalid/gxvmort2.c
+++ b/src/gxvalid/gxvmort2.c
@@ -57,11 +57,11 @@
   static void
   gxv_mort_subtable_type2_opttable_load( FT_Bytes       table,
                                          FT_Bytes       limit,
-                                         GXV_Validator  valid )
+                                         GXV_Validator  gxvalid )
   {
-    FT_Bytes p = table;
+    FT_Bytes  p = table;
     GXV_mort_subtable_type2_StateOptRecData  optdata =
-      (GXV_mort_subtable_type2_StateOptRecData)valid->statetable.optdata;
+      (GXV_mort_subtable_type2_StateOptRecData)gxvalid->statetable.optdata;
 
 
     GXV_LIMIT_CHECK( 2 + 2 + 2 );
@@ -86,14 +86,14 @@
                                           FT_UShort      *classTable_length_p,
                                           FT_UShort      *stateArray_length_p,
                                           FT_UShort      *entryTable_length_p,
-                                          GXV_Validator  valid )
+                                          GXV_Validator  gxvalid )
   {
     FT_UShort  o[6];
     FT_UShort  *l[6];
     FT_UShort  buff[7];
 
     GXV_mort_subtable_type2_StateOptRecData  optdata =
-      (GXV_mort_subtable_type2_StateOptRecData)valid->statetable.optdata;
+      (GXV_mort_subtable_type2_StateOptRecData)gxvalid->statetable.optdata;
 
 
     GXV_NAME_ENTER( "subtable boundaries setup" );
@@ -111,7 +111,7 @@
     l[4] = &(optdata->componentTable_length);
     l[5] = &(optdata->ligatureTable_length);
 
-    gxv_set_length_by_ushort_offset( o, l, buff, 6, table_size, valid );
+    gxv_set_length_by_ushort_offset( o, l, buff, 6, table_size, gxvalid );
 
     GXV_TRACE(( "classTable: offset=0x%04x length=0x%04x\n",
                 classTable, *classTable_length_p ));
@@ -137,11 +137,11 @@
   gxv_mort_subtable_type2_ligActionOffset_validate(
     FT_Bytes       table,
     FT_UShort      ligActionOffset,
-    GXV_Validator  valid )
+    GXV_Validator  gxvalid )
   {
     /* access ligActionTable */
     GXV_mort_subtable_type2_StateOptRecData  optdata =
-      (GXV_mort_subtable_type2_StateOptRecData)valid->statetable.optdata;
+      (GXV_mort_subtable_type2_StateOptRecData)gxvalid->statetable.optdata;
 
     FT_Bytes lat_base  = table + optdata->ligActionTable;
     FT_Bytes p         = table + ligActionOffset;
@@ -214,7 +214,7 @@
     GXV_StateTable_GlyphOffsetCPtr  glyphOffset_p,
     FT_Bytes                        table,
     FT_Bytes                        limit,
-    GXV_Validator                   valid )
+    GXV_Validator                   gxvalid )
   {
 #ifdef GXV_LOAD_UNUSED_VARS
     FT_UShort setComponent;
@@ -236,16 +236,16 @@
 
     if ( 0 < offset )
       gxv_mort_subtable_type2_ligActionOffset_validate( table, offset,
-                                                        valid );
+                                                        gxvalid );
   }
 
 
   static void
   gxv_mort_subtable_type2_ligatureTable_validate( FT_Bytes       table,
-                                                  GXV_Validator  valid )
+                                                  GXV_Validator  gxvalid )
   {
     GXV_mort_subtable_type2_StateOptRecData  optdata =
-      (GXV_mort_subtable_type2_StateOptRecData)valid->statetable.optdata;
+      (GXV_mort_subtable_type2_StateOptRecData)gxvalid->statetable.optdata;
 
     FT_Bytes p     = table + optdata->ligatureTable;
     FT_Bytes limit = table + optdata->ligatureTable
@@ -264,7 +264,7 @@
         GXV_LIMIT_CHECK( 2 );
         lig_gid = FT_NEXT_USHORT( p );
 
-        if ( valid->face->num_glyphs < lig_gid )
+        if ( gxvalid->face->num_glyphs < lig_gid )
           GXV_SET_ERR_IF_PARANOID( FT_INVALID_GLYPH_ID );
       }
     }
@@ -275,7 +275,7 @@
   FT_LOCAL_DEF( void )
   gxv_mort_subtable_type2_validate( FT_Bytes       table,
                                     FT_Bytes       limit,
-                                    GXV_Validator  valid )
+                                    GXV_Validator  gxvalid )
   {
     FT_Bytes  p = table;
 
@@ -286,23 +286,23 @@
 
     GXV_LIMIT_CHECK( GXV_MORT_SUBTABLE_TYPE2_HEADER_SIZE );
 
-    valid->statetable.optdata =
+    gxvalid->statetable.optdata =
       &lig_rec;
-    valid->statetable.optdata_load_func =
+    gxvalid->statetable.optdata_load_func =
       gxv_mort_subtable_type2_opttable_load;
-    valid->statetable.subtable_setup_func =
+    gxvalid->statetable.subtable_setup_func =
       gxv_mort_subtable_type2_subtable_setup;
-    valid->statetable.entry_glyphoffset_fmt =
+    gxvalid->statetable.entry_glyphoffset_fmt =
       GXV_GLYPHOFFSET_NONE;
-    valid->statetable.entry_validate_func =
+    gxvalid->statetable.entry_validate_func =
       gxv_mort_subtable_type2_entry_validate;
 
-    gxv_StateTable_validate( p, limit, valid );
+    gxv_StateTable_validate( p, limit, gxvalid );
 
-    p += valid->subtable_length;
-    gxv_mort_subtable_type2_ligatureTable_validate( table, valid );
+    p += gxvalid->subtable_length;
+    gxv_mort_subtable_type2_ligatureTable_validate( table, gxvalid );
 
-    valid->subtable_length = p - table;
+    gxvalid->subtable_length = p - table;
 
     GXV_EXIT;
   }
diff --git a/src/gxvalid/gxvmort4.c b/src/gxvalid/gxvmort4.c
index 8347098..9e86af4 100644
--- a/src/gxvalid/gxvmort4.c
+++ b/src/gxvalid/gxvmort4.c
@@ -41,11 +41,11 @@
   static void
   gxv_mort_subtable_type4_lookupval_validate( FT_UShort            glyph,
                                               GXV_LookupValueCPtr  value_p,
-                                              GXV_Validator        valid )
+                                              GXV_Validator        gxvalid )
   {
     FT_UNUSED( glyph );
 
-    gxv_glyphid_validate( value_p->u, valid );
+    gxv_glyphid_validate( value_p->u, gxvalid );
   }
 
   /*
@@ -80,7 +80,7 @@
     FT_UShort            relative_gindex,
     GXV_LookupValueCPtr  base_value_p,
     FT_Bytes             lookuptbl_limit,
-    GXV_Validator        valid )
+    GXV_Validator        gxvalid )
   {
     FT_Bytes             p;
     FT_Bytes             limit;
@@ -91,7 +91,7 @@
     offset = (FT_UShort)( base_value_p->u +
                           relative_gindex * sizeof ( FT_UShort ) );
 
-    p     = valid->lookuptbl_head + offset;
+    p     = gxvalid->lookuptbl_head + offset;
     limit = lookuptbl_limit;
 
     GXV_LIMIT_CHECK( 2 );
@@ -104,7 +104,7 @@
   FT_LOCAL_DEF( void )
   gxv_mort_subtable_type4_validate( FT_Bytes       table,
                                     FT_Bytes       limit,
-                                    GXV_Validator  valid )
+                                    GXV_Validator  gxvalid )
   {
     FT_Bytes  p = table;
 
@@ -112,11 +112,11 @@
     GXV_NAME_ENTER( "mort chain subtable type4 "
                     "(Non-Contextual Glyph Substitution)" );
 
-    valid->lookupval_sign   = GXV_LOOKUPVALUE_UNSIGNED;
-    valid->lookupval_func   = gxv_mort_subtable_type4_lookupval_validate;
-    valid->lookupfmt4_trans = gxv_mort_subtable_type4_lookupfmt4_transit;
+    gxvalid->lookupval_sign   = GXV_LOOKUPVALUE_UNSIGNED;
+    gxvalid->lookupval_func   = gxv_mort_subtable_type4_lookupval_validate;
+    gxvalid->lookupfmt4_trans = gxv_mort_subtable_type4_lookupfmt4_transit;
 
-    gxv_LookupTable_validate( p, limit, valid );
+    gxv_LookupTable_validate( p, limit, gxvalid );
 
     GXV_EXIT;
   }
diff --git a/src/gxvalid/gxvmort5.c b/src/gxvalid/gxvmort5.c
index 32cfb03..9498b10 100644
--- a/src/gxvalid/gxvmort5.c
+++ b/src/gxvalid/gxvmort5.c
@@ -70,10 +70,10 @@
                                           FT_UShort*     classTable_length_p,
                                           FT_UShort*     stateArray_length_p,
                                           FT_UShort*     entryTable_length_p,
-                                          GXV_Validator  valid )
+                                          GXV_Validator  gxvalid )
   {
     GXV_mort_subtable_type5_StateOptRecData  optdata =
-      (GXV_mort_subtable_type5_StateOptRecData)valid->statetable.optdata;
+      (GXV_mort_subtable_type5_StateOptRecData)gxvalid->statetable.optdata;
 
 
     gxv_StateTable_subtable_setup( table_size,
@@ -83,7 +83,7 @@
                                    classTable_length_p,
                                    stateArray_length_p,
                                    entryTable_length_p,
-                                   valid );
+                                   gxvalid );
 
     optdata->classTable = classTable;
     optdata->stateArray = stateArray;
@@ -100,7 +100,7 @@
                                                FT_UShort      count,
                                                FT_Bytes       table,
                                                FT_Bytes       limit,
-                                               GXV_Validator  valid )
+                                               GXV_Validator  gxvalid )
   {
     /*
      * We don't know the range of insertion-glyph-list.
@@ -109,7 +109,7 @@
     FT_Bytes  p = table + offset;
 
     GXV_mort_subtable_type5_StateOptRecData  optdata =
-      (GXV_mort_subtable_type5_StateOptRecData)valid->statetable.optdata;
+      (GXV_mort_subtable_type5_StateOptRecData)gxvalid->statetable.optdata;
 
     if ( optdata->classTable < offset                                   &&
          offset < optdata->classTable + *(optdata->classTable_length_p) )
@@ -145,7 +145,7 @@
     GXV_StateTable_GlyphOffsetCPtr  glyphOffset,
     FT_Bytes                        table,
     FT_Bytes                        limit,
-    GXV_Validator                   valid )
+    GXV_Validator                   gxvalid )
   {
 #ifdef GXV_LOAD_UNUSED_VARS
     FT_Bool    setMark;
@@ -184,7 +184,7 @@
                                                    currentInsertCount,
                                                    table,
                                                    limit,
-                                                   valid );
+                                                   gxvalid );
     }
 
     if ( 0 != markedInsertList && 0 != markedInsertCount )
@@ -193,7 +193,7 @@
                                                    markedInsertCount,
                                                    table,
                                                    limit,
-                                                   valid );
+                                                   gxvalid );
     }
   }
 
@@ -201,7 +201,7 @@
   FT_LOCAL_DEF( void )
   gxv_mort_subtable_type5_validate( FT_Bytes       table,
                                     FT_Bytes       limit,
-                                    GXV_Validator  valid )
+                                    GXV_Validator  gxvalid )
   {
     FT_Bytes  p = table;
 
@@ -213,18 +213,18 @@
 
     GXV_LIMIT_CHECK( GXV_MORT_SUBTABLE_TYPE5_HEADER_SIZE );
 
-    valid->statetable.optdata =
+    gxvalid->statetable.optdata =
       et;
-    valid->statetable.optdata_load_func =
+    gxvalid->statetable.optdata_load_func =
       NULL;
-    valid->statetable.subtable_setup_func =
+    gxvalid->statetable.subtable_setup_func =
       gxv_mort_subtable_type5_subtable_setup;
-    valid->statetable.entry_glyphoffset_fmt =
+    gxvalid->statetable.entry_glyphoffset_fmt =
       GXV_GLYPHOFFSET_ULONG;
-    valid->statetable.entry_validate_func =
+    gxvalid->statetable.entry_validate_func =
       gxv_mort_subtable_type5_entry_validate;
 
-    gxv_StateTable_validate( p, limit, valid );
+    gxv_StateTable_validate( p, limit, gxvalid );
 
     GXV_EXIT;
   }
diff --git a/src/gxvalid/gxvmorx.c b/src/gxvalid/gxvmorx.c
index 5ae04d3..96dba63 100644
--- a/src/gxvalid/gxvmorx.c
+++ b/src/gxvalid/gxvmorx.c
@@ -42,7 +42,7 @@
   gxv_morx_subtables_validate( FT_Bytes       table,
                                FT_Bytes       limit,
                                FT_UShort      nSubtables,
-                               GXV_Validator  valid )
+                               GXV_Validator  gxvalid )
   {
     FT_Bytes  p = table;
 
@@ -93,7 +93,7 @@
 
       /* morx coverage consists of mort_coverage & 16bit padding */
       gxv_mort_coverage_validate( (FT_UShort)( ( coverage >> 16 ) | coverage ),
-                                  valid );
+                                  gxvalid );
       if ( type > 5 )
         FT_INVALID_FORMAT;
 
@@ -101,13 +101,13 @@
       if ( func == NULL )
         GXV_TRACE(( "morx type %d is reserved\n", type ));
 
-      func( p, p + rest, valid );
+      func( p, p + rest, gxvalid );
 
       /* TODO: subFeatureFlags should be unique in a table? */
       p += rest;
     }
 
-    valid->subtable_length = p - table;
+    gxvalid->subtable_length = p - table;
 
     GXV_EXIT;
   }
@@ -116,7 +116,7 @@
   static void
   gxv_morx_chain_validate( FT_Bytes       table,
                            FT_Bytes       limit,
-                           GXV_Validator  valid )
+                           GXV_Validator  gxvalid )
   {
     FT_Bytes  p = table;
 #ifdef GXV_LOAD_UNUSED_VARS
@@ -140,16 +140,16 @@
     nSubtables    = FT_NEXT_ULONG( p );
 
     /* feature-array of morx is same with that of mort */
-    gxv_mort_featurearray_validate( p, limit, nFeatureFlags, valid );
-    p += valid->subtable_length;
+    gxv_mort_featurearray_validate( p, limit, nFeatureFlags, gxvalid );
+    p += gxvalid->subtable_length;
 
     if ( nSubtables >= 0x10000L )
       FT_INVALID_DATA;
 
     gxv_morx_subtables_validate( p, table + chainLength,
-                                 (FT_UShort)nSubtables, valid );
+                                 (FT_UShort)nSubtables, gxvalid );
 
-    valid->subtable_length = chainLength;
+    gxvalid->subtable_length = chainLength;
 
     /* TODO: defaultFlags should be compared with the flags in tables */
 
@@ -162,8 +162,8 @@
                      FT_Face       face,
                      FT_Validator  ftvalid )
   {
-    GXV_ValidatorRec  validrec;
-    GXV_Validator     valid = &validrec;
+    GXV_ValidatorRec  gxvalidrec;
+    GXV_Validator     gxvalid = &gxvalidrec;
     FT_Bytes          p     = table;
     FT_Bytes          limit = 0;
     FT_ULong          version;
@@ -171,8 +171,8 @@
     FT_ULong          i;
 
 
-    valid->root = ftvalid;
-    valid->face = face;
+    gxvalid->root = ftvalid;
+    gxvalid->face = face;
 
     FT_TRACE3(( "validating `morx' table\n" ));
     GXV_INIT;
@@ -188,8 +188,8 @@
     {
       GXV_TRACE(( "validating chain %d/%d\n", i + 1, nChains ));
       GXV_32BIT_ALIGNMENT_VALIDATE( p - table );
-      gxv_morx_chain_validate( p, limit, valid );
-      p += valid->subtable_length;
+      gxv_morx_chain_validate( p, limit, gxvalid );
+      p += gxvalid->subtable_length;
     }
 
     FT_TRACE4(( "\n" ));
diff --git a/src/gxvalid/gxvmorx.h b/src/gxvalid/gxvmorx.h
index 28c1a44..9ed907a 100644
--- a/src/gxvalid/gxvmorx.h
+++ b/src/gxvalid/gxvmorx.h
@@ -38,27 +38,27 @@
   FT_LOCAL( void )
   gxv_morx_subtable_type0_validate( FT_Bytes       table,
                                     FT_Bytes       limit,
-                                    GXV_Validator  valid );
+                                    GXV_Validator  gxvalid );
 
   FT_LOCAL( void )
   gxv_morx_subtable_type1_validate( FT_Bytes       table,
                                     FT_Bytes       limit,
-                                    GXV_Validator  valid );
+                                    GXV_Validator  gxvalid );
 
   FT_LOCAL( void )
   gxv_morx_subtable_type2_validate( FT_Bytes       table,
                                     FT_Bytes       limit,
-                                    GXV_Validator  valid );
+                                    GXV_Validator  gxvalid );
 
   FT_LOCAL( void )
   gxv_morx_subtable_type4_validate( FT_Bytes       table,
                                     FT_Bytes       limit,
-                                    GXV_Validator  valid );
+                                    GXV_Validator  gxvalid );
 
   FT_LOCAL( void )
   gxv_morx_subtable_type5_validate( FT_Bytes       table,
                                     FT_Bytes       limit,
-                                    GXV_Validator  valid );
+                                    GXV_Validator  gxvalid );
 
 
 #endif /* __GXVMORX_H__ */
diff --git a/src/gxvalid/gxvmorx0.c b/src/gxvalid/gxvmorx0.c
index 6a736c1..db165f4 100644
--- a/src/gxvalid/gxvmorx0.c
+++ b/src/gxvalid/gxvmorx0.c
@@ -45,7 +45,7 @@
     GXV_XStateTable_GlyphOffsetCPtr  glyphOffset_p,
     FT_Bytes                         table,
     FT_Bytes                         limit,
-    GXV_Validator                    valid )
+    GXV_Validator                    gxvalid )
   {
 #ifdef GXV_LOAD_UNUSED_VARS
     FT_UShort  markFirst;
@@ -85,7 +85,7 @@
   FT_LOCAL_DEF( void )
   gxv_morx_subtable_type0_validate( FT_Bytes       table,
                                     FT_Bytes       limit,
-                                    GXV_Validator  valid )
+                                    GXV_Validator  gxvalid )
   {
     FT_Bytes  p = table;
 
@@ -95,14 +95,14 @@
 
     GXV_LIMIT_CHECK( GXV_STATETABLE_HEADER_SIZE );
 
-    valid->xstatetable.optdata               = NULL;
-    valid->xstatetable.optdata_load_func     = NULL;
-    valid->xstatetable.subtable_setup_func   = NULL;
-    valid->xstatetable.entry_glyphoffset_fmt = GXV_GLYPHOFFSET_NONE;
-    valid->xstatetable.entry_validate_func =
+    gxvalid->xstatetable.optdata               = NULL;
+    gxvalid->xstatetable.optdata_load_func     = NULL;
+    gxvalid->xstatetable.subtable_setup_func   = NULL;
+    gxvalid->xstatetable.entry_glyphoffset_fmt = GXV_GLYPHOFFSET_NONE;
+    gxvalid->xstatetable.entry_validate_func =
       gxv_morx_subtable_type0_entry_validate;
 
-    gxv_XStateTable_validate( p, limit, valid );
+    gxv_XStateTable_validate( p, limit, gxvalid );
 
     GXV_EXIT;
   }
diff --git a/src/gxvalid/gxvmorx1.c b/src/gxvalid/gxvmorx1.c
index ce0009a..49f53d1 100644
--- a/src/gxvalid/gxvmorx1.c
+++ b/src/gxvalid/gxvmorx1.c
@@ -55,12 +55,12 @@
   static void
   gxv_morx_subtable_type1_substitutionTable_load( FT_Bytes       table,
                                                   FT_Bytes       limit,
-                                                  GXV_Validator  valid )
+                                                  GXV_Validator  gxvalid )
   {
     FT_Bytes  p = table;
 
     GXV_morx_subtable_type1_StateOptRecData  optdata =
-      (GXV_morx_subtable_type1_StateOptRecData)valid->xstatetable.optdata;
+      (GXV_morx_subtable_type1_StateOptRecData)gxvalid->xstatetable.optdata;
 
 
     GXV_LIMIT_CHECK( 2 );
@@ -76,14 +76,14 @@
                                           FT_ULong*      classTable_length_p,
                                           FT_ULong*      stateArray_length_p,
                                           FT_ULong*      entryTable_length_p,
-                                          GXV_Validator  valid )
+                                          GXV_Validator  gxvalid )
   {
     FT_ULong  o[4];
     FT_ULong  *l[4];
     FT_ULong  buff[5];
 
     GXV_morx_subtable_type1_StateOptRecData  optdata =
-      (GXV_morx_subtable_type1_StateOptRecData)valid->xstatetable.optdata;
+      (GXV_morx_subtable_type1_StateOptRecData)gxvalid->xstatetable.optdata;
 
 
     o[0] = classTable;
@@ -95,7 +95,7 @@
     l[2] = entryTable_length_p;
     l[3] = &(optdata->substitutionTable_length);
 
-    gxv_set_length_by_ulong_offset( o, l, buff, 4, table_size, valid );
+    gxv_set_length_by_ulong_offset( o, l, buff, 4, table_size, gxvalid );
   }
 
 
@@ -106,7 +106,7 @@
     GXV_StateTable_GlyphOffsetCPtr  glyphOffset_p,
     FT_Bytes                        table,
     FT_Bytes                        limit,
-    GXV_Validator                   valid )
+    GXV_Validator                   gxvalid )
   {
 #ifdef GXV_LOAD_TRACE_VARS
     FT_UShort  setMark;
@@ -117,7 +117,7 @@
     FT_Short   currentIndex;
 
     GXV_morx_subtable_type1_StateOptRecData  optdata =
-      (GXV_morx_subtable_type1_StateOptRecData)valid->xstatetable.optdata;
+      (GXV_morx_subtable_type1_StateOptRecData)gxvalid->xstatetable.optdata;
 
     FT_UNUSED( state );
     FT_UNUSED( table );
@@ -159,13 +159,13 @@
   static void
   gxv_morx_subtable_type1_LookupValue_validate( FT_UShort            glyph,
                                                 GXV_LookupValueCPtr  value_p,
-                                                GXV_Validator        valid )
+                                                GXV_Validator        gxvalid )
   {
     FT_UNUSED( glyph ); /* for the non-debugging case */
 
     GXV_TRACE(( "morx subtable type1 subst.: %d -> %d\n", glyph, value_p->u ));
 
-    if ( value_p->u > valid->face->num_glyphs )
+    if ( value_p->u > gxvalid->face->num_glyphs )
       FT_INVALID_GLYPH_ID;
   }
 
@@ -175,7 +175,7 @@
     FT_UShort            relative_gindex,
     GXV_LookupValueCPtr  base_value_p,
     FT_Bytes             lookuptbl_limit,
-    GXV_Validator        valid )
+    GXV_Validator        gxvalid )
   {
     FT_Bytes             p;
     FT_Bytes             limit;
@@ -186,7 +186,7 @@
     offset = (FT_UShort)( base_value_p->u +
                           relative_gindex * sizeof ( FT_UShort ) );
 
-    p     = valid->lookuptbl_head + offset;
+    p     = gxvalid->lookuptbl_head + offset;
     limit = lookuptbl_limit;
 
     GXV_LIMIT_CHECK ( 2 );
@@ -202,19 +202,19 @@
   static void
   gxv_morx_subtable_type1_substitutionTable_validate( FT_Bytes       table,
                                                       FT_Bytes       limit,
-                                                      GXV_Validator  valid )
+                                                      GXV_Validator  gxvalid )
   {
     FT_Bytes   p = table;
     FT_UShort  i;
 
     GXV_morx_subtable_type1_StateOptRecData  optdata =
-      (GXV_morx_subtable_type1_StateOptRecData)valid->xstatetable.optdata;
+      (GXV_morx_subtable_type1_StateOptRecData)gxvalid->xstatetable.optdata;
 
 
     /* TODO: calculate offset/length for each lookupTables */
-    valid->lookupval_sign   = GXV_LOOKUPVALUE_UNSIGNED;
-    valid->lookupval_func   = gxv_morx_subtable_type1_LookupValue_validate;
-    valid->lookupfmt4_trans = gxv_morx_subtable_type1_LookupFmt4_transit;
+    gxvalid->lookupval_sign   = GXV_LOOKUPVALUE_UNSIGNED;
+    gxvalid->lookupval_func   = gxv_morx_subtable_type1_LookupValue_validate;
+    gxvalid->lookupfmt4_trans = gxv_morx_subtable_type1_LookupFmt4_transit;
 
     for ( i = 0; i < optdata->substitutionTable_num_lookupTables; i++ )
     {
@@ -224,7 +224,7 @@
       GXV_LIMIT_CHECK( 4 );
       offset = FT_NEXT_ULONG( p );
 
-      gxv_LookupTable_validate( table + offset, limit, valid );
+      gxv_LookupTable_validate( table + offset, limit, gxvalid );
     }
 
     /* TODO: overlapping of lookupTables in substitutionTable */
@@ -239,7 +239,7 @@
   FT_LOCAL_DEF( void )
   gxv_morx_subtable_type1_validate( FT_Bytes       table,
                                     FT_Bytes       limit,
-                                    GXV_Validator  valid )
+                                    GXV_Validator  gxvalid )
   {
     FT_Bytes  p = table;
 
@@ -252,23 +252,23 @@
 
     st_rec.substitutionTable_num_lookupTables = 0;
 
-    valid->xstatetable.optdata =
+    gxvalid->xstatetable.optdata =
       &st_rec;
-    valid->xstatetable.optdata_load_func =
+    gxvalid->xstatetable.optdata_load_func =
       gxv_morx_subtable_type1_substitutionTable_load;
-    valid->xstatetable.subtable_setup_func =
+    gxvalid->xstatetable.subtable_setup_func =
       gxv_morx_subtable_type1_subtable_setup;
-    valid->xstatetable.entry_glyphoffset_fmt =
+    gxvalid->xstatetable.entry_glyphoffset_fmt =
       GXV_GLYPHOFFSET_ULONG;
-    valid->xstatetable.entry_validate_func =
+    gxvalid->xstatetable.entry_validate_func =
       gxv_morx_subtable_type1_entry_validate;
 
-    gxv_XStateTable_validate( p, limit, valid );
+    gxv_XStateTable_validate( p, limit, gxvalid );
 
     gxv_morx_subtable_type1_substitutionTable_validate(
       table + st_rec.substitutionTable,
       table + st_rec.substitutionTable + st_rec.substitutionTable_length,
-      valid );
+      gxvalid );
 
     GXV_EXIT;
   }
diff --git a/src/gxvalid/gxvmorx2.c b/src/gxvalid/gxvmorx2.c
index 95b8ea4..e44445d 100644
--- a/src/gxvalid/gxvmorx2.c
+++ b/src/gxvalid/gxvmorx2.c
@@ -58,12 +58,12 @@
   static void
   gxv_morx_subtable_type2_opttable_load( FT_Bytes       table,
                                          FT_Bytes       limit,
-                                         GXV_Validator  valid )
+                                         GXV_Validator  gxvalid )
   {
     FT_Bytes  p = table;
 
     GXV_morx_subtable_type2_StateOptRecData  optdata =
-      (GXV_morx_subtable_type2_StateOptRecData)valid->xstatetable.optdata;
+      (GXV_morx_subtable_type2_StateOptRecData)gxvalid->xstatetable.optdata;
 
 
     GXV_LIMIT_CHECK( 4 + 4 + 4 );
@@ -88,14 +88,14 @@
                                           FT_ULong*      classTable_length_p,
                                           FT_ULong*      stateArray_length_p,
                                           FT_ULong*      entryTable_length_p,
-                                          GXV_Validator  valid )
+                                          GXV_Validator  gxvalid )
   {
     FT_ULong   o[6];
     FT_ULong*  l[6];
     FT_ULong   buff[7];
 
     GXV_morx_subtable_type2_StateOptRecData  optdata =
-      (GXV_morx_subtable_type2_StateOptRecData)valid->xstatetable.optdata;
+      (GXV_morx_subtable_type2_StateOptRecData)gxvalid->xstatetable.optdata;
 
 
     GXV_NAME_ENTER( "subtable boundaries setup" );
@@ -113,7 +113,7 @@
     l[4] = &(optdata->componentTable_length);
     l[5] = &(optdata->ligatureTable_length);
 
-    gxv_set_length_by_ulong_offset( o, l, buff, 6, table_size, valid );
+    gxv_set_length_by_ulong_offset( o, l, buff, 6, table_size, gxvalid );
 
     GXV_TRACE(( "classTable: offset=0x%08x length=0x%08x\n",
                 classTable, *classTable_length_p ));
@@ -142,11 +142,11 @@
   gxv_morx_subtable_type2_ligActionIndex_validate(
     FT_Bytes       table,
     FT_UShort      ligActionIndex,
-    GXV_Validator  valid )
+    GXV_Validator  gxvalid )
   {
     /* access ligActionTable */
     GXV_morx_subtable_type2_StateOptRecData optdata =
-      (GXV_morx_subtable_type2_StateOptRecData)valid->xstatetable.optdata;
+      (GXV_morx_subtable_type2_StateOptRecData)gxvalid->xstatetable.optdata;
 
     FT_Bytes lat_base  = table + optdata->ligActionTable;
     FT_Bytes p         = lat_base +
@@ -188,7 +188,7 @@
       /* it is different from the location offset in mort */
       if ( ( offset & 0x3FFF0000UL ) == 0x3FFF0000UL )
       { /* negative offset */
-        gid_limit = valid->face->num_glyphs - ( offset & 0x0000FFFFUL );
+        gid_limit = gxvalid->face->num_glyphs - ( offset & 0x0000FFFFUL );
         if ( gid_limit > 0 )
           return;
 
@@ -198,9 +198,9 @@
                     offset & 0xFFFFU ));
         GXV_SET_ERR_IF_PARANOID( FT_INVALID_OFFSET );
       }
-      else if ( ( offset & 0x3FFF0000UL ) == 0x0000000UL )
+      else if ( ( offset & 0x3FFF0000UL ) == 0x00000000UL )
       { /* positive offset */
-        if ( (FT_Long)offset < valid->face->num_glyphs )
+        if ( (FT_Long)offset < gxvalid->face->num_glyphs )
           return;
 
         GXV_TRACE(( "ligature action table includes"
@@ -225,7 +225,7 @@
     GXV_StateTable_GlyphOffsetCPtr  glyphOffset_p,
     FT_Bytes                        table,
     FT_Bytes                        limit,
-    GXV_Validator                   valid )
+    GXV_Validator                   gxvalid )
   {
 #ifdef GXV_LOAD_UNUSED_VARS
     FT_UShort  setComponent;
@@ -253,16 +253,16 @@
 
     if ( 0 < ligActionIndex )
       gxv_morx_subtable_type2_ligActionIndex_validate(
-        table, ligActionIndex, valid );
+        table, ligActionIndex, gxvalid );
   }
 
 
   static void
   gxv_morx_subtable_type2_ligatureTable_validate( FT_Bytes       table,
-                                                  GXV_Validator  valid )
+                                                  GXV_Validator  gxvalid )
   {
     GXV_morx_subtable_type2_StateOptRecData  optdata =
-      (GXV_morx_subtable_type2_StateOptRecData)valid->xstatetable.optdata;
+      (GXV_morx_subtable_type2_StateOptRecData)gxvalid->xstatetable.optdata;
 
     FT_Bytes p     = table + optdata->ligatureTable;
     FT_Bytes limit = table + optdata->ligatureTable
@@ -281,7 +281,7 @@
 
         GXV_LIMIT_CHECK( 2 );
         lig_gid = FT_NEXT_USHORT( p );
-        if ( lig_gid < valid->face->num_glyphs )
+        if ( lig_gid < gxvalid->face->num_glyphs )
           GXV_SET_ERR_IF_PARANOID( FT_INVALID_GLYPH_ID );
       }
     }
@@ -293,7 +293,7 @@
   FT_LOCAL_DEF( void )
   gxv_morx_subtable_type2_validate( FT_Bytes       table,
                                     FT_Bytes       limit,
-                                    GXV_Validator  valid )
+                                    GXV_Validator  gxvalid )
   {
     FT_Bytes  p = table;
 
@@ -304,23 +304,23 @@
 
     GXV_LIMIT_CHECK( GXV_MORX_SUBTABLE_TYPE2_HEADER_SIZE );
 
-    valid->xstatetable.optdata =
+    gxvalid->xstatetable.optdata =
       &lig_rec;
-    valid->xstatetable.optdata_load_func =
+    gxvalid->xstatetable.optdata_load_func =
       gxv_morx_subtable_type2_opttable_load;
-    valid->xstatetable.subtable_setup_func =
+    gxvalid->xstatetable.subtable_setup_func =
       gxv_morx_subtable_type2_subtable_setup;
-    valid->xstatetable.entry_glyphoffset_fmt =
+    gxvalid->xstatetable.entry_glyphoffset_fmt =
       GXV_GLYPHOFFSET_USHORT;
-    valid->xstatetable.entry_validate_func =
+    gxvalid->xstatetable.entry_validate_func =
       gxv_morx_subtable_type2_entry_validate;
 
-    gxv_XStateTable_validate( p, limit, valid );
+    gxv_XStateTable_validate( p, limit, gxvalid );
 
 #if 0
-    p += valid->subtable_length;
+    p += gxvalid->subtable_length;
 #endif
-    gxv_morx_subtable_type2_ligatureTable_validate( table, valid );
+    gxv_morx_subtable_type2_ligatureTable_validate( table, gxvalid );
 
     GXV_EXIT;
   }
diff --git a/src/gxvalid/gxvmorx4.c b/src/gxvalid/gxvmorx4.c
index c0d2f78..68ab678 100644
--- a/src/gxvalid/gxvmorx4.c
+++ b/src/gxvalid/gxvmorx4.c
@@ -41,12 +41,12 @@
   FT_LOCAL_DEF( void )
   gxv_morx_subtable_type4_validate( FT_Bytes       table,
                                     FT_Bytes       limit,
-                                    GXV_Validator  valid )
+                                    GXV_Validator  gxvalid )
   {
     GXV_NAME_ENTER( "morx chain subtable type4 "
                     "(Non-Contextual Glyph Substitution)" );
 
-    gxv_mort_subtable_type4_validate( table, limit, valid );
+    gxv_mort_subtable_type4_validate( table, limit, gxvalid );
 
     GXV_EXIT;
   }
diff --git a/src/gxvalid/gxvmorx5.c b/src/gxvalid/gxvmorx5.c
index d8cf700..5e095dd 100644
--- a/src/gxvalid/gxvmorx5.c
+++ b/src/gxvalid/gxvmorx5.c
@@ -64,12 +64,12 @@
   static void
   gxv_morx_subtable_type5_insertionGlyphList_load( FT_Bytes       table,
                                                    FT_Bytes       limit,
-                                                   GXV_Validator  valid )
+                                                   GXV_Validator  gxvalid )
   {
     FT_Bytes  p = table;
 
     GXV_morx_subtable_type5_StateOptRecData  optdata =
-      (GXV_morx_subtable_type5_StateOptRecData)valid->xstatetable.optdata;
+      (GXV_morx_subtable_type5_StateOptRecData)gxvalid->xstatetable.optdata;
 
 
     GXV_LIMIT_CHECK( 4 );
@@ -85,14 +85,14 @@
                                           FT_ULong*      classTable_length_p,
                                           FT_ULong*      stateArray_length_p,
                                           FT_ULong*      entryTable_length_p,
-                                          GXV_Validator  valid )
+                                          GXV_Validator  gxvalid )
   {
     FT_ULong   o[4];
     FT_ULong*  l[4];
     FT_ULong   buff[5];
 
     GXV_morx_subtable_type5_StateOptRecData  optdata =
-      (GXV_morx_subtable_type5_StateOptRecData)valid->xstatetable.optdata;
+      (GXV_morx_subtable_type5_StateOptRecData)gxvalid->xstatetable.optdata;
 
 
     o[0] = classTable;
@@ -104,7 +104,7 @@
     l[2] = entryTable_length_p;
     l[3] = &(optdata->insertionGlyphList_length);
 
-    gxv_set_length_by_ulong_offset( o, l, buff, 4, table_size, valid );
+    gxv_set_length_by_ulong_offset( o, l, buff, 4, table_size, gxvalid );
   }
 
 
@@ -113,9 +113,9 @@
                                                FT_UShort      count,
                                                FT_Bytes       table,
                                                FT_Bytes       limit,
-                                               GXV_Validator  valid )
+                                               GXV_Validator  gxvalid )
   {
-    FT_Bytes p = table + table_index * 2;
+    FT_Bytes  p = table + table_index * 2;
 
 
 #ifndef GXV_LOAD_TRACE_VARS
@@ -143,7 +143,7 @@
     GXV_StateTable_GlyphOffsetCPtr  glyphOffset_p,
     FT_Bytes                        table,
     FT_Bytes                        limit,
-    GXV_Validator                   valid )
+    GXV_Validator                   gxvalid )
   {
 #ifdef GXV_LOAD_UNUSED_VARS
     FT_Bool    setMark;
@@ -180,20 +180,20 @@
       gxv_morx_subtable_type5_InsertList_validate( currentInsertList,
                                                    currentInsertCount,
                                                    table, limit,
-                                                   valid );
+                                                   gxvalid );
 
     if ( markedInsertList && 0 != markedInsertCount )
       gxv_morx_subtable_type5_InsertList_validate( markedInsertList,
                                                    markedInsertCount,
                                                    table, limit,
-                                                   valid );
+                                                   gxvalid );
   }
 
 
   FT_LOCAL_DEF( void )
   gxv_morx_subtable_type5_validate( FT_Bytes       table,
                                     FT_Bytes       limit,
-                                    GXV_Validator  valid )
+                                    GXV_Validator  gxvalid )
   {
     FT_Bytes  p = table;
 
@@ -205,18 +205,18 @@
 
     GXV_LIMIT_CHECK( GXV_MORX_SUBTABLE_TYPE5_HEADER_SIZE );
 
-    valid->xstatetable.optdata =
+    gxvalid->xstatetable.optdata =
       et;
-    valid->xstatetable.optdata_load_func =
+    gxvalid->xstatetable.optdata_load_func =
       gxv_morx_subtable_type5_insertionGlyphList_load;
-    valid->xstatetable.subtable_setup_func =
+    gxvalid->xstatetable.subtable_setup_func =
       gxv_morx_subtable_type5_subtable_setup;
-    valid->xstatetable.entry_glyphoffset_fmt =
+    gxvalid->xstatetable.entry_glyphoffset_fmt =
       GXV_GLYPHOFFSET_ULONG;
-    valid->xstatetable.entry_validate_func =
+    gxvalid->xstatetable.entry_validate_func =
       gxv_morx_subtable_type5_entry_validate;
 
-    gxv_XStateTable_validate( p, limit, valid );
+    gxv_XStateTable_validate( p, limit, gxvalid );
 
     GXV_EXIT;
   }
diff --git a/src/gxvalid/gxvopbd.c b/src/gxvalid/gxvopbd.c
index e125060..ab0cd72 100644
--- a/src/gxvalid/gxvopbd.c
+++ b/src/gxvalid/gxvopbd.c
@@ -68,11 +68,11 @@
   static void
   gxv_opbd_LookupValue_validate( FT_UShort            glyph,
                                  GXV_LookupValueCPtr  value_p,
-                                 GXV_Validator        valid )
+                                 GXV_Validator        gxvalid )
   {
     /* offset in LookupTable is measured from the head of opbd table */
-    FT_Bytes   p     = valid->root->base + value_p->u;
-    FT_Bytes   limit = valid->root->limit;
+    FT_Bytes   p     = gxvalid->root->base + value_p->u;
+    FT_Bytes   limit = gxvalid->root->limit;
     FT_Short   delta_value;
     int        i;
 
@@ -90,7 +90,7 @@
         if ( delta_value == -1 )
           continue;
 
-        gxv_ctlPoint_validate( glyph, delta_value, valid );
+        gxv_ctlPoint_validate( glyph, delta_value, gxvalid );
       }
       else                              /* format 0, value is distance */
         continue;
@@ -134,12 +134,12 @@
   gxv_opbd_LookupFmt4_transit( FT_UShort            relative_gindex,
                                GXV_LookupValueCPtr  base_value_p,
                                FT_Bytes             lookuptbl_limit,
-                               GXV_Validator        valid )
+                               GXV_Validator        gxvalid )
   {
     GXV_LookupValueDesc  value;
 
     FT_UNUSED( lookuptbl_limit );
-    FT_UNUSED( valid );
+    FT_UNUSED( gxvalid );
 
     /* XXX: check range? */
     value.u = (FT_UShort)( base_value_p->u +
@@ -162,8 +162,8 @@
                      FT_Face       face,
                      FT_Validator  ftvalid )
   {
-    GXV_ValidatorRec  validrec;
-    GXV_Validator     valid = &validrec;
+    GXV_ValidatorRec  gxvalidrec;
+    GXV_Validator     gxvalid = &gxvalidrec;
     GXV_opbd_DataRec  opbdrec;
     GXV_opbd_Data     opbd  = &opbdrec;
     FT_Bytes          p     = table;
@@ -172,9 +172,9 @@
     FT_ULong  version;
 
 
-    valid->root       = ftvalid;
-    valid->table_data = opbd;
-    valid->face       = face;
+    gxvalid->root       = ftvalid;
+    gxvalid->table_data = opbd;
+    gxvalid->face       = face;
 
     FT_TRACE3(( "validating `opbd' table\n" ));
     GXV_INIT;
@@ -196,12 +196,12 @@
     if ( 0x0001 < GXV_OPBD_DATA( format ) )
       FT_INVALID_FORMAT;
 
-    valid->lookupval_sign   = GXV_LOOKUPVALUE_UNSIGNED;
-    valid->lookupval_func   = gxv_opbd_LookupValue_validate;
-    valid->lookupfmt4_trans = gxv_opbd_LookupFmt4_transit;
+    gxvalid->lookupval_sign   = GXV_LOOKUPVALUE_UNSIGNED;
+    gxvalid->lookupval_func   = gxv_opbd_LookupValue_validate;
+    gxvalid->lookupfmt4_trans = gxv_opbd_LookupFmt4_transit;
 
-    gxv_LookupTable_validate( p, limit, valid );
-    p += valid->subtable_length;
+    gxv_LookupTable_validate( p, limit, gxvalid );
+    p += gxvalid->subtable_length;
 
     if ( p > table + GXV_OPBD_DATA( valueOffset_min ) )
     {
diff --git a/src/gxvalid/gxvprop.c b/src/gxvalid/gxvprop.c
index 0be2133..aa5c8ee 100644
--- a/src/gxvalid/gxvprop.c
+++ b/src/gxvalid/gxvprop.c
@@ -75,7 +75,7 @@
 
   static void
   gxv_prop_zero_advance_validate( FT_UShort      gid,
-                                  GXV_Validator  valid )
+                                  GXV_Validator  gxvalid )
   {
     FT_Face       face;
     FT_Error      error;
@@ -84,7 +84,7 @@
 
     GXV_NAME_ENTER( "zero advance" );
 
-    face = valid->face;
+    face = gxvalid->face;
 
     error = FT_Load_Glyph( face,
                            gid,
@@ -109,10 +109,10 @@
   static void
   gxv_prop_property_validate( FT_UShort      property,
                               FT_UShort      glyph,
-                              GXV_Validator  valid )
+                              GXV_Validator  gxvalid )
   {
     if ( glyph != 0 && ( property & GXV_PROP_FLOATER ) )
-      gxv_prop_zero_advance_validate( glyph, valid );
+      gxv_prop_zero_advance_validate( glyph, gxvalid );
 
     if ( property & GXV_PROP_USE_COMPLEMENTARY_BRACKET )
     {
@@ -145,7 +145,7 @@
       else
       {
         /* The gid for complement must be the face. */
-        gxv_glyphid_validate( (FT_UShort)( glyph + complement ), valid );
+        gxv_glyphid_validate( (FT_UShort)( glyph + complement ), gxvalid );
       }
     }
     else
@@ -187,9 +187,9 @@
   static void
   gxv_prop_LookupValue_validate( FT_UShort            glyph,
                                  GXV_LookupValueCPtr  value_p,
-                                 GXV_Validator        valid )
+                                 GXV_Validator        gxvalid )
   {
-    gxv_prop_property_validate( value_p->u, glyph, valid );
+    gxv_prop_property_validate( value_p->u, glyph, gxvalid );
   }
 
 
@@ -224,7 +224,7 @@
   gxv_prop_LookupFmt4_transit( FT_UShort            relative_gindex,
                                GXV_LookupValueCPtr  base_value_p,
                                FT_Bytes             lookuptbl_limit,
-                               GXV_Validator        valid )
+                               GXV_Validator        gxvalid )
   {
     FT_Bytes             p;
     FT_Bytes             limit;
@@ -234,7 +234,7 @@
     /* XXX: check range? */
     offset = (FT_UShort)( base_value_p->u +
                           relative_gindex * sizeof ( FT_UShort ) );
-    p      = valid->lookuptbl_head + offset;
+    p      = gxvalid->lookuptbl_head + offset;
     limit  = lookuptbl_limit;
 
     GXV_LIMIT_CHECK ( 2 );
@@ -259,8 +259,8 @@
   {
     FT_Bytes          p     = table;
     FT_Bytes          limit = 0;
-    GXV_ValidatorRec  validrec;
-    GXV_Validator     valid = &validrec;
+    GXV_ValidatorRec  gxvalidrec;
+    GXV_Validator     gxvalid = &gxvalidrec;
 
     GXV_prop_DataRec  proprec;
     GXV_prop_Data     prop = &proprec;
@@ -270,9 +270,9 @@
     FT_UShort         defaultProp;
 
 
-    valid->root       = ftvalid;
-    valid->table_data = prop;
-    valid->face       = face;
+    gxvalid->root       = ftvalid;
+    gxvalid->table_data = prop;
+    gxvalid->face       = face;
 
     FT_TRACE3(( "validating `prop' table\n" ));
     GXV_INIT;
@@ -303,7 +303,7 @@
       FT_INVALID_FORMAT;
     }
 
-    gxv_prop_property_validate( defaultProp, 0, valid );
+    gxv_prop_property_validate( defaultProp, 0, gxvalid );
 
     if ( format == 0 )
     {
@@ -315,11 +315,11 @@
     /* format == 1 */
     GXV_PROP_DATA( version ) = version;
 
-    valid->lookupval_sign   = GXV_LOOKUPVALUE_UNSIGNED;
-    valid->lookupval_func   = gxv_prop_LookupValue_validate;
-    valid->lookupfmt4_trans = gxv_prop_LookupFmt4_transit;
+    gxvalid->lookupval_sign   = GXV_LOOKUPVALUE_UNSIGNED;
+    gxvalid->lookupval_func   = gxv_prop_LookupValue_validate;
+    gxvalid->lookupfmt4_trans = gxv_prop_LookupFmt4_transit;
 
-    gxv_LookupTable_validate( p, limit, valid );
+    gxv_LookupTable_validate( p, limit, gxvalid );
 
   Exit:
     FT_TRACE4(( "\n" ));
diff --git a/src/gxvalid/gxvtrak.c b/src/gxvalid/gxvtrak.c
index 11fbd7c..3ec1a56 100644
--- a/src/gxvalid/gxvtrak.c
+++ b/src/gxvalid/gxvtrak.c
@@ -93,9 +93,9 @@
   gxv_trak_trackTable_validate( FT_Bytes       table,
                                 FT_Bytes       limit,
                                 FT_UShort      nTracks,
-                                GXV_Validator  valid )
+                                GXV_Validator  gxvalid )
   {
-    FT_Bytes   p = table;
+    FT_Bytes  p = table;
 
     FT_Fixed   track, t;
     FT_UShort  nameIndex;
@@ -122,7 +122,7 @@
       if ( offset > GXV_TRAK_DATA( trackValueOffset_max ) )
         GXV_TRAK_DATA( trackValueOffset_max ) = offset;
 
-      gxv_sfntName_validate( nameIndex, 256, 32767, valid );
+      gxv_sfntName_validate( nameIndex, 256, 32767, gxvalid );
 
       for ( j = i; j < nTracks; j ++ )
       {
@@ -134,7 +134,7 @@
       }
     }
 
-    valid->subtable_length = p - table;
+    gxvalid->subtable_length = p - table;
     GXV_EXIT;
   }
 
@@ -142,7 +142,7 @@
   static void
   gxv_trak_trackData_validate( FT_Bytes       table,
                                FT_Bytes       limit,
-                               GXV_Validator  valid )
+                               GXV_Validator  gxvalid )
   {
     FT_Bytes   p = table;
     FT_UShort  nTracks;
@@ -164,31 +164,31 @@
     gxv_odtect_add_range( table, p - table, "trackData header", odtect );
 
     /* validate trackTable */
-    gxv_trak_trackTable_validate( p, limit, nTracks, valid );
-    gxv_odtect_add_range( p, valid->subtable_length,
+    gxv_trak_trackTable_validate( p, limit, nTracks, gxvalid );
+    gxv_odtect_add_range( p, gxvalid->subtable_length,
                           "trackTable", odtect );
 
     /* sizeTable is array of FT_Fixed, don't check contents */
-    p = valid->root->base + sizeTableOffset;
+    p = gxvalid->root->base + sizeTableOffset;
     GXV_LIMIT_CHECK( nSizes * 4 );
     gxv_odtect_add_range( p, nSizes * 4, "sizeTable", odtect );
 
     /* validate trackValueOffet */
-    p = valid->root->base + GXV_TRAK_DATA( trackValueOffset_min );
+    p = gxvalid->root->base + GXV_TRAK_DATA( trackValueOffset_min );
     if ( limit - p < nTracks * nSizes * 2 )
       GXV_TRACE(( "too short trackValue array\n" ));
 
-    p = valid->root->base + GXV_TRAK_DATA( trackValueOffset_max );
+    p = gxvalid->root->base + GXV_TRAK_DATA( trackValueOffset_max );
     GXV_LIMIT_CHECK( nSizes * 2 );
 
-    gxv_odtect_add_range( valid->root->base
+    gxv_odtect_add_range( gxvalid->root->base
                             + GXV_TRAK_DATA( trackValueOffset_min ),
                           GXV_TRAK_DATA( trackValueOffset_max )
                             - GXV_TRAK_DATA( trackValueOffset_min )
                             + nSizes * 2,
                           "trackValue array", odtect );
 
-    gxv_odtect_validate( odtect, valid );
+    gxv_odtect_validate( odtect, gxvalid );
 
     GXV_EXIT;
   }
@@ -210,8 +210,8 @@
     FT_Bytes          p = table;
     FT_Bytes          limit = 0;
 
-    GXV_ValidatorRec  validrec;
-    GXV_Validator     valid = &validrec;
+    GXV_ValidatorRec  gxvalidrec;
+    GXV_Validator     gxvalid = &gxvalidrec;
     GXV_trak_DataRec  trakrec;
     GXV_trak_Data     trak = &trakrec;
 
@@ -225,11 +225,11 @@
     GXV_ODTECT( 3, odtect );
 
     GXV_ODTECT_INIT( odtect );
-    valid->root       = ftvalid;
-    valid->table_data = trak;
-    valid->face       = face;
+    gxvalid->root       = ftvalid;
+    gxvalid->table_data = trak;
+    gxvalid->face       = face;
 
-    limit      = valid->root->limit;
+    limit      = gxvalid->root->limit;
 
     FT_TRACE3(( "validating `trak' table\n" ));
     GXV_INIT;
@@ -265,19 +265,19 @@
     /* validate trackData */
     if ( 0 < horizOffset )
     {
-      gxv_trak_trackData_validate( table + horizOffset, limit, valid );
-      gxv_odtect_add_range( table + horizOffset, valid->subtable_length,
+      gxv_trak_trackData_validate( table + horizOffset, limit, gxvalid );
+      gxv_odtect_add_range( table + horizOffset, gxvalid->subtable_length,
                             "horizJustData", odtect );
     }
 
     if ( 0 < vertOffset )
     {
-      gxv_trak_trackData_validate( table + vertOffset, limit, valid );
-      gxv_odtect_add_range( table + vertOffset, valid->subtable_length,
+      gxv_trak_trackData_validate( table + vertOffset, limit, gxvalid );
+      gxv_odtect_add_range( table + vertOffset, gxvalid->subtable_length,
                             "vertJustData", odtect );
     }
 
-    gxv_odtect_validate( odtect, valid );
+    gxv_odtect_validate( odtect, gxvalid );
 
     FT_TRACE4(( "\n" ));
   }
diff --git a/src/gzip/ftgzip.c b/src/gzip/ftgzip.c
index 83be22b..2d4200d 100644
--- a/src/gzip/ftgzip.c
+++ b/src/gzip/ftgzip.c
@@ -208,8 +208,8 @@
 
     /* head[0] && head[1] are the magic numbers;    */
     /* head[2] is the method, and head[3] the flags */
-    if ( head[0] != 0x1f              ||
-         head[1] != 0x8b              ||
+    if ( head[0] != 0x1F              ||
+         head[1] != 0x8B              ||
          head[2] != Z_DEFLATED        ||
         (head[3] & FT_GZIP_RESERVED)  )
     {
diff --git a/src/lzw/ftlzw.c b/src/lzw/ftlzw.c
index 6092626..e1b3564 100644
--- a/src/lzw/ftlzw.c
+++ b/src/lzw/ftlzw.c
@@ -96,8 +96,8 @@
       goto Exit;
 
     /* head[0] && head[1] are the magic numbers */
-    if ( head[0] != 0x1f ||
-         head[1] != 0x9d )
+    if ( head[0] != 0x1F ||
+         head[1] != 0x9D )
       error = FT_THROW( Invalid_File_Format );
 
   Exit:
diff --git a/src/lzw/ftzopen.h b/src/lzw/ftzopen.h
index f7d2936..cdc8fd7 100644
--- a/src/lzw/ftzopen.h
+++ b/src/lzw/ftzopen.h
@@ -41,7 +41,7 @@
 #define LZW_CLEAR         256
 #define LZW_FIRST         257
 
-#define LZW_BIT_MASK      0x1f
+#define LZW_BIT_MASK      0x1F
 #define LZW_BLOCK_MASK    0x80
 #define LZW_MASK( n )     ( ( 1U << (n) ) - 1U )
 
diff --git a/src/otvalid/otvbase.c b/src/otvalid/otvbase.c
index d742d2d..4f9d2fa 100644
--- a/src/otvalid/otvbase.c
+++ b/src/otvalid/otvbase.c
@@ -32,7 +32,7 @@
 
   static void
   otv_BaseCoord_validate( FT_Bytes       table,
-                          OTV_Validator  valid )
+                          OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   BaseCoordFormat;
@@ -58,7 +58,7 @@
     case 3:     /* BaseCoordFormat3 */
       OTV_LIMIT_CHECK( 2 );
       /* DeviceTable */
-      otv_Device_validate( table + FT_NEXT_USHORT( p ), valid );
+      otv_Device_validate( table + FT_NEXT_USHORT( p ), otvalid );
       break;
 
     default:
@@ -71,7 +71,7 @@
 
   static void
   otv_BaseTagList_validate( FT_Bytes       table,
-                            OTV_Validator  valid )
+                            OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   BaseTagCount;
@@ -93,7 +93,7 @@
 
   static void
   otv_BaseValues_validate( FT_Bytes       table,
-                           OTV_Validator  valid )
+                           OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   BaseCoordCount;
@@ -112,7 +112,7 @@
 
     /* BaseCoord */
     for ( ; BaseCoordCount > 0; BaseCoordCount-- )
-      otv_BaseCoord_validate( table + FT_NEXT_USHORT( p ), valid );
+      otv_BaseCoord_validate( table + FT_NEXT_USHORT( p ), otvalid );
 
     OTV_EXIT;
   }
@@ -120,7 +120,7 @@
 
   static void
   otv_MinMax_validate( FT_Bytes       table,
-                       OTV_Validator  valid )
+                       OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   table_size;
@@ -144,11 +144,11 @@
 
     OTV_SIZE_CHECK( MinCoord );
     if ( MinCoord )
-      otv_BaseCoord_validate( table + MinCoord, valid );
+      otv_BaseCoord_validate( table + MinCoord, otvalid );
 
     OTV_SIZE_CHECK( MaxCoord );
     if ( MaxCoord )
-      otv_BaseCoord_validate( table + MaxCoord, valid );
+      otv_BaseCoord_validate( table + MaxCoord, otvalid );
 
     OTV_LIMIT_CHECK( FeatMinMaxCount * 8 );
 
@@ -162,11 +162,11 @@
 
       OTV_SIZE_CHECK( MinCoord );
       if ( MinCoord )
-        otv_BaseCoord_validate( table + MinCoord, valid );
+        otv_BaseCoord_validate( table + MinCoord, otvalid );
 
       OTV_SIZE_CHECK( MaxCoord );
       if ( MaxCoord )
-        otv_BaseCoord_validate( table + MaxCoord, valid );
+        otv_BaseCoord_validate( table + MaxCoord, otvalid );
     }
 
     OTV_EXIT;
@@ -175,7 +175,7 @@
 
   static void
   otv_BaseScript_validate( FT_Bytes       table,
-                           OTV_Validator  valid )
+                           OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   table_size;
@@ -198,11 +198,11 @@
 
     OTV_SIZE_CHECK( BaseValues );
     if ( BaseValues )
-      otv_BaseValues_validate( table + BaseValues, valid );
+      otv_BaseValues_validate( table + BaseValues, otvalid );
 
     OTV_SIZE_CHECK( DefaultMinMax );
     if ( DefaultMinMax )
-      otv_MinMax_validate( table + DefaultMinMax, valid );
+      otv_MinMax_validate( table + DefaultMinMax, otvalid );
 
     OTV_LIMIT_CHECK( BaseLangSysCount * 6 );
 
@@ -211,7 +211,7 @@
     {
       p += 4;       /* skip BaseLangSysTag */
 
-      otv_MinMax_validate( table + FT_NEXT_USHORT( p ), valid );
+      otv_MinMax_validate( table + FT_NEXT_USHORT( p ), otvalid );
     }
 
     OTV_EXIT;
@@ -220,7 +220,7 @@
 
   static void
   otv_BaseScriptList_validate( FT_Bytes       table,
-                               OTV_Validator  valid )
+                               OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   BaseScriptCount;
@@ -241,7 +241,7 @@
       p += 4;       /* skip BaseScriptTag */
 
       /* BaseScript */
-      otv_BaseScript_validate( table + FT_NEXT_USHORT( p ), valid );
+      otv_BaseScript_validate( table + FT_NEXT_USHORT( p ), otvalid );
     }
 
     OTV_EXIT;
@@ -250,7 +250,7 @@
 
   static void
   otv_Axis_validate( FT_Bytes       table,
-                     OTV_Validator  valid )
+                     OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   table_size;
@@ -267,10 +267,10 @@
 
     OTV_SIZE_CHECK( BaseTagList );
     if ( BaseTagList )
-      otv_BaseTagList_validate( table + BaseTagList, valid );
+      otv_BaseTagList_validate( table + BaseTagList, otvalid );
 
     /* BaseScriptList */
-    otv_BaseScriptList_validate( table + FT_NEXT_USHORT( p ), valid );
+    otv_BaseScriptList_validate( table + FT_NEXT_USHORT( p ), otvalid );
 
     OTV_EXIT;
   }
@@ -280,16 +280,16 @@
   otv_BASE_validate( FT_Bytes      table,
                      FT_Validator  ftvalid )
   {
-    OTV_ValidatorRec  validrec;
-    OTV_Validator     valid = &validrec;
-    FT_Bytes          p     = table;
+    OTV_ValidatorRec  otvalidrec;
+    OTV_Validator     otvalid = &otvalidrec;
+    FT_Bytes          p       = table;
     FT_UInt           table_size;
 
     OTV_OPTIONAL_TABLE( HorizAxis );
     OTV_OPTIONAL_TABLE( VertAxis  );
 
 
-    valid->root = ftvalid;
+    otvalid->root = ftvalid;
 
     FT_TRACE3(( "validating BASE table\n" ));
     OTV_INIT;
@@ -304,12 +304,12 @@
     OTV_OPTIONAL_OFFSET( HorizAxis );
     OTV_SIZE_CHECK( HorizAxis );
     if ( HorizAxis )
-      otv_Axis_validate( table + HorizAxis, valid );
+      otv_Axis_validate( table + HorizAxis, otvalid );
 
     OTV_OPTIONAL_OFFSET( VertAxis );
     OTV_SIZE_CHECK( VertAxis );
     if ( VertAxis )
-      otv_Axis_validate( table + VertAxis, valid );
+      otv_Axis_validate( table + VertAxis, otvalid );
 
     FT_TRACE4(( "\n" ));
   }
diff --git a/src/otvalid/otvcommn.c b/src/otvalid/otvcommn.c
index a4f885b..3c3de63 100644
--- a/src/otvalid/otvcommn.c
+++ b/src/otvalid/otvcommn.c
@@ -39,7 +39,7 @@
 
   FT_LOCAL_DEF( void )
   otv_Coverage_validate( FT_Bytes       table,
-                         OTV_Validator  valid,
+                         OTV_Validator  otvalid,
                          FT_Int         expected_count )
   {
     FT_Bytes  p = table;
@@ -74,7 +74,7 @@
 
 
           gid = FT_NEXT_USHORT( p );
-          if ( gid >= valid->glyph_count )
+          if ( gid >= otvalid->glyph_count )
             FT_INVALID_GLYPH_ID;
         }
 
@@ -104,7 +104,7 @@
           if ( Start > End || StartCoverageIndex != total )
             FT_INVALID_DATA;
 
-          if ( End >= valid->glyph_count )
+          if ( End >= otvalid->glyph_count )
             FT_INVALID_GLYPH_ID;
 
           if ( n > 0 && Start <= last )
@@ -219,7 +219,7 @@
 
   FT_LOCAL_DEF( void )
   otv_ClassDef_validate( FT_Bytes       table,
-                         OTV_Validator  valid )
+                         OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   ClassFormat;
@@ -249,7 +249,7 @@
 
         OTV_LIMIT_CHECK( GlyphCount * 2 );    /* ClassValueArray */
 
-        if ( StartGlyph + GlyphCount - 1 >= valid->glyph_count )
+        if ( StartGlyph + GlyphCount - 1 >= otvalid->glyph_count )
           FT_INVALID_GLYPH_ID;
       }
       break;
@@ -276,7 +276,7 @@
           if ( Start > End || ( n > 0 && Start <= last ) )
             FT_INVALID_DATA;
 
-          if ( End >= valid->glyph_count )
+          if ( End >= otvalid->glyph_count )
             FT_INVALID_GLYPH_ID;
 
           last = End;
@@ -305,7 +305,7 @@
 
   FT_LOCAL_DEF( void )
   otv_Device_validate( FT_Bytes       table,
-                       OTV_Validator  valid )
+                       OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   StartSize, EndSize, DeltaFormat, count;
@@ -339,12 +339,12 @@
   /*************************************************************************/
   /*************************************************************************/
 
-  /* uses valid->type_count */
-  /* uses valid->type_funcs */
+  /* uses otvalid->type_count */
+  /* uses otvalid->type_funcs */
 
   FT_LOCAL_DEF( void )
   otv_Lookup_validate( FT_Bytes       table,
-                       OTV_Validator  valid )
+                       OTV_Validator  otvalid )
   {
     FT_Bytes           p = table;
     FT_UInt            LookupType, SubTableCount;
@@ -360,10 +360,10 @@
 
     OTV_TRACE(( " (type %d)\n", LookupType ));
 
-    if ( LookupType == 0 || LookupType > valid->type_count )
+    if ( LookupType == 0 || LookupType > otvalid->type_count )
       FT_INVALID_DATA;
 
-    validate = valid->type_funcs[LookupType - 1];
+    validate = otvalid->type_funcs[LookupType - 1];
 
     OTV_TRACE(( " (SubTableCount = %d)\n", SubTableCount ));
 
@@ -371,7 +371,7 @@
 
     /* SubTable */
     for ( ; SubTableCount > 0; SubTableCount-- )
-      validate( table + FT_NEXT_USHORT( p ), valid );
+      validate( table + FT_NEXT_USHORT( p ), otvalid );
 
     OTV_EXIT;
   }
@@ -381,7 +381,7 @@
 
   FT_LOCAL_DEF( void )
   otv_LookupList_validate( FT_Bytes       table,
-                           OTV_Validator  valid )
+                           OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   LookupCount;
@@ -396,11 +396,11 @@
 
     OTV_LIMIT_CHECK( LookupCount * 2 );
 
-    valid->lookup_count = LookupCount;
+    otvalid->lookup_count = LookupCount;
 
     /* Lookup */
     for ( ; LookupCount > 0; LookupCount-- )
-      otv_Lookup_validate( table + FT_NEXT_USHORT( p ), valid );
+      otv_Lookup_validate( table + FT_NEXT_USHORT( p ), otvalid );
 
     OTV_EXIT;
   }
@@ -421,11 +421,11 @@
   /*************************************************************************/
   /*************************************************************************/
 
-  /* uses valid->lookup_count */
+  /* uses otvalid->lookup_count */
 
   FT_LOCAL_DEF( void )
   otv_Feature_validate( FT_Bytes       table,
-                        OTV_Validator  valid )
+                        OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   LookupCount;
@@ -443,7 +443,7 @@
 
     /* LookupListIndex */
     for ( ; LookupCount > 0; LookupCount-- )
-      if ( FT_NEXT_USHORT( p ) >= valid->lookup_count )
+      if ( FT_NEXT_USHORT( p ) >= otvalid->lookup_count )
         FT_INVALID_DATA;
 
     OTV_EXIT;
@@ -457,12 +457,12 @@
   }
 
 
-  /* sets valid->lookup_count */
+  /* sets otvalid->lookup_count */
 
   FT_LOCAL_DEF( void )
   otv_FeatureList_validate( FT_Bytes       table,
                             FT_Bytes       lookups,
-                            OTV_Validator  valid )
+                            OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   FeatureCount;
@@ -477,7 +477,7 @@
 
     OTV_LIMIT_CHECK( FeatureCount * 2 );
 
-    valid->lookup_count = otv_LookupList_get_count( lookups );
+    otvalid->lookup_count = otv_LookupList_get_count( lookups );
 
     /* FeatureRecord */
     for ( ; FeatureCount > 0; FeatureCount-- )
@@ -485,7 +485,7 @@
       p += 4;       /* skip FeatureTag */
 
       /* Feature */
-      otv_Feature_validate( table + FT_NEXT_USHORT( p ), valid );
+      otv_Feature_validate( table + FT_NEXT_USHORT( p ), otvalid );
     }
 
     OTV_EXIT;
@@ -501,11 +501,11 @@
   /*************************************************************************/
 
 
-  /* uses valid->extra1 (number of features) */
+  /* uses otvalid->extra1 (number of features) */
 
   FT_LOCAL_DEF( void )
   otv_LangSys_validate( FT_Bytes       table,
-                        OTV_Validator  valid )
+                        OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   ReqFeatureIndex;
@@ -522,14 +522,14 @@
     OTV_TRACE(( " (ReqFeatureIndex = %d)\n", ReqFeatureIndex ));
     OTV_TRACE(( " (FeatureCount = %d)\n",    FeatureCount    ));
 
-    if ( ReqFeatureIndex != 0xFFFFU && ReqFeatureIndex >= valid->extra1 )
+    if ( ReqFeatureIndex != 0xFFFFU && ReqFeatureIndex >= otvalid->extra1 )
       FT_INVALID_DATA;
 
     OTV_LIMIT_CHECK( FeatureCount * 2 );
 
     /* FeatureIndex */
     for ( ; FeatureCount > 0; FeatureCount-- )
-      if ( FT_NEXT_USHORT( p ) >= valid->extra1 )
+      if ( FT_NEXT_USHORT( p ) >= otvalid->extra1 )
         FT_INVALID_DATA;
 
     OTV_EXIT;
@@ -546,7 +546,7 @@
 
   FT_LOCAL_DEF( void )
   otv_Script_validate( FT_Bytes       table,
-                       OTV_Validator  valid )
+                       OTV_Validator  otvalid )
   {
     FT_UInt   DefaultLangSys, LangSysCount;
     FT_Bytes  p = table;
@@ -561,7 +561,7 @@
     OTV_TRACE(( " (LangSysCount = %d)\n", LangSysCount ));
 
     if ( DefaultLangSys != 0 )
-      otv_LangSys_validate( table + DefaultLangSys, valid );
+      otv_LangSys_validate( table + DefaultLangSys, otvalid );
 
     OTV_LIMIT_CHECK( LangSysCount * 6 );
 
@@ -571,19 +571,19 @@
       p += 4;       /* skip LangSysTag */
 
       /* LangSys */
-      otv_LangSys_validate( table + FT_NEXT_USHORT( p ), valid );
+      otv_LangSys_validate( table + FT_NEXT_USHORT( p ), otvalid );
     }
 
     OTV_EXIT;
   }
 
 
-  /* sets valid->extra1 (number of features) */
+  /* sets otvalid->extra1 (number of features) */
 
   FT_LOCAL_DEF( void )
   otv_ScriptList_validate( FT_Bytes       table,
                            FT_Bytes       features,
-                           OTV_Validator  valid )
+                           OTV_Validator  otvalid )
   {
     FT_UInt   ScriptCount;
     FT_Bytes  p = table;
@@ -598,14 +598,14 @@
 
     OTV_LIMIT_CHECK( ScriptCount * 6 );
 
-    valid->extra1 = otv_Feature_get_count( features );
+    otvalid->extra1 = otv_Feature_get_count( features );
 
     /* ScriptRecord */
     for ( ; ScriptCount > 0; ScriptCount-- )
     {
       p += 4;       /* skip ScriptTag */
 
-      otv_Script_validate( table + FT_NEXT_USHORT( p ), valid ); /* Script */
+      otv_Script_validate( table + FT_NEXT_USHORT( p ), otvalid ); /* Script */
     }
 
     OTV_EXIT;
@@ -640,7 +640,7 @@
 
   FT_LOCAL_DEF( void )
   otv_x_Ox( FT_Bytes       table,
-            OTV_Validator  valid )
+            OTV_Validator  otvalid )
   {
     FT_Bytes           p = table;
     FT_UInt            Count;
@@ -656,13 +656,13 @@
 
     OTV_LIMIT_CHECK( Count * 2 );
 
-    valid->nesting_level++;
-    func = valid->func[valid->nesting_level];
+    otvalid->nesting_level++;
+    func = otvalid->func[otvalid->nesting_level];
 
     for ( ; Count > 0; Count-- )
-      func( table + FT_NEXT_USHORT( p ), valid );
+      func( table + FT_NEXT_USHORT( p ), otvalid );
 
-    valid->nesting_level--;
+    otvalid->nesting_level--;
 
     OTV_EXIT;
   }
@@ -670,7 +670,7 @@
 
   FT_LOCAL_DEF( void )
   otv_u_C_x_Ox( FT_Bytes       table,
-                OTV_Validator  valid )
+                OTV_Validator  otvalid )
   {
     FT_Bytes           p = table;
     FT_UInt            Count, Coverage;
@@ -687,27 +687,27 @@
 
     OTV_TRACE(( " (Count = %d)\n", Count ));
 
-    otv_Coverage_validate( table + Coverage, valid, Count );
+    otv_Coverage_validate( table + Coverage, otvalid, Count );
 
     OTV_LIMIT_CHECK( Count * 2 );
 
-    valid->nesting_level++;
-    func = valid->func[valid->nesting_level];
+    otvalid->nesting_level++;
+    func = otvalid->func[otvalid->nesting_level];
 
     for ( ; Count > 0; Count-- )
-      func( table + FT_NEXT_USHORT( p ), valid );
+      func( table + FT_NEXT_USHORT( p ), otvalid );
 
-    valid->nesting_level--;
+    otvalid->nesting_level--;
 
     OTV_EXIT;
   }
 
 
-  /* uses valid->extra1 (if > 0: array value limit) */
+  /* uses otvalid->extra1 (if > 0: array value limit) */
 
   FT_LOCAL_DEF( void )
   otv_x_ux( FT_Bytes       table,
-            OTV_Validator  valid )
+            OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   Count;
@@ -722,10 +722,10 @@
 
     OTV_LIMIT_CHECK( Count * 2 );
 
-    if ( valid->extra1 )
+    if ( otvalid->extra1 )
     {
       for ( ; Count > 0; Count-- )
-        if ( FT_NEXT_USHORT( p ) >= valid->extra1 )
+        if ( FT_NEXT_USHORT( p ) >= otvalid->extra1 )
           FT_INVALID_DATA;
     }
 
@@ -736,11 +736,11 @@
   /* `ux' in the function's name is not really correct since only x-1 */
   /* elements are tested                                              */
 
-  /* uses valid->extra1 (array value limit) */
+  /* uses otvalid->extra1 (array value limit) */
 
   FT_LOCAL_DEF( void )
   otv_x_y_ux_sy( FT_Bytes       table,
-                 OTV_Validator  valid )
+                 OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   Count1, Count2;
@@ -766,7 +766,7 @@
       if ( FT_NEXT_USHORT( p ) >= Count1 )
         FT_INVALID_DATA;
 
-      if ( FT_NEXT_USHORT( p ) >= valid->extra1 )
+      if ( FT_NEXT_USHORT( p ) >= otvalid->extra1 )
         FT_INVALID_DATA;
     }
 
@@ -777,11 +777,11 @@
   /* `uy' in the function's name is not really correct since only y-1 */
   /* elements are tested                                              */
 
-  /* uses valid->extra1 (array value limit) */
+  /* uses otvalid->extra1 (array value limit) */
 
   FT_LOCAL_DEF( void )
   otv_x_ux_y_uy_z_uz_p_sp( FT_Bytes       table,
-                           OTV_Validator  valid )
+                           OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   BacktrackCount, InputCount, LookaheadCount;
@@ -825,7 +825,7 @@
       if ( FT_NEXT_USHORT( p ) >= InputCount )
         FT_INVALID_DATA;
 
-      if ( FT_NEXT_USHORT( p ) >= valid->extra1 )
+      if ( FT_NEXT_USHORT( p ) >= otvalid->extra1 )
         FT_INVALID_DATA;
     }
 
@@ -833,11 +833,11 @@
   }
 
 
-  /* sets valid->extra1 (valid->lookup_count) */
+  /* sets otvalid->extra1 (valid->lookup_count) */
 
   FT_LOCAL_DEF( void )
   otv_u_O_O_x_Onx( FT_Bytes       table,
-                   OTV_Validator  valid )
+                   OTV_Validator  otvalid )
   {
     FT_Bytes           p = table;
     FT_UInt            Coverage, ClassDef, ClassSetCount;
@@ -855,14 +855,14 @@
 
     OTV_TRACE(( " (ClassSetCount = %d)\n", ClassSetCount ));
 
-    otv_Coverage_validate( table + Coverage, valid, -1 );
-    otv_ClassDef_validate( table + ClassDef, valid );
+    otv_Coverage_validate( table + Coverage, otvalid, -1 );
+    otv_ClassDef_validate( table + ClassDef, otvalid );
 
     OTV_LIMIT_CHECK( ClassSetCount * 2 );
 
-    valid->nesting_level++;
-    func          = valid->func[valid->nesting_level];
-    valid->extra1 = valid->lookup_count;
+    otvalid->nesting_level++;
+    func          = otvalid->func[otvalid->nesting_level];
+    otvalid->extra1 = otvalid->lookup_count;
 
     for ( ; ClassSetCount > 0; ClassSetCount-- )
     {
@@ -870,20 +870,20 @@
 
 
       if ( offset )
-        func( table + offset, valid );
+        func( table + offset, otvalid );
     }
 
-    valid->nesting_level--;
+    otvalid->nesting_level--;
 
     OTV_EXIT;
   }
 
 
-  /* uses valid->lookup_count */
+  /* uses otvalid->lookup_count */
 
   FT_LOCAL_DEF( void )
   otv_u_x_y_Ox_sy( FT_Bytes       table,
-                   OTV_Validator  valid )
+                   OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   GlyphCount, Count, count1;
@@ -903,14 +903,14 @@
     OTV_LIMIT_CHECK( GlyphCount * 2 + Count * 4 );
 
     for ( count1 = GlyphCount; count1 > 0; count1-- )
-      otv_Coverage_validate( table + FT_NEXT_USHORT( p ), valid, -1 );
+      otv_Coverage_validate( table + FT_NEXT_USHORT( p ), otvalid, -1 );
 
     for ( ; Count > 0; Count-- )
     {
       if ( FT_NEXT_USHORT( p ) >= GlyphCount )
         FT_INVALID_DATA;
 
-      if ( FT_NEXT_USHORT( p ) >= valid->lookup_count )
+      if ( FT_NEXT_USHORT( p ) >= otvalid->lookup_count )
         FT_INVALID_DATA;
     }
 
@@ -918,11 +918,11 @@
   }
 
 
-  /* sets valid->extra1 (valid->lookup_count)    */
+  /* sets otvalid->extra1 (valid->lookup_count)    */
 
   FT_LOCAL_DEF( void )
   otv_u_O_O_O_O_x_Onx( FT_Bytes       table,
-                       OTV_Validator  valid )
+                       OTV_Validator  otvalid )
   {
     FT_Bytes           p = table;
     FT_UInt            Coverage;
@@ -944,17 +944,17 @@
 
     OTV_TRACE(( " (ChainClassSetCount = %d)\n", ChainClassSetCount ));
 
-    otv_Coverage_validate( table + Coverage, valid, -1 );
+    otv_Coverage_validate( table + Coverage, otvalid, -1 );
 
-    otv_ClassDef_validate( table + BacktrackClassDef,  valid );
-    otv_ClassDef_validate( table + InputClassDef, valid );
-    otv_ClassDef_validate( table + LookaheadClassDef, valid );
+    otv_ClassDef_validate( table + BacktrackClassDef,  otvalid );
+    otv_ClassDef_validate( table + InputClassDef, otvalid );
+    otv_ClassDef_validate( table + LookaheadClassDef, otvalid );
 
     OTV_LIMIT_CHECK( ChainClassSetCount * 2 );
 
-    valid->nesting_level++;
-    func          = valid->func[valid->nesting_level];
-    valid->extra1 = valid->lookup_count;
+    otvalid->nesting_level++;
+    func          = otvalid->func[otvalid->nesting_level];
+    otvalid->extra1 = otvalid->lookup_count;
 
     for ( ; ChainClassSetCount > 0; ChainClassSetCount-- )
     {
@@ -962,20 +962,20 @@
 
 
       if ( offset )
-        func( table + offset, valid );
+        func( table + offset, otvalid );
     }
 
-    valid->nesting_level--;
+    otvalid->nesting_level--;
 
     OTV_EXIT;
   }
 
 
-  /* uses valid->lookup_count */
+  /* uses otvalid->lookup_count */
 
   FT_LOCAL_DEF( void )
   otv_u_x_Ox_y_Oy_z_Oz_p_sp( FT_Bytes       table,
-                             OTV_Validator  valid )
+                             OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   BacktrackGlyphCount, InputGlyphCount, LookaheadGlyphCount;
@@ -994,7 +994,7 @@
     OTV_LIMIT_CHECK( BacktrackGlyphCount * 2 + 2 );
 
     for ( ; BacktrackGlyphCount > 0; BacktrackGlyphCount-- )
-      otv_Coverage_validate( table + FT_NEXT_USHORT( p ), valid, -1 );
+      otv_Coverage_validate( table + FT_NEXT_USHORT( p ), otvalid, -1 );
 
     InputGlyphCount = FT_NEXT_USHORT( p );
 
@@ -1003,7 +1003,7 @@
     OTV_LIMIT_CHECK( InputGlyphCount * 2 + 2 );
 
     for ( count1 = InputGlyphCount; count1 > 0; count1-- )
-      otv_Coverage_validate( table + FT_NEXT_USHORT( p ), valid, -1 );
+      otv_Coverage_validate( table + FT_NEXT_USHORT( p ), otvalid, -1 );
 
     LookaheadGlyphCount = FT_NEXT_USHORT( p );
 
@@ -1012,7 +1012,7 @@
     OTV_LIMIT_CHECK( LookaheadGlyphCount * 2 + 2 );
 
     for ( ; LookaheadGlyphCount > 0; LookaheadGlyphCount-- )
-      otv_Coverage_validate( table + FT_NEXT_USHORT( p ), valid, -1 );
+      otv_Coverage_validate( table + FT_NEXT_USHORT( p ), otvalid, -1 );
 
     count2 = FT_NEXT_USHORT( p );
 
@@ -1025,7 +1025,7 @@
       if ( FT_NEXT_USHORT( p ) >= InputGlyphCount )
         FT_INVALID_DATA;
 
-      if ( FT_NEXT_USHORT( p ) >= valid->lookup_count )
+      if ( FT_NEXT_USHORT( p ) >= otvalid->lookup_count )
         FT_INVALID_DATA;
     }
 
diff --git a/src/otvalid/otvcommn.h b/src/otvalid/otvcommn.h
index 898887f..5c93ba7 100644
--- a/src/otvalid/otvcommn.h
+++ b/src/otvalid/otvcommn.h
@@ -4,7 +4,7 @@
 /*                                                                         */
 /*    OpenType common tables validation (specification).                   */
 /*                                                                         */
-/*  Copyright 2004, 2005, 2007, 2009 by                                    */
+/*  Copyright 2004, 2005, 2007, 2009, 2014 by                              */
 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
 /*                                                                         */
 /*  This file is part of the FreeType project, and may only be used,       */
@@ -39,7 +39,7 @@ FT_BEGIN_HEADER
   typedef struct OTV_ValidatorRec_*  OTV_Validator;
 
   typedef void  (*OTV_Validate_Func)( FT_Bytes       table,
-                                      OTV_Validator  valid );
+                                      OTV_Validator  otvalid );
 
   typedef struct  OTV_ValidatorRec_
   {
@@ -67,8 +67,8 @@ FT_BEGIN_HEADER
 
 
 #undef  FT_INVALID_
-#define FT_INVALID_( _prefix, _error )                         \
-          ft_validator_error( valid->root, _prefix ## _error )
+#define FT_INVALID_( _error ) \
+          ft_validator_error( otvalid->root, FT_THROW( _error ) )
 
 #define OTV_OPTIONAL_TABLE( _table )  FT_UShort  _table;      \
                                       FT_Bytes   _table ## _p
@@ -81,7 +81,7 @@ FT_BEGIN_HEADER
 
 #define OTV_LIMIT_CHECK( _count )                    \
           FT_BEGIN_STMNT                             \
-            if ( p + (_count) > valid->root->limit ) \
+            if ( p + (_count) > otvalid->root->limit ) \
               FT_INVALID_TOO_SHORT;                  \
           FT_END_STMNT
 
@@ -89,7 +89,7 @@ FT_BEGIN_HEADER
           FT_BEGIN_STMNT                                            \
             if ( _size > 0 && _size < table_size )                  \
             {                                                       \
-              if ( valid->root->level == FT_VALIDATE_PARANOID )     \
+              if ( otvalid->root->level == FT_VALIDATE_PARANOID )     \
                 FT_INVALID_OFFSET;                                  \
               else                                                  \
               {                                                     \
@@ -117,79 +117,79 @@ FT_BEGIN_HEADER
 
 #ifdef FT_DEBUG_LEVEL_TRACE
 
-#define OTV_NEST1( x )                                     \
-          FT_BEGIN_STMNT                                   \
-            valid->nesting_level          = 0;             \
-            valid->func[0]                = OTV_FUNC( x ); \
-            valid->debug_function_name[0] = OTV_NAME( x ); \
+#define OTV_NEST1( x )                                       \
+          FT_BEGIN_STMNT                                     \
+            otvalid->nesting_level          = 0;             \
+            otvalid->func[0]                = OTV_FUNC( x ); \
+            otvalid->debug_function_name[0] = OTV_NAME( x ); \
           FT_END_STMNT
 
-#define OTV_NEST2( x, y )                                  \
-          FT_BEGIN_STMNT                                   \
-            valid->nesting_level          = 0;             \
-            valid->func[0]                = OTV_FUNC( x ); \
-            valid->func[1]                = OTV_FUNC( y ); \
-            valid->debug_function_name[0] = OTV_NAME( x ); \
-            valid->debug_function_name[1] = OTV_NAME( y ); \
+#define OTV_NEST2( x, y )                                    \
+          FT_BEGIN_STMNT                                     \
+            otvalid->nesting_level          = 0;             \
+            otvalid->func[0]                = OTV_FUNC( x ); \
+            otvalid->func[1]                = OTV_FUNC( y ); \
+            otvalid->debug_function_name[0] = OTV_NAME( x ); \
+            otvalid->debug_function_name[1] = OTV_NAME( y ); \
           FT_END_STMNT
 
-#define OTV_NEST3( x, y, z )                               \
-          FT_BEGIN_STMNT                                   \
-            valid->nesting_level          = 0;             \
-            valid->func[0]                = OTV_FUNC( x ); \
-            valid->func[1]                = OTV_FUNC( y ); \
-            valid->func[2]                = OTV_FUNC( z ); \
-            valid->debug_function_name[0] = OTV_NAME( x ); \
-            valid->debug_function_name[1] = OTV_NAME( y ); \
-            valid->debug_function_name[2] = OTV_NAME( z ); \
+#define OTV_NEST3( x, y, z )                                 \
+          FT_BEGIN_STMNT                                     \
+            otvalid->nesting_level          = 0;             \
+            otvalid->func[0]                = OTV_FUNC( x ); \
+            otvalid->func[1]                = OTV_FUNC( y ); \
+            otvalid->func[2]                = OTV_FUNC( z ); \
+            otvalid->debug_function_name[0] = OTV_NAME( x ); \
+            otvalid->debug_function_name[1] = OTV_NAME( y ); \
+            otvalid->debug_function_name[2] = OTV_NAME( z ); \
           FT_END_STMNT
 
-#define OTV_INIT  valid->debug_indent = 0
+#define OTV_INIT  otvalid->debug_indent = 0
 
-#define OTV_ENTER                                                            \
-          FT_BEGIN_STMNT                                                     \
-            valid->debug_indent += 2;                                        \
-            FT_TRACE4(( "%*.s", valid->debug_indent, 0 ));                   \
-            FT_TRACE4(( "%s table\n",                                        \
-                        valid->debug_function_name[valid->nesting_level] )); \
+#define OTV_ENTER                                                              \
+          FT_BEGIN_STMNT                                                       \
+            otvalid->debug_indent += 2;                                        \
+            FT_TRACE4(( "%*.s", otvalid->debug_indent, 0 ));                   \
+            FT_TRACE4(( "%s table\n",                                          \
+                        otvalid->debug_function_name[otvalid->nesting_level] )); \
           FT_END_STMNT
 
-#define OTV_NAME_ENTER( name )                             \
-          FT_BEGIN_STMNT                                   \
-            valid->debug_indent += 2;                      \
-            FT_TRACE4(( "%*.s", valid->debug_indent, 0 )); \
-            FT_TRACE4(( "%s table\n", name ));             \
+#define OTV_NAME_ENTER( name )                               \
+          FT_BEGIN_STMNT                                     \
+            otvalid->debug_indent += 2;                      \
+            FT_TRACE4(( "%*.s", otvalid->debug_indent, 0 )); \
+            FT_TRACE4(( "%s table\n", name ));               \
           FT_END_STMNT
 
-#define OTV_EXIT  valid->debug_indent -= 2
+#define OTV_EXIT  otvalid->debug_indent -= 2
 
-#define OTV_TRACE( s )                                     \
-          FT_BEGIN_STMNT                                   \
-            FT_TRACE4(( "%*.s", valid->debug_indent, 0 )); \
-            FT_TRACE4( s );                                \
+#define OTV_TRACE( s )                                       \
+          FT_BEGIN_STMNT                                     \
+            FT_TRACE4(( "%*.s", otvalid->debug_indent, 0 )); \
+            FT_TRACE4( s );                                  \
           FT_END_STMNT
 
 #else   /* !FT_DEBUG_LEVEL_TRACE */
 
-#define OTV_NEST1( x )                            \
-          FT_BEGIN_STMNT                          \
-            valid->nesting_level = 0;             \
-            valid->func[0]       = OTV_FUNC( x ); \
+#define OTV_NEST1( x )                              \
+          FT_BEGIN_STMNT                            \
+            otvalid->nesting_level = 0;             \
+            otvalid->func[0]       = OTV_FUNC( x ); \
           FT_END_STMNT
 
-#define OTV_NEST2( x, y )                         \
-          FT_BEGIN_STMNT                          \
-            valid->nesting_level = 0;             \
-            valid->func[0]       = OTV_FUNC( x ); \
-            valid->func[1]       = OTV_FUNC( y ); \
+#define OTV_NEST2( x, y )                           \
+          FT_BEGIN_STMNT                            \
+            otvalid->nesting_level = 0;             \
+            otvalid->func[0]       = OTV_FUNC( x ); \
+            otvalid->func[1]       = OTV_FUNC( y ); \
           FT_END_STMNT
 
-#define OTV_NEST3( x, y, z )                      \
-          FT_BEGIN_STMNT                          \
-            valid->nesting_level = 0;             \
-            valid->func[0]       = OTV_FUNC( x ); \
-            valid->func[1]       = OTV_FUNC( y ); \
-            valid->func[2]       = OTV_FUNC( z ); \
+#define OTV_NEST3( x, y, z )                        \
+          FT_BEGIN_STMNT                            \
+            otvalid->nesting_level = 0;             \
+            otvalid->func[0]       = OTV_FUNC( x ); \
+            otvalid->func[1]       = OTV_FUNC( y ); \
+            otvalid->func[2]       = OTV_FUNC( z ); \
           FT_END_STMNT
 
 #define OTV_INIT                do { } while ( 0 )
@@ -202,7 +202,7 @@ FT_BEGIN_HEADER
 #endif  /* !FT_DEBUG_LEVEL_TRACE */
 
 
-#define OTV_RUN  valid->func[0]
+#define OTV_RUN  otvalid->func[0]
 
 
   /*************************************************************************/
@@ -215,7 +215,7 @@ FT_BEGIN_HEADER
 
   FT_LOCAL( void )
   otv_Coverage_validate( FT_Bytes       table,
-                         OTV_Validator  valid,
+                         OTV_Validator  otvalid,
                          FT_Int         expected_count );
 
   /* return first covered glyph */
@@ -241,7 +241,7 @@ FT_BEGIN_HEADER
 
   FT_LOCAL( void )
   otv_ClassDef_validate( FT_Bytes       table,
-                         OTV_Validator  valid );
+                         OTV_Validator  otvalid );
 
 
   /*************************************************************************/
@@ -254,7 +254,7 @@ FT_BEGIN_HEADER
 
   FT_LOCAL( void )
   otv_Device_validate( FT_Bytes       table,
-                       OTV_Validator  valid );
+                       OTV_Validator  otvalid );
 
 
   /*************************************************************************/
@@ -267,11 +267,11 @@ FT_BEGIN_HEADER
 
   FT_LOCAL( void )
   otv_Lookup_validate( FT_Bytes       table,
-                       OTV_Validator  valid );
+                       OTV_Validator  otvalid );
 
   FT_LOCAL( void )
   otv_LookupList_validate( FT_Bytes       table,
-                           OTV_Validator  valid );
+                           OTV_Validator  otvalid );
 
 
   /*************************************************************************/
@@ -284,13 +284,13 @@ FT_BEGIN_HEADER
 
   FT_LOCAL( void )
   otv_Feature_validate( FT_Bytes       table,
-                        OTV_Validator  valid );
+                        OTV_Validator  otvalid );
 
   /* lookups must already be validated */
   FT_LOCAL( void )
   otv_FeatureList_validate( FT_Bytes       table,
                             FT_Bytes       lookups,
-                            OTV_Validator  valid );
+                            OTV_Validator  otvalid );
 
 
   /*************************************************************************/
@@ -303,7 +303,7 @@ FT_BEGIN_HEADER
 
   FT_LOCAL( void )
   otv_LangSys_validate( FT_Bytes       table,
-                        OTV_Validator  valid );
+                        OTV_Validator  otvalid );
 
 
   /*************************************************************************/
@@ -316,13 +316,13 @@ FT_BEGIN_HEADER
 
   FT_LOCAL( void )
   otv_Script_validate( FT_Bytes       table,
-                       OTV_Validator  valid );
+                       OTV_Validator  otvalid );
 
   /* features must already be validated */
   FT_LOCAL( void )
   otv_ScriptList_validate( FT_Bytes       table,
                            FT_Bytes       features,
-                           OTV_Validator  valid );
+                           OTV_Validator  otvalid );
 
 
   /*************************************************************************/
@@ -349,7 +349,7 @@ FT_BEGIN_HEADER
 
   FT_LOCAL( void )
   otv_x_Ox ( FT_Bytes       table,
-             OTV_Validator  valid );
+             OTV_Validator  otvalid );
 
 #define AlternateSubstFormat1Func     otv_u_C_x_Ox
 #define ChainContextPosFormat1Func    otv_u_C_x_Ox
@@ -361,7 +361,7 @@ FT_BEGIN_HEADER
 
   FT_LOCAL( void )
   otv_u_C_x_Ox( FT_Bytes       table,
-                OTV_Validator  valid );
+                OTV_Validator  otvalid );
 
 #define AlternateSetFunc     otv_x_ux
 #define AttachPointFunc      otv_x_ux
@@ -372,7 +372,7 @@ FT_BEGIN_HEADER
 
   FT_LOCAL( void )
   otv_x_ux( FT_Bytes       table,
-            OTV_Validator  valid );
+            OTV_Validator  otvalid );
 
 #define PosClassRuleFunc  otv_x_y_ux_sy
 #define PosRuleFunc       otv_x_y_ux_sy
@@ -381,7 +381,7 @@ FT_BEGIN_HEADER
 
   FT_LOCAL( void )
   otv_x_y_ux_sy( FT_Bytes       table,
-                 OTV_Validator  valid );
+                 OTV_Validator  otvalid );
 
 #define ChainPosClassRuleFunc  otv_x_ux_y_uy_z_uz_p_sp
 #define ChainPosRuleFunc       otv_x_ux_y_uy_z_uz_p_sp
@@ -390,35 +390,35 @@ FT_BEGIN_HEADER
 
   FT_LOCAL( void )
   otv_x_ux_y_uy_z_uz_p_sp( FT_Bytes       table,
-                           OTV_Validator  valid );
+                           OTV_Validator  otvalid );
 
 #define ContextPosFormat2Func    otv_u_O_O_x_Onx
 #define ContextSubstFormat2Func  otv_u_O_O_x_Onx
 
   FT_LOCAL( void )
   otv_u_O_O_x_Onx( FT_Bytes       table,
-                   OTV_Validator  valid );
+                   OTV_Validator  otvalid );
 
 #define ContextPosFormat3Func    otv_u_x_y_Ox_sy
 #define ContextSubstFormat3Func  otv_u_x_y_Ox_sy
 
   FT_LOCAL( void )
   otv_u_x_y_Ox_sy( FT_Bytes       table,
-                   OTV_Validator  valid );
+                   OTV_Validator  otvalid );
 
 #define ChainContextPosFormat2Func    otv_u_O_O_O_O_x_Onx
 #define ChainContextSubstFormat2Func  otv_u_O_O_O_O_x_Onx
 
   FT_LOCAL( void )
   otv_u_O_O_O_O_x_Onx( FT_Bytes       table,
-                       OTV_Validator  valid );
+                       OTV_Validator  otvalid );
 
 #define ChainContextPosFormat3Func    otv_u_x_Ox_y_Oy_z_Oz_p_sp
 #define ChainContextSubstFormat3Func  otv_u_x_Ox_y_Oy_z_Oz_p_sp
 
   FT_LOCAL( void )
   otv_u_x_Ox_y_Oy_z_Oz_p_sp( FT_Bytes       table,
-                             OTV_Validator  valid );
+                             OTV_Validator  otvalid );
 
 
   FT_LOCAL( FT_UInt )
diff --git a/src/otvalid/otvgdef.c b/src/otvalid/otvgdef.c
index 3633ad0..e60ef36 100644
--- a/src/otvalid/otvgdef.c
+++ b/src/otvalid/otvgdef.c
@@ -45,7 +45,7 @@
 
   static void
   otv_O_x_Ox( FT_Bytes       table,
-              OTV_Validator  valid )
+              OTV_Validator  otvalid )
   {
     FT_Bytes           p = table;
     FT_Bytes           Coverage;
@@ -61,20 +61,20 @@
 
     OTV_TRACE(( " (GlyphCount = %d)\n", GlyphCount ));
 
-    otv_Coverage_validate( Coverage, valid, GlyphCount );
+    otv_Coverage_validate( Coverage, otvalid, GlyphCount );
     if ( GlyphCount != otv_Coverage_get_count( Coverage ) )
       FT_INVALID_DATA;
 
     OTV_LIMIT_CHECK( GlyphCount * 2 );
 
-    valid->nesting_level++;
-    func          = valid->func[valid->nesting_level];
-    valid->extra1 = 0;
+    otvalid->nesting_level++;
+    func          = otvalid->func[otvalid->nesting_level];
+    otvalid->extra1 = 0;
 
     for ( ; GlyphCount > 0; GlyphCount-- )
-      func( table + FT_NEXT_USHORT( p ), valid );
+      func( table + FT_NEXT_USHORT( p ), otvalid );
 
-    valid->nesting_level--;
+    otvalid->nesting_level--;
 
     OTV_EXIT;
   }
@@ -92,7 +92,7 @@
 
   static void
   otv_CaretValue_validate( FT_Bytes       table,
-                           OTV_Validator  valid )
+                           OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   CaretValueFormat;
@@ -122,7 +122,7 @@
       OTV_LIMIT_CHECK( 2 );
 
       /* DeviceTable */
-      otv_Device_validate( table + FT_NEXT_USHORT( p ), valid );
+      otv_Device_validate( table + FT_NEXT_USHORT( p ), otvalid );
       break;
 
     default:
@@ -141,7 +141,7 @@
   /*************************************************************************/
   /*************************************************************************/
 
-  /* sets valid->glyph_count */
+  /* sets otvalid->glyph_count */
 
   FT_LOCAL_DEF( void )
   otv_GDEF_validate( FT_Bytes      table,
@@ -150,8 +150,8 @@
                      FT_UInt       glyph_count,
                      FT_Validator  ftvalid )
   {
-    OTV_ValidatorRec  validrec;
-    OTV_Validator     valid = &validrec;
+    OTV_ValidatorRec  otvalidrec;
+    OTV_Validator     otvalid = &otvalidrec;
     FT_Bytes          p     = table;
     FT_UInt           table_size;
     FT_Bool           need_MarkAttachClassDef;
@@ -162,7 +162,7 @@
     OTV_OPTIONAL_TABLE( MarkAttachClassDef );
 
 
-    valid->root = ftvalid;
+    otvalid->root = ftvalid;
 
     FT_TRACE3(( "validating GDEF table\n" ));
     OTV_INIT;
@@ -186,19 +186,19 @@
     else
       table_size = 10;              /* OpenType < 1.2  */
 
-    valid->glyph_count = glyph_count;
+    otvalid->glyph_count = glyph_count;
 
     OTV_OPTIONAL_OFFSET( GlyphClassDef );
     OTV_SIZE_CHECK( GlyphClassDef );
     if ( GlyphClassDef )
-      otv_ClassDef_validate( table + GlyphClassDef, valid );
+      otv_ClassDef_validate( table + GlyphClassDef, otvalid );
 
     OTV_OPTIONAL_OFFSET( AttachListOffset );
     OTV_SIZE_CHECK( AttachListOffset );
     if ( AttachListOffset )
     {
       OTV_NEST2( AttachList, AttachPoint );
-      OTV_RUN( table + AttachListOffset, valid );
+      OTV_RUN( table + AttachListOffset, otvalid );
     }
 
     OTV_OPTIONAL_OFFSET( LigCaretListOffset );
@@ -206,7 +206,7 @@
     if ( LigCaretListOffset )
     {
       OTV_NEST3( LigCaretList, LigGlyph, CaretValue );
-      OTV_RUN( table + LigCaretListOffset, valid );
+      OTV_RUN( table + LigCaretListOffset, otvalid );
     }
 
     if ( need_MarkAttachClassDef )
@@ -214,7 +214,7 @@
       OTV_OPTIONAL_OFFSET( MarkAttachClassDef );
       OTV_SIZE_CHECK( MarkAttachClassDef );
       if ( MarkAttachClassDef )
-        otv_ClassDef_validate( table + MarkAttachClassDef, valid );
+        otv_ClassDef_validate( table + MarkAttachClassDef, otvalid );
     }
 
     FT_TRACE4(( "\n" ));
diff --git a/src/otvalid/otvgpos.c b/src/otvalid/otvgpos.c
index 49b4618..1a9dbaa 100644
--- a/src/otvalid/otvgpos.c
+++ b/src/otvalid/otvgpos.c
@@ -57,7 +57,7 @@
 
   static void
   otv_x_sxy( FT_Bytes       table,
-             OTV_Validator  valid )
+             OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   Count, count1, table_size;
@@ -71,26 +71,26 @@
 
     OTV_TRACE(( " (Count = %d)\n", Count ));
 
-    OTV_LIMIT_CHECK( Count * valid->extra1 * 2 );
+    OTV_LIMIT_CHECK( Count * otvalid->extra1 * 2 );
 
-    table_size = Count * valid->extra1 * 2 + 2;
+    table_size = Count * otvalid->extra1 * 2 + 2;
 
     for ( ; Count > 0; Count-- )
-      for ( count1 = valid->extra1; count1 > 0; count1-- )
+      for ( count1 = otvalid->extra1; count1 > 0; count1-- )
       {
         OTV_OPTIONAL_TABLE( anchor_offset );
 
 
         OTV_OPTIONAL_OFFSET( anchor_offset );
 
-        if ( valid->extra2 )
+        if ( otvalid->extra2 )
         {
           OTV_SIZE_CHECK( anchor_offset );
           if ( anchor_offset )
-            otv_Anchor_validate( table + anchor_offset, valid );
+            otv_Anchor_validate( table + anchor_offset, otvalid );
         }
         else
-          otv_Anchor_validate( table + anchor_offset, valid );
+          otv_Anchor_validate( table + anchor_offset, otvalid );
       }
 
     OTV_EXIT;
@@ -101,11 +101,11 @@
 #define MarkLigPosFormat1Func   otv_u_O_O_u_O_O
 #define MarkMarkPosFormat1Func  otv_u_O_O_u_O_O
 
-  /* sets valid->extra1 (class count) */
+  /* sets otvalid->extra1 (class count) */
 
   static void
   otv_u_O_O_u_O_O( FT_Bytes       table,
-                   OTV_Validator  valid )
+                   OTV_Validator  otvalid )
   {
     FT_Bytes           p = table;
     FT_UInt            Coverage1, Coverage2, ClassCount;
@@ -124,18 +124,18 @@
     Array1     = FT_NEXT_USHORT( p );
     Array2     = FT_NEXT_USHORT( p );
 
-    otv_Coverage_validate( table + Coverage1, valid, -1 );
-    otv_Coverage_validate( table + Coverage2, valid, -1 );
+    otv_Coverage_validate( table + Coverage1, otvalid, -1 );
+    otv_Coverage_validate( table + Coverage2, otvalid, -1 );
 
-    otv_MarkArray_validate( table + Array1, valid );
+    otv_MarkArray_validate( table + Array1, otvalid );
 
-    valid->nesting_level++;
-    func          = valid->func[valid->nesting_level];
-    valid->extra1 = ClassCount;
+    otvalid->nesting_level++;
+    func          = otvalid->func[otvalid->nesting_level];
+    otvalid->extra1 = ClassCount;
 
-    func( table + Array2, valid );
+    func( table + Array2, otvalid );
 
-    valid->nesting_level--;
+    otvalid->nesting_level--;
 
     OTV_EXIT;
   }
@@ -163,12 +163,12 @@
   }
 
 
-  /* uses valid->extra3 (pointer to base table) */
+  /* uses otvalid->extra3 (pointer to base table) */
 
   static void
   otv_ValueRecord_validate( FT_Bytes       table,
                             FT_UInt        format,
-                            OTV_Validator  valid )
+                            OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   count;
@@ -222,11 +222,11 @@
         /* ValueRecord is part of an array -- getting the correct table    */
         /* size is probably not worth the trouble                          */
 
-        table_size = p - valid->extra3;
+        table_size = p - otvalid->extra3;
 
         OTV_SIZE_CHECK( device );
         if ( device )
-          otv_Device_validate( valid->extra3 + device, valid );
+          otv_Device_validate( otvalid->extra3 + device, otvalid );
       }
       format >>= 1;
     }
@@ -245,7 +245,7 @@
 
   static void
   otv_Anchor_validate( FT_Bytes       table,
-                       OTV_Validator  valid )
+                       OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   AnchorFormat;
@@ -285,11 +285,11 @@
 
         OTV_SIZE_CHECK( XDeviceTable );
         if ( XDeviceTable )
-          otv_Device_validate( table + XDeviceTable, valid );
+          otv_Device_validate( table + XDeviceTable, otvalid );
 
         OTV_SIZE_CHECK( YDeviceTable );
         if ( YDeviceTable )
-          otv_Device_validate( table + YDeviceTable, valid );
+          otv_Device_validate( table + YDeviceTable, otvalid );
       }
       break;
 
@@ -311,7 +311,7 @@
 
   static void
   otv_MarkArray_validate( FT_Bytes       table,
-                          OTV_Validator  valid )
+                          OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   MarkCount;
@@ -331,7 +331,7 @@
     {
       p += 2;   /* skip Class */
       /* MarkAnchor */
-      otv_Anchor_validate( table + FT_NEXT_USHORT( p ), valid );
+      otv_Anchor_validate( table + FT_NEXT_USHORT( p ), otvalid );
     }
 
     OTV_EXIT;
@@ -346,11 +346,11 @@
   /*************************************************************************/
   /*************************************************************************/
 
-  /* sets valid->extra3 (pointer to base table) */
+  /* sets otvalid->extra3 (pointer to base table) */
 
   static void
   otv_SinglePos_validate( FT_Bytes       table,
-                          OTV_Validator  valid )
+                          OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   PosFormat;
@@ -363,7 +363,7 @@
 
     OTV_TRACE(( " (format %d)\n", PosFormat ));
 
-    valid->extra3 = table;
+    otvalid->extra3 = table;
 
     switch ( PosFormat )
     {
@@ -376,8 +376,8 @@
         Coverage    = FT_NEXT_USHORT( p );
         ValueFormat = FT_NEXT_USHORT( p );
 
-        otv_Coverage_validate( table + Coverage, valid, -1 );
-        otv_ValueRecord_validate( p, ValueFormat, valid ); /* Value */
+        otv_Coverage_validate( table + Coverage, otvalid, -1 );
+        otv_ValueRecord_validate( p, ValueFormat, otvalid ); /* Value */
       }
       break;
 
@@ -395,14 +395,14 @@
 
         len_value = otv_value_length( ValueFormat );
 
-        otv_Coverage_validate( table + Coverage, valid, ValueCount );
+        otv_Coverage_validate( table + Coverage, otvalid, ValueCount );
 
         OTV_LIMIT_CHECK( ValueCount * len_value );
 
         /* Value */
         for ( ; ValueCount > 0; ValueCount-- )
         {
-          otv_ValueRecord_validate( p, ValueFormat, valid );
+          otv_ValueRecord_validate( p, ValueFormat, otvalid );
           p += len_value;
         }
       }
@@ -428,7 +428,7 @@
   otv_PairSet_validate( FT_Bytes       table,
                         FT_UInt        format1,
                         FT_UInt        format2,
-                        OTV_Validator  valid )
+                        OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   value_len1, value_len2, PairValueCount;
@@ -452,11 +452,11 @@
       p += 2;       /* skip SecondGlyph */
 
       if ( format1 )
-        otv_ValueRecord_validate( p, format1, valid ); /* Value1 */
+        otv_ValueRecord_validate( p, format1, otvalid ); /* Value1 */
       p += value_len1;
 
       if ( format2 )
-        otv_ValueRecord_validate( p, format2, valid ); /* Value2 */
+        otv_ValueRecord_validate( p, format2, otvalid ); /* Value2 */
       p += value_len2;
     }
 
@@ -464,11 +464,11 @@
   }
 
 
-  /* sets valid->extra3 (pointer to base table) */
+  /* sets otvalid->extra3 (pointer to base table) */
 
   static void
   otv_PairPos_validate( FT_Bytes       table,
-                        OTV_Validator  valid )
+                        OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   PosFormat;
@@ -481,7 +481,7 @@
 
     OTV_TRACE(( " (format %d)\n", PosFormat ));
 
-    valid->extra3 = table;
+    otvalid->extra3 = table;
 
     switch ( PosFormat )
     {
@@ -498,14 +498,14 @@
 
         OTV_TRACE(( " (PairSetCount = %d)\n", PairSetCount ));
 
-        otv_Coverage_validate( table + Coverage, valid, -1 );
+        otv_Coverage_validate( table + Coverage, otvalid, -1 );
 
         OTV_LIMIT_CHECK( PairSetCount * 2 );
 
         /* PairSetOffset */
         for ( ; PairSetCount > 0; PairSetCount-- )
           otv_PairSet_validate( table + FT_NEXT_USHORT( p ),
-                                ValueFormat1, ValueFormat2, valid );
+                                ValueFormat1, ValueFormat2, otvalid );
       }
       break;
 
@@ -530,9 +530,9 @@
         len_value1 = otv_value_length( ValueFormat1 );
         len_value2 = otv_value_length( ValueFormat2 );
 
-        otv_Coverage_validate( table + Coverage, valid, -1 );
-        otv_ClassDef_validate( table + ClassDef1, valid );
-        otv_ClassDef_validate( table + ClassDef2, valid );
+        otv_Coverage_validate( table + Coverage, otvalid, -1 );
+        otv_ClassDef_validate( table + ClassDef1, otvalid );
+        otv_ClassDef_validate( table + ClassDef2, otvalid );
 
         OTV_LIMIT_CHECK( ClassCount1 * ClassCount2 *
                      ( len_value1 + len_value2 ) );
@@ -545,12 +545,12 @@
           {
             if ( ValueFormat1 )
               /* Value1 */
-              otv_ValueRecord_validate( p, ValueFormat1, valid );
+              otv_ValueRecord_validate( p, ValueFormat1, otvalid );
             p += len_value1;
 
             if ( ValueFormat2 )
               /* Value2 */
-              otv_ValueRecord_validate( p, ValueFormat2, valid );
+              otv_ValueRecord_validate( p, ValueFormat2, otvalid );
             p += len_value2;
           }
         }
@@ -575,7 +575,7 @@
 
   static void
   otv_CursivePos_validate( FT_Bytes       table,
-                           OTV_Validator  valid )
+                           OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   PosFormat;
@@ -605,7 +605,7 @@
 
         OTV_TRACE(( " (EntryExitCount = %d)\n", EntryExitCount ));
 
-        otv_Coverage_validate( table + Coverage, valid, EntryExitCount );
+        otv_Coverage_validate( table + Coverage, otvalid, EntryExitCount );
 
         OTV_LIMIT_CHECK( EntryExitCount * 4 );
 
@@ -619,11 +619,11 @@
 
           OTV_SIZE_CHECK( EntryAnchor );
           if ( EntryAnchor )
-            otv_Anchor_validate( table + EntryAnchor, valid );
+            otv_Anchor_validate( table + EntryAnchor, otvalid );
 
           OTV_SIZE_CHECK( ExitAnchor );
           if ( ExitAnchor )
-            otv_Anchor_validate( table + ExitAnchor, valid );
+            otv_Anchor_validate( table + ExitAnchor, otvalid );
         }
       }
       break;
@@ -647,11 +647,11 @@
   /* UNDOCUMENTED (in OpenType 1.5):              */
   /* BaseRecord tables can contain NULL pointers. */
 
-  /* sets valid->extra2 (1) */
+  /* sets otvalid->extra2 (1) */
 
   static void
   otv_MarkBasePos_validate( FT_Bytes       table,
-                            OTV_Validator  valid )
+                            OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   PosFormat;
@@ -667,9 +667,9 @@
     switch ( PosFormat )
     {
     case 1:
-      valid->extra2 = 1;
+      otvalid->extra2 = 1;
       OTV_NEST2( MarkBasePosFormat1, BaseArray );
-      OTV_RUN( table, valid );
+      OTV_RUN( table, otvalid );
       break;
 
     default:
@@ -688,11 +688,11 @@
   /*************************************************************************/
   /*************************************************************************/
 
-  /* sets valid->extra2 (1) */
+  /* sets otvalid->extra2 (1) */
 
   static void
   otv_MarkLigPos_validate( FT_Bytes       table,
-                           OTV_Validator  valid )
+                           OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   PosFormat;
@@ -708,9 +708,9 @@
     switch ( PosFormat )
     {
     case 1:
-      valid->extra2 = 1;
+      otvalid->extra2 = 1;
       OTV_NEST3( MarkLigPosFormat1, LigatureArray, LigatureAttach );
-      OTV_RUN( table, valid );
+      OTV_RUN( table, otvalid );
       break;
 
     default:
@@ -729,11 +729,11 @@
   /*************************************************************************/
   /*************************************************************************/
 
-  /* sets valid->extra2 (0) */
+  /* sets otvalid->extra2 (0) */
 
   static void
   otv_MarkMarkPos_validate( FT_Bytes       table,
-                            OTV_Validator  valid )
+                            OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   PosFormat;
@@ -749,9 +749,9 @@
     switch ( PosFormat )
     {
     case 1:
-      valid->extra2 = 0;
+      otvalid->extra2 = 0;
       OTV_NEST2( MarkMarkPosFormat1, Mark2Array );
-      OTV_RUN( table, valid );
+      OTV_RUN( table, otvalid );
       break;
 
     default:
@@ -770,11 +770,11 @@
   /*************************************************************************/
   /*************************************************************************/
 
-  /* sets valid->extra1 (lookup count) */
+  /* sets otvalid->extra1 (lookup count) */
 
   static void
   otv_ContextPos_validate( FT_Bytes       table,
-                           OTV_Validator  valid )
+                           OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   PosFormat;
@@ -794,9 +794,9 @@
       /* context rules since even invalid glyph indices/classes return  */
       /* meaningful results                                             */
 
-      valid->extra1 = valid->lookup_count;
+      otvalid->extra1 = otvalid->lookup_count;
       OTV_NEST3( ContextPosFormat1, PosRuleSet, PosRule );
-      OTV_RUN( table, valid );
+      OTV_RUN( table, otvalid );
       break;
 
     case 2:
@@ -805,12 +805,12 @@
       /* meaningful results                                             */
 
       OTV_NEST3( ContextPosFormat2, PosClassSet, PosClassRule );
-      OTV_RUN( table, valid );
+      OTV_RUN( table, otvalid );
       break;
 
     case 3:
       OTV_NEST1( ContextPosFormat3 );
-      OTV_RUN( table, valid );
+      OTV_RUN( table, otvalid );
       break;
 
     default:
@@ -829,11 +829,11 @@
   /*************************************************************************/
   /*************************************************************************/
 
-  /* sets valid->extra1 (lookup count) */
+  /* sets otvalid->extra1 (lookup count) */
 
   static void
   otv_ChainContextPos_validate( FT_Bytes       table,
-                                OTV_Validator  valid )
+                                OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   PosFormat;
@@ -853,10 +853,10 @@
       /* context rules since even invalid glyph indices/classes return  */
       /* meaningful results                                             */
 
-      valid->extra1 = valid->lookup_count;
+      otvalid->extra1 = otvalid->lookup_count;
       OTV_NEST3( ChainContextPosFormat1,
                  ChainPosRuleSet, ChainPosRule );
-      OTV_RUN( table, valid );
+      OTV_RUN( table, otvalid );
       break;
 
     case 2:
@@ -866,12 +866,12 @@
 
       OTV_NEST3( ChainContextPosFormat2,
                  ChainPosClassSet, ChainPosClassRule );
-      OTV_RUN( table, valid );
+      OTV_RUN( table, otvalid );
       break;
 
     case 3:
       OTV_NEST1( ChainContextPosFormat3 );
-      OTV_RUN( table, valid );
+      OTV_RUN( table, otvalid );
       break;
 
     default:
@@ -890,11 +890,11 @@
   /*************************************************************************/
   /*************************************************************************/
 
-  /* uses valid->type_funcs */
+  /* uses otvalid->type_funcs */
 
   static void
   otv_ExtensionPos_validate( FT_Bytes       table,
-                             OTV_Validator  valid )
+                             OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   PosFormat;
@@ -923,8 +923,8 @@
         if ( ExtensionLookupType == 0 || ExtensionLookupType >= 9 )
           FT_INVALID_DATA;
 
-        validate = valid->type_funcs[ExtensionLookupType - 1];
-        validate( table + ExtensionOffset, valid );
+        validate = otvalid->type_funcs[ExtensionLookupType - 1];
+        validate( table + ExtensionOffset, otvalid );
       }
       break;
 
@@ -950,17 +950,17 @@
   };
 
 
-  /* sets valid->type_count */
-  /* sets valid->type_funcs */
+  /* sets otvalid->type_count */
+  /* sets otvalid->type_funcs */
 
   FT_LOCAL_DEF( void )
   otv_GPOS_subtable_validate( FT_Bytes       table,
-                              OTV_Validator  valid )
+                              OTV_Validator  otvalid )
   {
-    valid->type_count = 9;
-    valid->type_funcs = (OTV_Validate_Func*)otv_gpos_validate_funcs;
+    otvalid->type_count = 9;
+    otvalid->type_funcs = (OTV_Validate_Func*)otv_gpos_validate_funcs;
 
-    otv_Lookup_validate( table, valid );
+    otv_Lookup_validate( table, otvalid );
   }
 
 
@@ -972,7 +972,7 @@
   /*************************************************************************/
   /*************************************************************************/
 
-  /* sets valid->glyph_count */
+  /* sets otvalid->glyph_count */
 
   FT_LOCAL_DEF( void )
   otv_GPOS_validate( FT_Bytes      table,
@@ -980,12 +980,12 @@
                      FT_Validator  ftvalid )
   {
     OTV_ValidatorRec  validrec;
-    OTV_Validator     valid = &validrec;
+    OTV_Validator     otvalid = &validrec;
     FT_Bytes          p     = table;
     FT_UInt           ScriptList, FeatureList, LookupList;
 
 
-    valid->root = ftvalid;
+    otvalid->root = ftvalid;
 
     FT_TRACE3(( "validating GPOS table\n" ));
     OTV_INIT;
@@ -999,16 +999,16 @@
     FeatureList = FT_NEXT_USHORT( p );
     LookupList  = FT_NEXT_USHORT( p );
 
-    valid->type_count  = 9;
-    valid->type_funcs  = (OTV_Validate_Func*)otv_gpos_validate_funcs;
-    valid->glyph_count = glyph_count;
+    otvalid->type_count  = 9;
+    otvalid->type_funcs  = (OTV_Validate_Func*)otv_gpos_validate_funcs;
+    otvalid->glyph_count = glyph_count;
 
     otv_LookupList_validate( table + LookupList,
-                             valid );
+                             otvalid );
     otv_FeatureList_validate( table + FeatureList, table + LookupList,
-                              valid );
+                              otvalid );
     otv_ScriptList_validate( table + ScriptList, table + FeatureList,
-                             valid );
+                             otvalid );
 
     FT_TRACE4(( "\n" ));
   }
diff --git a/src/otvalid/otvgsub.c b/src/otvalid/otvgsub.c
index ed499d1..024b8ca 100644
--- a/src/otvalid/otvgsub.c
+++ b/src/otvalid/otvgsub.c
@@ -38,11 +38,11 @@
   /*************************************************************************/
   /*************************************************************************/
 
-  /* uses valid->glyph_count */
+  /* uses otvalid->glyph_count */
 
   static void
   otv_SingleSubst_validate( FT_Bytes       table,
-                            OTV_Validator  valid )
+                            OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   SubstFormat;
@@ -68,14 +68,14 @@
         Coverage     = table + FT_NEXT_USHORT( p );
         DeltaGlyphID = FT_NEXT_SHORT( p );
 
-        otv_Coverage_validate( Coverage, valid, -1 );
+        otv_Coverage_validate( Coverage, otvalid, -1 );
 
         idx = otv_Coverage_get_first( Coverage ) + DeltaGlyphID;
         if ( idx < 0 )
           FT_INVALID_DATA;
 
         idx = otv_Coverage_get_last( Coverage ) + DeltaGlyphID;
-        if ( (FT_UInt)idx >= valid->glyph_count )
+        if ( (FT_UInt)idx >= otvalid->glyph_count )
           FT_INVALID_DATA;
       }
       break;
@@ -91,13 +91,13 @@
 
         OTV_TRACE(( " (GlyphCount = %d)\n", GlyphCount ));
 
-        otv_Coverage_validate( table + Coverage, valid, GlyphCount );
+        otv_Coverage_validate( table + Coverage, otvalid, GlyphCount );
 
         OTV_LIMIT_CHECK( GlyphCount * 2 );
 
         /* Substitute */
         for ( ; GlyphCount > 0; GlyphCount-- )
-          if ( FT_NEXT_USHORT( p ) >= valid->glyph_count )
+          if ( FT_NEXT_USHORT( p ) >= otvalid->glyph_count )
             FT_INVALID_GLYPH_ID;
       }
       break;
@@ -118,11 +118,11 @@
   /*************************************************************************/
   /*************************************************************************/
 
-  /* sets valid->extra1 (glyph count) */
+  /* sets otvalid->extra1 (glyph count) */
 
   static void
   otv_MultipleSubst_validate( FT_Bytes       table,
-                              OTV_Validator  valid )
+                              OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   SubstFormat;
@@ -138,9 +138,9 @@
     switch ( SubstFormat )
     {
     case 1:
-      valid->extra1 = valid->glyph_count;
+      otvalid->extra1 = otvalid->glyph_count;
       OTV_NEST2( MultipleSubstFormat1, Sequence );
-      OTV_RUN( table, valid );
+      OTV_RUN( table, otvalid );
       break;
 
     default:
@@ -159,11 +159,11 @@
   /*************************************************************************/
   /*************************************************************************/
 
-  /* sets valid->extra1 (glyph count) */
+  /* sets otvalid->extra1 (glyph count) */
 
   static void
   otv_AlternateSubst_validate( FT_Bytes       table,
-                               OTV_Validator  valid )
+                               OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   SubstFormat;
@@ -179,9 +179,9 @@
     switch ( SubstFormat )
     {
     case 1:
-      valid->extra1 = valid->glyph_count;
+      otvalid->extra1 = otvalid->glyph_count;
       OTV_NEST2( AlternateSubstFormat1, AlternateSet );
-      OTV_RUN( table, valid );
+      OTV_RUN( table, otvalid );
       break;
 
     default:
@@ -202,11 +202,11 @@
 
 #define LigatureFunc  otv_Ligature_validate
 
-  /* uses valid->glyph_count */
+  /* uses otvalid->glyph_count */
 
   static void
   otv_Ligature_validate( FT_Bytes       table,
-                         OTV_Validator  valid )
+                         OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   LigatureGlyph, CompCount;
@@ -216,7 +216,7 @@
 
     OTV_LIMIT_CHECK( 4 );
     LigatureGlyph = FT_NEXT_USHORT( p );
-    if ( LigatureGlyph >= valid->glyph_count )
+    if ( LigatureGlyph >= otvalid->glyph_count )
       FT_INVALID_DATA;
 
     CompCount = FT_NEXT_USHORT( p );
@@ -238,7 +238,7 @@
 
   static void
   otv_LigatureSubst_validate( FT_Bytes       table,
-                              OTV_Validator  valid )
+                              OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   SubstFormat;
@@ -255,7 +255,7 @@
     {
     case 1:
       OTV_NEST3( LigatureSubstFormat1, LigatureSet, Ligature );
-      OTV_RUN( table, valid );
+      OTV_RUN( table, otvalid );
       break;
 
     default:
@@ -274,11 +274,11 @@
   /*************************************************************************/
   /*************************************************************************/
 
-  /* sets valid->extra1 (lookup count) */
+  /* sets otvalid->extra1 (lookup count) */
 
   static void
   otv_ContextSubst_validate( FT_Bytes       table,
-                             OTV_Validator  valid )
+                             OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   SubstFormat;
@@ -298,9 +298,9 @@
       /* context rules since even invalid glyph indices/classes return  */
       /* meaningful results                                             */
 
-      valid->extra1 = valid->lookup_count;
+      otvalid->extra1 = otvalid->lookup_count;
       OTV_NEST3( ContextSubstFormat1, SubRuleSet, SubRule );
-      OTV_RUN( table, valid );
+      OTV_RUN( table, otvalid );
       break;
 
     case 2:
@@ -309,12 +309,12 @@
       /* meaningful results                                             */
 
       OTV_NEST3( ContextSubstFormat2, SubClassSet, SubClassRule );
-      OTV_RUN( table, valid );
+      OTV_RUN( table, otvalid );
       break;
 
     case 3:
       OTV_NEST1( ContextSubstFormat3 );
-      OTV_RUN( table, valid );
+      OTV_RUN( table, otvalid );
       break;
 
     default:
@@ -333,11 +333,11 @@
   /*************************************************************************/
   /*************************************************************************/
 
-  /* sets valid->extra1 (lookup count)            */
+  /* sets otvalid->extra1 (lookup count)            */
 
   static void
   otv_ChainContextSubst_validate( FT_Bytes       table,
-                                  OTV_Validator  valid )
+                                  OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   SubstFormat;
@@ -357,10 +357,10 @@
       /* context rules since even invalid glyph indices/classes return  */
       /* meaningful results                                             */
 
-      valid->extra1 = valid->lookup_count;
+      otvalid->extra1 = otvalid->lookup_count;
       OTV_NEST3( ChainContextSubstFormat1,
                  ChainSubRuleSet, ChainSubRule );
-      OTV_RUN( table, valid );
+      OTV_RUN( table, otvalid );
       break;
 
     case 2:
@@ -370,12 +370,12 @@
 
       OTV_NEST3( ChainContextSubstFormat2,
                  ChainSubClassSet, ChainSubClassRule );
-      OTV_RUN( table, valid );
+      OTV_RUN( table, otvalid );
       break;
 
     case 3:
       OTV_NEST1( ChainContextSubstFormat3 );
-      OTV_RUN( table, valid );
+      OTV_RUN( table, otvalid );
       break;
 
     default:
@@ -394,11 +394,11 @@
   /*************************************************************************/
   /*************************************************************************/
 
-  /* uses valid->type_funcs */
+  /* uses otvalid->type_funcs */
 
   static void
   otv_ExtensionSubst_validate( FT_Bytes       table,
-                               OTV_Validator  valid )
+                               OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   SubstFormat;
@@ -429,8 +429,8 @@
              ExtensionLookupType > 8  )
           FT_INVALID_DATA;
 
-        validate = valid->type_funcs[ExtensionLookupType - 1];
-        validate( table + ExtensionOffset, valid );
+        validate = otvalid->type_funcs[ExtensionLookupType - 1];
+        validate( table + ExtensionOffset, otvalid );
       }
       break;
 
@@ -450,11 +450,11 @@
   /*************************************************************************/
   /*************************************************************************/
 
-  /* uses valid->glyph_count */
+  /* uses otvalid->glyph_count */
 
   static void
   otv_ReverseChainSingleSubst_validate( FT_Bytes       table,
-                                        OTV_Validator  valid )
+                                        OTV_Validator  otvalid )
   {
     FT_Bytes  p = table, Coverage;
     FT_UInt   SubstFormat;
@@ -477,12 +477,12 @@
 
       OTV_TRACE(( " (BacktrackGlyphCount = %d)\n", BacktrackGlyphCount ));
 
-      otv_Coverage_validate( Coverage, valid, -1 );
+      otv_Coverage_validate( Coverage, otvalid, -1 );
 
       OTV_LIMIT_CHECK( BacktrackGlyphCount * 2 + 2 );
 
       for ( ; BacktrackGlyphCount > 0; BacktrackGlyphCount-- )
-        otv_Coverage_validate( table + FT_NEXT_USHORT( p ), valid, -1 );
+        otv_Coverage_validate( table + FT_NEXT_USHORT( p ), otvalid, -1 );
 
       LookaheadGlyphCount = FT_NEXT_USHORT( p );
 
@@ -491,7 +491,7 @@
       OTV_LIMIT_CHECK( LookaheadGlyphCount * 2 + 2 );
 
       for ( ; LookaheadGlyphCount > 0; LookaheadGlyphCount-- )
-        otv_Coverage_validate( table + FT_NEXT_USHORT( p ), valid, -1 );
+        otv_Coverage_validate( table + FT_NEXT_USHORT( p ), otvalid, -1 );
 
       GlyphCount = FT_NEXT_USHORT( p );
 
@@ -504,7 +504,7 @@
 
       /* Substitute */
       for ( ; GlyphCount > 0; GlyphCount-- )
-        if ( FT_NEXT_USHORT( p ) >= valid->glyph_count )
+        if ( FT_NEXT_USHORT( p ) >= otvalid->glyph_count )
           FT_INVALID_DATA;
 
       break;
@@ -538,22 +538,22 @@
   /*************************************************************************/
   /*************************************************************************/
 
-  /* sets valid->type_count  */
-  /* sets valid->type_funcs  */
-  /* sets valid->glyph_count */
+  /* sets otvalid->type_count  */
+  /* sets otvalid->type_funcs  */
+  /* sets otvalid->glyph_count */
 
   FT_LOCAL_DEF( void )
   otv_GSUB_validate( FT_Bytes      table,
                      FT_UInt       glyph_count,
                      FT_Validator  ftvalid )
   {
-    OTV_ValidatorRec  validrec;
-    OTV_Validator     valid = &validrec;
-    FT_Bytes          p     = table;
+    OTV_ValidatorRec  otvalidrec;
+    OTV_Validator     otvalid = &otvalidrec;
+    FT_Bytes          p       = table;
     FT_UInt           ScriptList, FeatureList, LookupList;
 
 
-    valid->root = ftvalid;
+    otvalid->root = ftvalid;
 
     FT_TRACE3(( "validating GSUB table\n" ));
     OTV_INIT;
@@ -567,16 +567,16 @@
     FeatureList = FT_NEXT_USHORT( p );
     LookupList  = FT_NEXT_USHORT( p );
 
-    valid->type_count  = 8;
-    valid->type_funcs  = (OTV_Validate_Func*)otv_gsub_validate_funcs;
-    valid->glyph_count = glyph_count;
+    otvalid->type_count  = 8;
+    otvalid->type_funcs  = (OTV_Validate_Func*)otv_gsub_validate_funcs;
+    otvalid->glyph_count = glyph_count;
 
     otv_LookupList_validate( table + LookupList,
-                             valid );
+                             otvalid );
     otv_FeatureList_validate( table + FeatureList, table + LookupList,
-                              valid );
+                              otvalid );
     otv_ScriptList_validate( table + ScriptList, table + FeatureList,
-                             valid );
+                             otvalid );
 
     FT_TRACE4(( "\n" ));
   }
diff --git a/src/otvalid/otvjstf.c b/src/otvalid/otvjstf.c
index a616a23..f273be8 100644
--- a/src/otvalid/otvjstf.c
+++ b/src/otvalid/otvjstf.c
@@ -34,13 +34,13 @@
 #define JstfPriorityFunc  otv_JstfPriority_validate
 #define JstfLookupFunc    otv_GPOS_subtable_validate
 
-  /* uses valid->extra1 (GSUB lookup count) */
-  /* uses valid->extra2 (GPOS lookup count) */
-  /* sets valid->extra1 (counter)           */
+  /* uses otvalid->extra1 (GSUB lookup count) */
+  /* uses otvalid->extra2 (GPOS lookup count) */
+  /* sets otvalid->extra1 (counter)           */
 
   static void
   otv_JstfPriority_validate( FT_Bytes       table,
-                             OTV_Validator  valid )
+                             OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   table_size;
@@ -63,34 +63,34 @@
 
     OTV_LIMIT_CHECK( 20 );
 
-    gsub_lookup_count = valid->extra1;
-    gpos_lookup_count = valid->extra2;
+    gsub_lookup_count = otvalid->extra1;
+    gpos_lookup_count = otvalid->extra2;
 
     table_size = 20;
 
-    valid->extra1 = gsub_lookup_count;
+    otvalid->extra1 = gsub_lookup_count;
 
     OTV_OPTIONAL_OFFSET( ShrinkageEnableGSUB );
     OTV_SIZE_CHECK( ShrinkageEnableGSUB );
     if ( ShrinkageEnableGSUB )
-      otv_x_ux( table + ShrinkageEnableGSUB, valid );
+      otv_x_ux( table + ShrinkageEnableGSUB, otvalid );
 
     OTV_OPTIONAL_OFFSET( ShrinkageDisableGSUB );
     OTV_SIZE_CHECK( ShrinkageDisableGSUB );
     if ( ShrinkageDisableGSUB )
-      otv_x_ux( table + ShrinkageDisableGSUB, valid );
+      otv_x_ux( table + ShrinkageDisableGSUB, otvalid );
 
-    valid->extra1 = gpos_lookup_count;
+    otvalid->extra1 = gpos_lookup_count;
 
     OTV_OPTIONAL_OFFSET( ShrinkageEnableGPOS );
     OTV_SIZE_CHECK( ShrinkageEnableGPOS );
     if ( ShrinkageEnableGPOS )
-      otv_x_ux( table + ShrinkageEnableGPOS, valid );
+      otv_x_ux( table + ShrinkageEnableGPOS, otvalid );
 
     OTV_OPTIONAL_OFFSET( ShrinkageDisableGPOS );
     OTV_SIZE_CHECK( ShrinkageDisableGPOS );
     if ( ShrinkageDisableGPOS )
-      otv_x_ux( table + ShrinkageDisableGPOS, valid );
+      otv_x_ux( table + ShrinkageDisableGPOS, otvalid );
 
     OTV_OPTIONAL_OFFSET( ShrinkageJstfMax );
     OTV_SIZE_CHECK( ShrinkageJstfMax );
@@ -98,32 +98,32 @@
     {
       /* XXX: check lookup types? */
       OTV_NEST2( JstfMax, JstfLookup );
-      OTV_RUN( table + ShrinkageJstfMax, valid );
+      OTV_RUN( table + ShrinkageJstfMax, otvalid );
     }
 
-    valid->extra1 = gsub_lookup_count;
+    otvalid->extra1 = gsub_lookup_count;
 
     OTV_OPTIONAL_OFFSET( ExtensionEnableGSUB );
     OTV_SIZE_CHECK( ExtensionEnableGSUB );
     if ( ExtensionEnableGSUB )
-      otv_x_ux( table + ExtensionEnableGSUB, valid );
+      otv_x_ux( table + ExtensionEnableGSUB, otvalid );
 
     OTV_OPTIONAL_OFFSET( ExtensionDisableGSUB );
     OTV_SIZE_CHECK( ExtensionDisableGSUB );
     if ( ExtensionDisableGSUB )
-      otv_x_ux( table + ExtensionDisableGSUB, valid );
+      otv_x_ux( table + ExtensionDisableGSUB, otvalid );
 
-    valid->extra1 = gpos_lookup_count;
+    otvalid->extra1 = gpos_lookup_count;
 
     OTV_OPTIONAL_OFFSET( ExtensionEnableGPOS );
     OTV_SIZE_CHECK( ExtensionEnableGPOS );
     if ( ExtensionEnableGPOS )
-      otv_x_ux( table + ExtensionEnableGPOS, valid );
+      otv_x_ux( table + ExtensionEnableGPOS, otvalid );
 
     OTV_OPTIONAL_OFFSET( ExtensionDisableGPOS );
     OTV_SIZE_CHECK( ExtensionDisableGPOS );
     if ( ExtensionDisableGPOS )
-      otv_x_ux( table + ExtensionDisableGPOS, valid );
+      otv_x_ux( table + ExtensionDisableGPOS, otvalid );
 
     OTV_OPTIONAL_OFFSET( ExtensionJstfMax );
     OTV_SIZE_CHECK( ExtensionJstfMax );
@@ -131,22 +131,22 @@
     {
       /* XXX: check lookup types? */
       OTV_NEST2( JstfMax, JstfLookup );
-      OTV_RUN( table + ExtensionJstfMax, valid );
+      OTV_RUN( table + ExtensionJstfMax, otvalid );
     }
 
-    valid->extra1 = gsub_lookup_count;
-    valid->extra2 = gpos_lookup_count;
+    otvalid->extra1 = gsub_lookup_count;
+    otvalid->extra2 = gpos_lookup_count;
 
     OTV_EXIT;
   }
 
 
-  /* sets valid->extra (glyph count)               */
-  /* sets valid->func1 (otv_JstfPriority_validate) */
+  /* sets otvalid->extra (glyph count)               */
+  /* sets otvalid->func1 (otv_JstfPriority_validate) */
 
   static void
   otv_JstfScript_validate( FT_Bytes       table,
-                           OTV_Validator  valid )
+                           OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   table_size;
@@ -170,16 +170,16 @@
     OTV_SIZE_CHECK( ExtGlyph );
     if ( ExtGlyph )
     {
-      valid->extra1 = valid->glyph_count;
+      otvalid->extra1 = otvalid->glyph_count;
       OTV_NEST1( ExtenderGlyph );
-      OTV_RUN( table + ExtGlyph, valid );
+      OTV_RUN( table + ExtGlyph, otvalid );
     }
 
     OTV_SIZE_CHECK( DefJstfLangSys );
     if ( DefJstfLangSys )
     {
       OTV_NEST2( JstfLangSys, JstfPriority );
-      OTV_RUN( table + DefJstfLangSys, valid );
+      OTV_RUN( table + DefJstfLangSys, otvalid );
     }
 
     OTV_LIMIT_CHECK( 6 * JstfLangSysCount );
@@ -190,16 +190,16 @@
     {
       p += 4;       /* skip JstfLangSysTag */
 
-      OTV_RUN( table + FT_NEXT_USHORT( p ), valid );
+      OTV_RUN( table + FT_NEXT_USHORT( p ), otvalid );
     }
 
     OTV_EXIT;
   }
 
 
-  /* sets valid->extra1 (GSUB lookup count) */
-  /* sets valid->extra2 (GPOS lookup count) */
-  /* sets valid->glyph_count                */
+  /* sets otvalid->extra1 (GSUB lookup count) */
+  /* sets otvalid->extra2 (GPOS lookup count) */
+  /* sets otvalid->glyph_count                */
 
   FT_LOCAL_DEF( void )
   otv_JSTF_validate( FT_Bytes      table,
@@ -208,13 +208,14 @@
                      FT_UInt       glyph_count,
                      FT_Validator  ftvalid )
   {
-    OTV_ValidatorRec  validrec;
-    OTV_Validator     valid = &validrec;
+    OTV_ValidatorRec  otvalidrec;
+    OTV_Validator     otvalid = &otvalidrec;
     FT_Bytes          p     = table;
     FT_UInt           JstfScriptCount;
 
 
-    valid->root = ftvalid;
+    otvalid->root = ftvalid;
+
 
     FT_TRACE3(( "validating JSTF table\n" ));
     OTV_INIT;
@@ -231,16 +232,16 @@
     OTV_LIMIT_CHECK( JstfScriptCount * 6 );
 
     if ( gsub )
-      valid->extra1 = otv_GSUBGPOS_get_Lookup_count( gsub );
+      otvalid->extra1 = otv_GSUBGPOS_get_Lookup_count( gsub );
     else
-      valid->extra1 = 0;
+      otvalid->extra1 = 0;
 
     if ( gpos )
-      valid->extra2 = otv_GSUBGPOS_get_Lookup_count( gpos );
+      otvalid->extra2 = otv_GSUBGPOS_get_Lookup_count( gpos );
     else
-      valid->extra2 = 0;
+      otvalid->extra2 = 0;
 
-    valid->glyph_count = glyph_count;
+    otvalid->glyph_count = glyph_count;
 
     /* JstfScriptRecord */
     for ( ; JstfScriptCount > 0; JstfScriptCount-- )
@@ -248,7 +249,7 @@
       p += 4;       /* skip JstfScriptTag */
 
       /* JstfScript */
-      otv_JstfScript_validate( table + FT_NEXT_USHORT( p ), valid );
+      otv_JstfScript_validate( table + FT_NEXT_USHORT( p ), otvalid );
     }
 
     FT_TRACE4(( "\n" ));
diff --git a/src/otvalid/otvmath.c b/src/otvalid/otvmath.c
index 96f841f..d1791f8 100644
--- a/src/otvalid/otvmath.c
+++ b/src/otvalid/otvmath.c
@@ -44,7 +44,7 @@
 
   static void
   otv_MathConstants_validate( FT_Bytes       table,
-                              OTV_Validator  valid )
+                              OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   i;
@@ -66,7 +66,7 @@
       OTV_OPTIONAL_OFFSET( DeviceTableOffset );
       OTV_SIZE_CHECK( DeviceTableOffset );
       if ( DeviceTableOffset )
-        otv_Device_validate( table + DeviceTableOffset, valid );
+        otv_Device_validate( table + DeviceTableOffset, otvalid );
     }
 
     OTV_EXIT;
@@ -84,7 +84,7 @@
 
   static void
   otv_MathItalicsCorrectionInfo_validate( FT_Bytes       table,
-                                          OTV_Validator  valid,
+                                          OTV_Validator  otvalid,
                                           FT_Int         isItalic )
   {
     FT_Bytes  p = table;
@@ -108,7 +108,7 @@
     table_size = 4 + 4 * cnt;
 
     OTV_SIZE_CHECK( Coverage );
-    otv_Coverage_validate( table + Coverage, valid, cnt );
+    otv_Coverage_validate( table + Coverage, otvalid, cnt );
 
     for ( i = 0; i < cnt; ++i )
     {
@@ -116,7 +116,7 @@
       OTV_OPTIONAL_OFFSET( DeviceTableOffset );
       OTV_SIZE_CHECK( DeviceTableOffset );
       if ( DeviceTableOffset )
-        otv_Device_validate( table + DeviceTableOffset, valid );
+        otv_Device_validate( table + DeviceTableOffset, otvalid );
     }
 
     OTV_EXIT;
@@ -133,7 +133,7 @@
 
   static void
   otv_MathKern_validate( FT_Bytes       table,
-                         OTV_Validator  valid )
+                         OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   i, cnt, table_size;
@@ -157,7 +157,7 @@
       OTV_OPTIONAL_OFFSET( DeviceTableOffset );
       OTV_SIZE_CHECK( DeviceTableOffset );
       if ( DeviceTableOffset )
-        otv_Device_validate( table + DeviceTableOffset, valid );
+        otv_Device_validate( table + DeviceTableOffset, otvalid );
     }
 
     /* One more Kerning value */
@@ -167,7 +167,7 @@
       OTV_OPTIONAL_OFFSET( DeviceTableOffset );
       OTV_SIZE_CHECK( DeviceTableOffset );
       if ( DeviceTableOffset )
-        otv_Device_validate( table + DeviceTableOffset, valid );
+        otv_Device_validate( table + DeviceTableOffset, otvalid );
     }
 
     OTV_EXIT;
@@ -176,7 +176,7 @@
 
   static void
   otv_MathKernInfo_validate( FT_Bytes       table,
-                             OTV_Validator  valid )
+                             OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   i, j, cnt, table_size;
@@ -196,7 +196,7 @@
     table_size = 4 + 8 * cnt;
 
     OTV_SIZE_CHECK( Coverage );
-    otv_Coverage_validate( table + Coverage, valid, cnt );
+    otv_Coverage_validate( table + Coverage, otvalid, cnt );
 
     for ( i = 0; i < cnt; ++i )
     {
@@ -205,7 +205,7 @@
         OTV_OPTIONAL_OFFSET( MKRecordOffset );
         OTV_SIZE_CHECK( MKRecordOffset );
         if ( MKRecordOffset )
-          otv_MathKern_validate( table + MKRecordOffset, valid );
+          otv_MathKern_validate( table + MKRecordOffset, otvalid );
       }
     }
 
@@ -223,7 +223,7 @@
 
   static void
   otv_MathGlyphInfo_validate( FT_Bytes       table,
-                              OTV_Validator  valid )
+                              OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   MathItalicsCorrectionInfo, MathTopAccentAttachment;
@@ -241,22 +241,22 @@
 
     if ( MathItalicsCorrectionInfo )
       otv_MathItalicsCorrectionInfo_validate(
-        table + MathItalicsCorrectionInfo, valid, TRUE );
+        table + MathItalicsCorrectionInfo, otvalid, TRUE );
 
     /* Italic correction and Top Accent Attachment have the same format */
     if ( MathTopAccentAttachment )
       otv_MathItalicsCorrectionInfo_validate(
-        table + MathTopAccentAttachment, valid, FALSE );
+        table + MathTopAccentAttachment, otvalid, FALSE );
 
     if ( ExtendedShapeCoverage )
     {
       OTV_NAME_ENTER( "ExtendedShapeCoverage" );
-      otv_Coverage_validate( table + ExtendedShapeCoverage, valid, -1 );
+      otv_Coverage_validate( table + ExtendedShapeCoverage, otvalid, -1 );
       OTV_EXIT;
     }
 
     if ( MathKernInfo )
-      otv_MathKernInfo_validate( table + MathKernInfo, valid );
+      otv_MathKernInfo_validate( table + MathKernInfo, otvalid );
 
     OTV_EXIT;
   }
@@ -272,7 +272,7 @@
 
   static void
   otv_GlyphAssembly_validate( FT_Bytes       table,
-                              OTV_Validator  valid )
+                              OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   pcnt, table_size;
@@ -294,7 +294,7 @@
 
     OTV_SIZE_CHECK( DeviceTableOffset );
     if ( DeviceTableOffset )
-      otv_Device_validate( table + DeviceTableOffset, valid );
+      otv_Device_validate( table + DeviceTableOffset, otvalid );
 
     for ( i = 0; i < pcnt; ++i )
     {
@@ -302,7 +302,7 @@
 
 
       gid = FT_NEXT_USHORT( p );
-      if ( gid >= valid->glyph_count )
+      if ( gid >= otvalid->glyph_count )
         FT_INVALID_GLYPH_ID;
       p += 2*4;             /* skip the Start, End, Full, and Flags fields */
     }
@@ -313,7 +313,7 @@
 
   static void
   otv_MathGlyphConstruction_validate( FT_Bytes       table,
-                                      OTV_Validator  valid )
+                                      OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   vcnt, table_size;
@@ -338,14 +338,14 @@
 
 
       gid = FT_NEXT_USHORT( p );
-      if ( gid >= valid->glyph_count )
+      if ( gid >= otvalid->glyph_count )
         FT_INVALID_GLYPH_ID;
       p += 2;                          /* skip the size */
     }
 
     OTV_SIZE_CHECK( GlyphAssembly );
     if ( GlyphAssembly )
-      otv_GlyphAssembly_validate( table+GlyphAssembly, valid );
+      otv_GlyphAssembly_validate( table+GlyphAssembly, otvalid );
 
     /* OTV_EXIT; */
   }
@@ -353,7 +353,7 @@
 
   static void
   otv_MathVariants_validate( FT_Bytes       table,
-                             OTV_Validator  valid )
+                             OTV_Validator  otvalid )
   {
     FT_Bytes  p = table;
     FT_UInt   vcnt, hcnt, i, table_size;
@@ -378,24 +378,24 @@
 
     OTV_SIZE_CHECK( VCoverage );
     if ( VCoverage )
-      otv_Coverage_validate( table + VCoverage, valid, vcnt );
+      otv_Coverage_validate( table + VCoverage, otvalid, vcnt );
 
     OTV_SIZE_CHECK( HCoverage );
     if ( HCoverage )
-      otv_Coverage_validate( table + HCoverage, valid, hcnt );
+      otv_Coverage_validate( table + HCoverage, otvalid, hcnt );
 
     for ( i = 0; i < vcnt; ++i )
     {
       OTV_OPTIONAL_OFFSET( Offset );
       OTV_SIZE_CHECK( Offset );
-      otv_MathGlyphConstruction_validate( table + Offset, valid );
+      otv_MathGlyphConstruction_validate( table + Offset, otvalid );
     }
 
     for ( i = 0; i < hcnt; ++i )
     {
       OTV_OPTIONAL_OFFSET( Offset );
       OTV_SIZE_CHECK( Offset );
-      otv_MathGlyphConstruction_validate( table + Offset, valid );
+      otv_MathGlyphConstruction_validate( table + Offset, otvalid );
     }
 
     OTV_EXIT;
@@ -410,20 +410,20 @@
   /*************************************************************************/
   /*************************************************************************/
 
-  /* sets valid->glyph_count */
+  /* sets otvalid->glyph_count */
 
   FT_LOCAL_DEF( void )
   otv_MATH_validate( FT_Bytes      table,
                      FT_UInt       glyph_count,
                      FT_Validator  ftvalid )
   {
-    OTV_ValidatorRec  validrec;
-    OTV_Validator     valid = &validrec;
-    FT_Bytes          p     = table;
+    OTV_ValidatorRec  otvalidrec;
+    OTV_Validator     otvalid = &otvalidrec;
+    FT_Bytes          p       = table;
     FT_UInt           MathConstants, MathGlyphInfo, MathVariants;
 
 
-    valid->root = ftvalid;
+    otvalid->root = ftvalid;
 
     FT_TRACE3(( "validating MATH table\n" ));
     OTV_INIT;
@@ -437,14 +437,14 @@
     MathGlyphInfo = FT_NEXT_USHORT( p );
     MathVariants  = FT_NEXT_USHORT( p );
 
-    valid->glyph_count = glyph_count;
+    otvalid->glyph_count = glyph_count;
 
     otv_MathConstants_validate( table + MathConstants,
-                                valid );
+                                otvalid );
     otv_MathGlyphInfo_validate( table + MathGlyphInfo,
-                                valid );
+                                otvalid );
     otv_MathVariants_validate ( table + MathVariants,
-                                valid );
+                                otvalid );
 
     FT_TRACE4(( "\n" ));
   }
diff --git a/src/pcf/pcfread.c b/src/pcf/pcfread.c
index 998cbed..a29a9e3 100644
--- a/src/pcf/pcfread.c
+++ b/src/pcf/pcfread.c
@@ -2,7 +2,7 @@
 
     FreeType font driver for pcf fonts
 
-  Copyright 2000-2010, 2012, 2013 by
+  Copyright 2000-2010, 2012-2014 by
   Francesco Zappa Nardelli
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
@@ -78,7 +78,7 @@ THE SOFTWARE.
     FT_FRAME_START( 16  ),
       FT_FRAME_ULONG_LE( type ),
       FT_FRAME_ULONG_LE( format ),
-      FT_FRAME_ULONG_LE( size ),
+      FT_FRAME_ULONG_LE( size ),   /* rounded up to a multiple of 4 */
       FT_FRAME_ULONG_LE( offset ),
     FT_FRAME_END
   };
@@ -95,9 +95,11 @@ THE SOFTWARE.
     FT_Memory  memory = FT_FACE( face )->memory;
     FT_UInt    n;
 
+    FT_ULong   size;
 
-    if ( FT_STREAM_SEEK ( 0 )                          ||
-         FT_STREAM_READ_FIELDS ( pcf_toc_header, toc ) )
+
+    if ( FT_STREAM_SEEK( 0 )                          ||
+         FT_STREAM_READ_FIELDS( pcf_toc_header, toc ) )
       return FT_THROW( Cannot_Open_Resource );
 
     if ( toc->version != PCF_FILE_VERSION                 ||
@@ -154,14 +156,35 @@ THE SOFTWARE.
         break;
     }
 
-    /* we now check whether the `size' and `offset' values are reasonable: */
-    /* `offset' + `size' must not exceed the stream size                   */
+    /*
+     *  We now check whether the `size' and `offset' values are reasonable:
+     *  `offset' + `size' must not exceed the stream size.
+     *
+     *  Note, however, that X11's `pcfWriteFont' routine (used by the
+     *  `bdftopcf' program to create PDF font files) has two special
+     *  features.
+     *
+     *  - It always assigns the accelerator table a size of 100 bytes in the
+     *    TOC, regardless of its real size, which can vary between 34 and 72
+     *    bytes.
+     *
+     *  - Due to the way the routine is designed, it ships out the last font
+     *    table with its real size, ignoring the TOC's size value.  Since
+     *    the TOC size values are always rounded up to a multiple of 4, the
+     *    difference can be up to three bytes for all tables except the
+     *    accelerator table, for which the difference can be as large as 66
+     *    bytes.
+     *
+     */
+
     tables = face->toc.tables;
-    for ( n = 0; n < toc->count; n++ )
+    size   = stream->size;
+
+    for ( n = 0; n < toc->count - 1; n++ )
     {
       /* we need two checks to avoid overflow */
-      if ( ( tables->size   > stream->size                ) ||
-           ( tables->offset > stream->size - tables->size ) )
+      if ( ( tables->size   > size                ) ||
+           ( tables->offset > size - tables->size ) )
       {
         error = FT_THROW( Invalid_Table );
         goto Exit;
@@ -169,6 +192,16 @@ THE SOFTWARE.
       tables++;
     }
 
+    /* only check `tables->offset' for last table element ... */
+    if ( ( tables->offset > size ) )
+    {
+      error = FT_THROW( Invalid_Table );
+      goto Exit;
+    }
+    /* ... and adjust `tables->size' to the real value if necessary */
+    if ( tables->size > size - tables->offset )
+      tables->size = size - tables->offset;
+
 #ifdef FT_DEBUG_LEVEL_TRACE
 
     {
@@ -733,8 +766,8 @@ THE SOFTWARE.
 
     FT_TRACE4(( "  number of bitmaps: %d\n", nbitmaps ));
 
-    /* XXX: PCF_Face->nmetrics is singed FT_Long, see pcf.h */
-    if ( face->nmetrics < 0 || nbitmaps != ( FT_ULong )face->nmetrics )
+    /* XXX: PCF_Face->nmetrics is signed FT_Long, see pcf.h */
+    if ( face->nmetrics < 0 || nbitmaps != (FT_ULong)face->nmetrics )
       return FT_THROW( Invalid_File_Format );
 
     if ( FT_NEW_ARRAY( offsets, nbitmaps ) )
diff --git a/src/pfr/pfrload.c b/src/pfr/pfrload.c
index 97c130a..f68d016 100644
--- a/src/pfr/pfrload.c
+++ b/src/pfr/pfrload.c
@@ -179,7 +179,7 @@
     if ( header->signature  != 0x50465230L ||   /* "PFR0" */
          header->version     > 4           ||
          header->header_size < 58          ||
-         header->signature2 != 0x0d0a      )    /* CR/LF  */
+         header->signature2 != 0x0D0A      )    /* CR/LF  */
     {
       result = 0;
     }
diff --git a/src/psaux/psconv.c b/src/psaux/psconv.c
index 7792a62..22e8cf2 100644
--- a/src/psaux/psconv.c
+++ b/src/psaux/psconv.c
@@ -124,7 +124,7 @@
       if ( IS_PS_SPACE( *p ) || *p OP 0x80 )
         break;
 
-      c = ft_char_table[*p & 0x7f];
+      c = ft_char_table[*p & 0x7F];
 
       if ( c < 0 || c >= base )
         break;
@@ -245,7 +245,7 @@
         if ( IS_PS_SPACE( *p ) || *p OP 0x80 )
           break;
 
-        c = ft_char_table[*p & 0x7f];
+        c = ft_char_table[*p & 0x7F];
 
         if ( c < 0 || c >= 10 )
           break;
@@ -521,7 +521,7 @@
       if ( *p OP 0x80 )
         break;
 
-      c = ft_char_table[*p & 0x7f];
+      c = ft_char_table[*p & 0x7F];
 
       if ( (unsigned)c >= 16 )
         break;
diff --git a/src/psnames/psmodule.c b/src/psnames/psmodule.c
index 0a5bcb7..42c9aff 100644
--- a/src/psnames/psmodule.c
+++ b/src/psnames/psmodule.c
@@ -4,7 +4,7 @@
 /*                                                                         */
 /*    PSNames module implementation (body).                                */
 /*                                                                         */
-/*  Copyright 1996-2003, 2005-2008, 2012, 2013 by                          */
+/*  Copyright 1996-2003, 2005-2008, 2012-2014 by                           */
 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
 /*                                                                         */
 /*  This file is part of the FreeType project, and may only be used,       */
@@ -563,7 +563,7 @@
   psnames_get_service( FT_Module    module,
                        const char*  service_id )
   {
-    /* PSCMAPS_SERVICES_GET derefers `library' in PIC mode */
+    /* PSCMAPS_SERVICES_GET dereferences `library' in PIC mode */
 #ifdef FT_CONFIG_OPTION_PIC
     FT_Library  library;
 
diff --git a/src/sfnt/sfdriver.c b/src/sfnt/sfdriver.c
index bd8dd2e..badb159 100644
--- a/src/sfnt/sfdriver.c
+++ b/src/sfnt/sfdriver.c
@@ -427,7 +427,7 @@
   sfnt_get_interface( FT_Module    module,
                       const char*  module_interface )
   {
-    /* SFNT_SERVICES_GET derefers `library' in PIC mode */
+    /* SFNT_SERVICES_GET dereferences `library' in PIC mode */
 #ifdef FT_CONFIG_OPTION_PIC
     FT_Library  library;
 
diff --git a/src/smooth/ftgrays.c b/src/smooth/ftgrays.c
index 9d37d64..131ad27 100644
--- a/src/smooth/ftgrays.c
+++ b/src/smooth/ftgrays.c
@@ -405,6 +405,8 @@ typedef ptrdiff_t  FT_PtrDist;
 
   typedef struct  gray_TWorker_
   {
+    ft_jmp_buf  jump_buffer;
+
     TCoord  ex, ey;
     TPos    min_ex, max_ex;
     TPos    min_ey, max_ey;
@@ -440,8 +442,6 @@ typedef ptrdiff_t  FT_PtrDist;
     int  band_size;
     int  band_shoot;
 
-    ft_jmp_buf  jump_buffer;
-
     void*       buffer;
     long        buffer_size;
 
diff --git a/src/tools/ftrandom/ftrandom.c b/src/tools/ftrandom/ftrandom.c
index 7c97957..9a5b632 100644
--- a/src/tools/ftrandom/ftrandom.c
+++ b/src/tools/ftrandom/ftrandom.c
@@ -449,9 +449,9 @@
       fseek( new, getRandom( 0, item->len - 1 ), SEEK_SET );
 
       if ( item->isbinary )
-        putc( getRandom( 0, 0xff ), new );
+        putc( getRandom( 0, 0xFF ), new );
       else if ( item->isascii )
-        putc( getRandom( 0x20, 0x7e ), new );
+        putc( getRandom( 0x20, 0x7E ), new );
       else
       {
         int  hex = getRandom( 0, 15 );
diff --git a/src/tools/test_trig.c b/src/tools/test_trig.c
index 49d927e..99ac1cf 100644
--- a/src/tools/test_trig.c
+++ b/src/tools/test_trig.c
@@ -20,7 +20,7 @@
     int  i;
 
 
-    for ( i = 0; i < FT_ANGLE_2PI; i += 0x10000 )
+    for ( i = 0; i < FT_ANGLE_2PI; i += 0x10000L )
     {
       FT_Fixed  f1, f2;
       double    d2;
@@ -46,7 +46,7 @@
     int  i;
 
 
-    for ( i = 0; i < FT_ANGLE_2PI; i += 0x10000 )
+    for ( i = 0; i < FT_ANGLE_2PI; i += 0x10000L )
     {
       FT_Fixed  f1, f2;
       double    d2;
@@ -72,7 +72,7 @@
     int  i;
 
 
-    for ( i = 0; i < FT_ANGLE_PI2-0x2000000; i += 0x10000 )
+    for ( i = 0; i < FT_ANGLE_PI2 - 0x2000000L; i += 0x10000L )
     {
       FT_Fixed  f1, f2;
       double    d2;
@@ -98,7 +98,7 @@
     int  i;
 
 
-    for ( i = 0; i < FT_ANGLE_2PI; i += 0x10000 )
+    for ( i = 0; i < FT_ANGLE_2PI; i += 0x10000L )
     {
       FT_Fixed  c2, s2;
       double    l, a, c1, s1;
@@ -133,7 +133,7 @@
     int  i;
 
 
-    for ( i = 0; i < FT_ANGLE_2PI; i += 0x10000 )
+    for ( i = 0; i < FT_ANGLE_2PI; i += 0x10000L )
     {
       FT_Vector  v;
       double     a, c1, s1;
@@ -166,7 +166,7 @@
     int  i;
 
 
-    for ( i = 0; i < FT_ANGLE_2PI; i += 0x10000 )
+    for ( i = 0; i < FT_ANGLE_2PI; i += 0x10000L )
     {
       FT_Vector  v;
       FT_Fixed   l, l2;
@@ -193,7 +193,7 @@
     int  rotate;
 
 
-    for ( rotate = 0; rotate < FT_ANGLE_2PI; rotate += 0x10000 )
+    for ( rotate = 0; rotate < FT_ANGLE_2PI; rotate += 0x10000L )
     {
       double  ra, cra, sra;
       int     i;
@@ -203,7 +203,7 @@
       cra = cos( ra );
       sra = sin( ra );
 
-      for ( i = 0; i < FT_ANGLE_2PI; i += 0x10000 )
+      for ( i = 0; i < FT_ANGLE_2PI; i += 0x10000L )
       {
         FT_Fixed   c2, s2, c4, s4;
         FT_Vector  v;
diff --git a/src/truetype/ttdriver.c b/src/truetype/ttdriver.c
index 64e433d..ecf4cdc 100644
--- a/src/truetype/ttdriver.c
+++ b/src/truetype/ttdriver.c
@@ -481,7 +481,7 @@
     SFNT_Service         sfnt;
 
 
-    /* TT_SERVICES_GET derefers `library' in PIC mode */
+    /* TT_SERVICES_GET dereferences `library' in PIC mode */
 #ifdef FT_CONFIG_OPTION_PIC
     if ( !driver )
       return NULL;
diff --git a/src/truetype/ttinterp.c b/src/truetype/ttinterp.c
index 2dc5f79..eccd4aa 100644
--- a/src/truetype/ttinterp.c
+++ b/src/truetype/ttinterp.c
@@ -5625,7 +5625,7 @@
   /*************************************************************************/
   /*                                                                       */
   /* INSTCTRL[]:   INSTruction ConTRoL                                     */
-  /* Opcode range: 0x8e                                                    */
+  /* Opcode range: 0x8E                                                    */
   /* Stack:        int32 int32 -->                                         */
   /*                                                                       */
   static void
diff --git a/src/truetype/ttobjs.c b/src/truetype/ttobjs.c
index a73529d..4707dfe 100644
--- a/src/truetype/ttobjs.c
+++ b/src/truetype/ttobjs.c
@@ -256,89 +256,89 @@
 #define TRICK_SFNT_ID_prep  2
 
       { /* MingLiU 1995 */
-        { 0x05bcf058, 0x000002e4 }, /* cvt  */
-        { 0x28233bf1, 0x000087c4 }, /* fpgm */
-        { 0xa344a1ea, 0x000001e1 }  /* prep */
+        { 0x05BCF058UL, 0x000002E4UL }, /* cvt  */
+        { 0x28233BF1UL, 0x000087C4UL }, /* fpgm */
+        { 0xA344A1EAUL, 0x000001E1UL }  /* prep */
       },
       { /* MingLiU 1996- */
-        { 0x05bcf058, 0x000002e4 }, /* cvt  */
-        { 0x28233bf1, 0x000087c4 }, /* fpgm */
-        { 0xa344a1eb, 0x000001e1 }  /* prep */
+        { 0x05BCF058UL, 0x000002E4UL }, /* cvt  */
+        { 0x28233BF1UL, 0x000087C4UL }, /* fpgm */
+        { 0xA344A1EBUL, 0x000001E1UL }  /* prep */
       },
       { /* DFKaiShu */
-        { 0x11e5ead4, 0x00000350 }, /* cvt  */
-        { 0x5a30ca3b, 0x00009063 }, /* fpgm */
-        { 0x13a42602, 0x0000007e }  /* prep */
+        { 0x11E5EAD4UL, 0x00000350UL }, /* cvt  */
+        { 0x5A30CA3BUL, 0x00009063UL }, /* fpgm */
+        { 0x13A42602UL, 0x0000007EUL }  /* prep */
       },
       { /* HuaTianKaiTi */
-        { 0xfffbfffc, 0x00000008 }, /* cvt  */
-        { 0x9c9e48b8, 0x0000bea2 }, /* fpgm */
-        { 0x70020112, 0x00000008 }  /* prep */
+        { 0xFFFBFFFCUL, 0x00000008UL }, /* cvt  */
+        { 0x9C9E48B8UL, 0x0000BEA2UL }, /* fpgm */
+        { 0x70020112UL, 0x00000008UL }  /* prep */
       },
       { /* HuaTianSongTi */
-        { 0xfffbfffc, 0x00000008 }, /* cvt  */
-        { 0x0a5a0483, 0x00017c39 }, /* fpgm */
-        { 0x70020112, 0x00000008 }  /* prep */
+        { 0xFFFBFFFCUL, 0x00000008UL }, /* cvt  */
+        { 0x0A5A0483UL, 0x00017C39UL }, /* fpgm */
+        { 0x70020112UL, 0x00000008UL }  /* prep */
       },
       { /* NEC fadpop7.ttf */
-        { 0x00000000, 0x00000000 }, /* cvt  */
-        { 0x40c92555, 0x000000e5 }, /* fpgm */
-        { 0xa39b58e3, 0x0000117c }  /* prep */
+        { 0x00000000UL, 0x00000000UL }, /* cvt  */
+        { 0x40C92555UL, 0x000000E5UL }, /* fpgm */
+        { 0xA39B58E3UL, 0x0000117CUL }  /* prep */
       },
       { /* NEC fadrei5.ttf */
-        { 0x00000000, 0x00000000 }, /* cvt  */
-        { 0x33c41652, 0x000000e5 }, /* fpgm */
-        { 0x26d6c52a, 0x00000f6a }  /* prep */
+        { 0x00000000UL, 0x00000000UL }, /* cvt  */
+        { 0x33C41652UL, 0x000000E5UL }, /* fpgm */
+        { 0x26D6C52AUL, 0x00000F6AUL }  /* prep */
       },
       { /* NEC fangot7.ttf */
-        { 0x00000000, 0x00000000 }, /* cvt  */
-        { 0x6db1651d, 0x0000019d }, /* fpgm */
-        { 0x6c6e4b03, 0x00002492 }  /* prep */
+        { 0x00000000UL, 0x00000000UL }, /* cvt  */
+        { 0x6DB1651DUL, 0x0000019DUL }, /* fpgm */
+        { 0x6C6E4B03UL, 0x00002492UL }  /* prep */
       },
       { /* NEC fangyo5.ttf */
-        { 0x00000000, 0x00000000 }, /* cvt  */
-        { 0x40c92555, 0x000000e5 }, /* fpgm */
-        { 0xde51fad0, 0x0000117c }  /* prep */
+        { 0x00000000UL, 0x00000000UL }, /* cvt  */
+        { 0x40C92555UL, 0x000000E5UL }, /* fpgm */
+        { 0xDE51FAD0UL, 0x0000117CUL }  /* prep */
       },
       { /* NEC fankyo5.ttf */
-        { 0x00000000, 0x00000000 }, /* cvt  */
-        { 0x85e47664, 0x000000e5 }, /* fpgm */
-        { 0xa6c62831, 0x00001caa }  /* prep */
+        { 0x00000000UL, 0x00000000UL }, /* cvt  */
+        { 0x85E47664UL, 0x000000E5UL }, /* fpgm */
+        { 0xA6C62831UL, 0x00001CAAUL }  /* prep */
       },
       { /* NEC fanrgo5.ttf */
-        { 0x00000000, 0x00000000 }, /* cvt  */
-        { 0x2d891cfd, 0x0000019d }, /* fpgm */
-        { 0xa0604633, 0x00001de8 }  /* prep */
+        { 0x00000000UL, 0x00000000UL }, /* cvt  */
+        { 0x2D891CFDUL, 0x0000019DUL }, /* fpgm */
+        { 0xA0604633UL, 0x00001DE8UL }  /* prep */
       },
       { /* NEC fangot5.ttc */
-        { 0x00000000, 0x00000000 }, /* cvt  */
-        { 0x40aa774c, 0x000001cb }, /* fpgm */
-        { 0x9b5caa96, 0x00001f9a }  /* prep */
+        { 0x00000000UL, 0x00000000UL }, /* cvt  */
+        { 0x40AA774CUL, 0x000001CBUL }, /* fpgm */
+        { 0x9B5CAA96UL, 0x00001F9AUL }  /* prep */
       },
       { /* NEC fanmin3.ttc */
-        { 0x00000000, 0x00000000 }, /* cvt  */
-        { 0x0d3de9cb, 0x00000141 }, /* fpgm */
-        { 0xd4127766, 0x00002280 }  /* prep */
+        { 0x00000000UL, 0x00000000UL }, /* cvt  */
+        { 0x0D3DE9CBUL, 0x00000141UL }, /* fpgm */
+        { 0xD4127766UL, 0x00002280UL }  /* prep */
       },
       { /* NEC FA-Gothic, 1996 */
-        { 0x00000000, 0x00000000 }, /* cvt  */
-        { 0x4a692698, 0x000001f0 }, /* fpgm */
-        { 0x340d4346, 0x00001fca }  /* prep */
+        { 0x00000000UL, 0x00000000UL }, /* cvt  */
+        { 0x4A692698UL, 0x000001F0UL }, /* fpgm */
+        { 0x340D4346UL, 0x00001FCAUL }  /* prep */
       },
       { /* NEC FA-Minchou, 1996 */
-        { 0x00000000, 0x00000000 }, /* cvt  */
-        { 0xcd34c604, 0x00000166 }, /* fpgm */
-        { 0x6cf31046, 0x000022b0 }  /* prep */
+        { 0x00000000UL, 0x00000000UL }, /* cvt  */
+        { 0xCD34C604UL, 0x00000166UL }, /* fpgm */
+        { 0x6CF31046UL, 0x000022B0UL }  /* prep */
       },
       { /* NEC FA-RoundGothicB, 1996 */
-        { 0x00000000, 0x00000000 }, /* cvt  */
-        { 0x5da75315, 0x0000019d }, /* fpgm */
-        { 0x40745a5f, 0x000022e0 }  /* prep */
+        { 0x00000000UL, 0x00000000UL }, /* cvt  */
+        { 0x5DA75315UL, 0x0000019DUL }, /* fpgm */
+        { 0x40745A5FUL, 0x000022E0UL }  /* prep */
       },
       { /* NEC FA-RoundGothicM, 1996 */
-        { 0x00000000, 0x00000000 }, /* cvt  */
-        { 0xf055fc48, 0x000001c2 }, /* fpgm */
-        { 0x3900ded3, 0x00001e18 }  /* prep */
+        { 0x00000000UL, 0x00000000UL }, /* cvt  */
+        { 0xF055FC48UL, 0x000001C2UL }, /* fpgm */
+        { 0x3900DED3UL, 0x00001E18UL }  /* prep */
       }
     };
 
@@ -1116,6 +1116,7 @@
     TT_Size   size  = (TT_Size)ttsize;
     FT_Error  error = FT_Err_Ok;
 
+
 #ifdef TT_USE_BYTECODE_INTERPRETER
     size->bytecode_ready = -1;
     size->cvt_ready      = -1;
@@ -1146,8 +1147,7 @@
 
 
 #ifdef TT_USE_BYTECODE_INTERPRETER
-    if ( size->bytecode_ready >= 0 )
-      tt_size_done_bytecode( ttsize );
+    tt_size_done_bytecode( ttsize );
 #endif
 
     size->ttmetrics.valid = FALSE;
diff --git a/src/type42/t42parse.c b/src/type42/t42parse.c
index fd3d669..5070853 100644
--- a/src/type42/t42parse.c
+++ b/src/type42/t42parse.c
@@ -580,6 +580,12 @@
 
         /* don't include delimiters */
         string_size = (FT_Long)( ( parser->root.cursor - cur - 2 + 1 ) / 2 );
+        if ( !string_size )
+        {
+          FT_ERROR(( "t42_parse_sfnts: invalid data in sfnts array\n" ));
+          error = FT_THROW( Invalid_File_Format );
+          goto Fail;
+        }
         if ( FT_REALLOC( string_buf, old_string_size, string_size ) )
           goto Fail;
 
@@ -661,6 +667,13 @@
             status         = BEFORE_TABLE_DIR;
             face->ttf_size = 12 + 16 * num_tables;
 
+            if ( (FT_ULong)( limit - parser->root.cursor ) < face->ttf_size )
+            {
+              FT_ERROR(( "t42_parse_sfnts: invalid data in sfnts array\n" ));
+              error = FT_THROW( Invalid_File_Format );
+              goto Fail;
+            }
+
             if ( FT_REALLOC( face->ttf_data, 12, face->ttf_size ) )
               goto Fail;
           }
diff --git a/src/winfonts/winfnt.c b/src/winfonts/winfnt.c
index f90b084..4705c53 100644
--- a/src/winfonts/winfnt.c
+++ b/src/winfonts/winfnt.c
@@ -72,12 +72,12 @@
 
     FT_FRAME_START( 248 ),
       FT_FRAME_ULONG_LE  ( magic ),   /* PE00 */
-      FT_FRAME_USHORT_LE ( machine ), /* 0x014c - i386 */
+      FT_FRAME_USHORT_LE ( machine ), /* 0x014C - i386 */
       FT_FRAME_USHORT_LE ( number_of_sections ),
       FT_FRAME_SKIP_BYTES( 12 ),
       FT_FRAME_USHORT_LE ( size_of_optional_header ),
       FT_FRAME_SKIP_BYTES( 2 ),
-      FT_FRAME_USHORT_LE ( magic32 ), /* 0x10b */
+      FT_FRAME_USHORT_LE ( magic32 ), /* 0x10B */
       FT_FRAME_SKIP_BYTES( 110 ),
       FT_FRAME_ULONG_LE  ( rsrc_virtual_address ),
       FT_FRAME_ULONG_LE  ( rsrc_size ),
@@ -412,9 +412,9 @@
                     pe32_header.rsrc_size ));
 
         if ( pe32_header.magic != WINFNT_PE_MAGIC /* check full signature */ ||
-             pe32_header.machine != 0x014c /* i386 */                        ||
-             pe32_header.size_of_optional_header != 0xe0 /* FIXME */         ||
-             pe32_header.magic32 != 0x10b                                    )
+             pe32_header.machine != 0x014C /* i386 */                        ||
+             pe32_header.size_of_optional_header != 0xE0 /* FIXME */         ||
+             pe32_header.magic32 != 0x10B                                    )
         {
           FT_TRACE2(( "this file has an invalid PE header\n" ));
           error = FT_THROW( Invalid_File_Format );
